[{"/Users/simen/repos/jest/packages/jest-snapshot/src/InlineSnapshots.ts":"1","/Users/simen/repos/jest/packages/jest-snapshot/src/SnapshotResolver.ts":"2","/Users/simen/repos/jest/packages/jest-snapshot/src/State.ts":"3","/Users/simen/repos/jest/packages/jest-snapshot/src/__tests__/InlineSnapshots.test.ts":"4","/Users/simen/repos/jest/packages/jest-snapshot/src/__tests__/SnapshotResolver.test.ts":"5","/Users/simen/repos/jest/packages/jest-snapshot/src/__tests__/dedentLines.test.ts":"6","/Users/simen/repos/jest/packages/jest-snapshot/src/__tests__/matcher.test.ts":"7","/Users/simen/repos/jest/packages/jest-snapshot/src/__tests__/mockSerializer.test.ts":"8","/Users/simen/repos/jest/packages/jest-snapshot/src/__tests__/plugins.test.ts":"9","/Users/simen/repos/jest/packages/jest-snapshot/src/__tests__/printSnapshot.test.ts":"10","/Users/simen/repos/jest/packages/jest-snapshot/src/__tests__/throwMatcher.test.ts":"11","/Users/simen/repos/jest/packages/jest-snapshot/src/__tests__/utils.test.ts":"12","/Users/simen/repos/jest/packages/jest-snapshot/src/colors.ts":"13","/Users/simen/repos/jest/packages/jest-snapshot/src/dedentLines.ts":"14","/Users/simen/repos/jest/packages/jest-snapshot/src/index.ts":"15","/Users/simen/repos/jest/packages/jest-snapshot/src/mockSerializer.ts":"16","/Users/simen/repos/jest/packages/jest-snapshot/src/plugins.ts":"17","/Users/simen/repos/jest/packages/jest-snapshot/src/printSnapshot.ts":"18","/Users/simen/repos/jest/packages/jest-snapshot/src/types.ts":"19","/Users/simen/repos/jest/packages/jest-snapshot/src/utils.ts":"20"},{"size":12367,"mtime":1665737657509,"results":"21","hashOfConfig":"22"},{"size":4276,"mtime":1665737657510,"results":"23","hashOfConfig":"22"},{"size":8870,"mtime":1665737657510,"results":"24","hashOfConfig":"22"},{"size":18561,"mtime":1665737657510,"results":"25","hashOfConfig":"22"},{"size":3804,"mtime":1662710982172,"results":"26","hashOfConfig":"22"},{"size":6035,"mtime":1665737657511,"results":"27","hashOfConfig":"22"},{"size":691,"mtime":1665737657511,"results":"28","hashOfConfig":"22"},{"size":4214,"mtime":1665737657511,"results":"29","hashOfConfig":"22"},{"size":1333,"mtime":1665737657511,"results":"30","hashOfConfig":"22"},{"size":40141,"mtime":1665737657511,"results":"31","hashOfConfig":"22"},{"size":1609,"mtime":1665737657511,"results":"32","hashOfConfig":"22"},{"size":14007,"mtime":1665737657512,"results":"33","hashOfConfig":"22"},{"size":636,"mtime":1662708144230,"results":"34","hashOfConfig":"22"},{"size":3804,"mtime":1665461180572,"results":"35","hashOfConfig":"22"},{"size":14606,"mtime":1665737657512,"results":"36","hashOfConfig":"22"},{"size":1312,"mtime":1664535326146,"results":"37","hashOfConfig":"22"},{"size":934,"mtime":1662710982173,"results":"38","hashOfConfig":"22"},{"size":9292,"mtime":1665737657512,"results":"39","hashOfConfig":"22"},{"size":2638,"mtime":1665737657512,"results":"40","hashOfConfig":"22"},{"size":8282,"mtime":1664535326147,"results":"41","hashOfConfig":"22"},{"filePath":"42","messages":"43","suppressedMessages":"44","errorCount":23,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"45"},"7p0edu",{"filePath":"46","messages":"47","suppressedMessages":"48","errorCount":2,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"49"},{"filePath":"50","messages":"51","suppressedMessages":"52","errorCount":11,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"53"},{"filePath":"54","messages":"55","suppressedMessages":"56","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"57","messages":"58","suppressedMessages":"59","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"60","messages":"61","suppressedMessages":"62","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"63","messages":"64","suppressedMessages":"65","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"66","messages":"67","suppressedMessages":"68","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"69","messages":"70","suppressedMessages":"71","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"72","messages":"73","suppressedMessages":"74","errorCount":26,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"75"},{"filePath":"76","messages":"77","suppressedMessages":"78","errorCount":3,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"79"},{"filePath":"80","messages":"81","suppressedMessages":"82","errorCount":6,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"83"},{"filePath":"84","messages":"85","suppressedMessages":"86","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"87","messages":"88","suppressedMessages":"89","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"90","messages":"91","suppressedMessages":"92","errorCount":19,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"93"},{"filePath":"94","messages":"95","suppressedMessages":"96","errorCount":11,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"97"},{"filePath":"98","messages":"99","suppressedMessages":"100","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"101","messages":"102","suppressedMessages":"103","errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"104"},{"filePath":"105","messages":"106","suppressedMessages":"107","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"108","messages":"109","suppressedMessages":"110","errorCount":32,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"111"},"/Users/simen/repos/jest/packages/jest-snapshot/src/InlineSnapshots.ts",["112","113","114","115","116","117","118","119","120","121","122","123","124","125","126","127","128","129","130","131","132","133","134"],[],"/**\n * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport * as path from 'path';\nimport type {ParseResult, PluginItem} from '@babel/core';\nimport {Expression, File, Program, isAwaitExpression} from '@babel/types';\nimport * as fs from 'graceful-fs';\nimport type {\n  CustomParser as PrettierCustomParser,\n  BuiltInParserName as PrettierParserName,\n} from 'prettier';\nimport semver = require('semver');\nimport type {Frame} from 'jest-message-util';\nimport {escapeBacktickString} from './utils';\n\n// prettier-ignore\nconst babelTraverse = (\n  // @ts-expect-error requireOutside Babel transform\n  requireOutside('@babel/traverse') as typeof import('@babel/traverse')\n).default;\n// prettier-ignore\nconst generate = (\n  // @ts-expect-error requireOutside Babel transform\n  requireOutside('@babel/generator') as typeof import('@babel/generator')\n).default;\n// @ts-expect-error requireOutside Babel transform\nconst {file, templateElement, templateLiteral} = requireOutside(\n  '@babel/types',\n) as typeof import('@babel/types');\n// @ts-expect-error requireOutside Babel transform\nconst {parseSync} = requireOutside(\n  '@babel/core',\n) as typeof import('@babel/core');\n\ntype Prettier = typeof import('prettier');\n\nexport type InlineSnapshot = {\n  snapshot: string;\n  frame: Frame;\n  node?: Expression;\n};\n\nexport function saveInlineSnapshots(\n  snapshots: Array<InlineSnapshot>,\n  rootDir: string,\n  prettierPath: string | null,\n): void {\n  let prettier: Prettier | null = null;\n  if (prettierPath) {\n    try {\n      // @ts-expect-error requireOutside Babel transform\n      prettier = requireOutside(prettierPath) as Prettier;\n    } catch {\n      // Continue even if prettier is not installed.\n    }\n  }\n\n  const snapshotsByFile = groupSnapshotsByFile(snapshots);\n\n  for (const sourceFilePath of Object.keys(snapshotsByFile)) {\n    saveSnapshotsForFile(\n      snapshotsByFile[sourceFilePath],\n      sourceFilePath,\n      rootDir,\n      prettier && semver.gte(prettier.version, '1.5.0') ? prettier : undefined,\n    );\n  }\n}\n\nconst saveSnapshotsForFile = (\n  snapshots: Array<InlineSnapshot>,\n  sourceFilePath: string,\n  rootDir: string,\n  prettier: Prettier | undefined,\n) => {\n  const sourceFile = fs.readFileSync(sourceFilePath, 'utf8');\n\n  // TypeScript projects may not have a babel config; make sure they can be parsed anyway.\n  const presets = [require.resolve('babel-preset-current-node-syntax')];\n  const plugins: Array<PluginItem> = [];\n  if (/\\.tsx?$/.test(sourceFilePath)) {\n    plugins.push([\n      require.resolve('@babel/plugin-syntax-typescript'),\n      {isTSX: sourceFilePath.endsWith('x')},\n      // unique name to make sure Babel does not complain about a possible duplicate plugin.\n      'TypeScript syntax plugin added by Jest snapshot',\n    ]);\n  }\n\n  // Record the matcher names seen during traversal and pass them down one\n  // by one to formatting parser.\n  const snapshotMatcherNames: Array<string> = [];\n\n  let ast: ParseResult | null = null;\n\n  try {\n    ast = parseSync(sourceFile, {\n      filename: sourceFilePath,\n      plugins,\n      presets,\n      root: rootDir,\n    });\n  } catch (error: any) {\n    // attempt to recover from missing jsx plugin\n    if (error.message.includes('@babel/plugin-syntax-jsx')) {\n      try {\n        const jsxSyntaxPlugin: PluginItem = [\n          require.resolve('@babel/plugin-syntax-jsx'),\n          {},\n          // unique name to make sure Babel does not complain about a possible duplicate plugin.\n          'JSX syntax plugin added by Jest snapshot',\n        ];\n        ast = parseSync(sourceFile, {\n          filename: sourceFilePath,\n          plugins: [...plugins, jsxSyntaxPlugin],\n          presets,\n          root: rootDir,\n        });\n      } catch {\n        throw error;\n      }\n    } else {\n      throw error;\n    }\n  }\n\n  if (!ast) {\n    throw new Error(`jest-snapshot: Failed to parse ${sourceFilePath}`);\n  }\n  traverseAst(snapshots, ast, snapshotMatcherNames);\n\n  // substitute in the snapshots in reverse order, so slice calculations aren't thrown off.\n  const sourceFileWithSnapshots = snapshots.reduceRight(\n    (sourceSoFar, nextSnapshot) => {\n      if (\n        !nextSnapshot.node ||\n        typeof nextSnapshot.node.start !== 'number' ||\n        typeof nextSnapshot.node.end !== 'number'\n      ) {\n        throw new Error('Jest: no snapshot insert location found');\n      }\n      return (\n        sourceSoFar.slice(0, nextSnapshot.node.start) +\n        generate(nextSnapshot.node, {retainLines: true}).code.trim() +\n        sourceSoFar.slice(nextSnapshot.node.end)\n      );\n    },\n    sourceFile,\n  );\n\n  const newSourceFile = prettier\n    ? runPrettier(\n        prettier,\n        sourceFilePath,\n        sourceFileWithSnapshots,\n        snapshotMatcherNames,\n      )\n    : sourceFileWithSnapshots;\n\n  if (newSourceFile !== sourceFile) {\n    fs.writeFileSync(sourceFilePath, newSourceFile);\n  }\n};\n\nconst groupSnapshotsBy =\n  (createKey: (inlineSnapshot: InlineSnapshot) => string) =>\n  (snapshots: Array<InlineSnapshot>) =>\n    snapshots.reduce<Record<string, Array<InlineSnapshot>>>(\n      (object, inlineSnapshot) => {\n        const key = createKey(inlineSnapshot);\n        return {...object, [key]: (object[key] || []).concat(inlineSnapshot)};\n      },\n      {},\n    );\n\nconst groupSnapshotsByFrame = groupSnapshotsBy(({frame: {line, column}}) =>\n  typeof line === 'number' && typeof column === 'number'\n    ? `${line}:${column - 1}`\n    : '',\n);\nconst groupSnapshotsByFile = groupSnapshotsBy(({frame: {file}}) => file);\n\nconst indent = (snapshot: string, numIndents: number, indentation: string) => {\n  const lines = snapshot.split('\\n');\n  // Prevent re-indentation of inline snapshots.\n  if (\n    lines.length >= 2 &&\n    lines[1].startsWith(indentation.repeat(numIndents + 1))\n  ) {\n    return snapshot;\n  }\n\n  return lines\n    .map((line, index) => {\n      if (index === 0) {\n        // First line is either a 1-line snapshot or a blank line.\n        return line;\n      } else if (index !== lines.length - 1) {\n        // Do not indent empty lines.\n        if (line === '') {\n          return line;\n        }\n\n        // Not last line, indent one level deeper than expect call.\n        return indentation.repeat(numIndents + 1) + line;\n      } else {\n        // The last line should be placed on the same level as the expect call.\n        return indentation.repeat(numIndents) + line;\n      }\n    })\n    .join('\\n');\n};\n\nconst resolveAst = (fileOrProgram: any): File => {\n  // Flow uses a 'Program' parent node, babel expects a 'File'.\n  let ast = fileOrProgram;\n  if (ast.type !== 'File') {\n    ast = file(ast, ast.comments, ast.tokens);\n    delete ast.program.comments;\n  }\n  return ast;\n};\n\nconst traverseAst = (\n  snapshots: Array<InlineSnapshot>,\n  fileOrProgram: File | Program,\n  snapshotMatcherNames: Array<string>,\n) => {\n  const ast = resolveAst(fileOrProgram);\n  const groupedSnapshots = groupSnapshotsByFrame(snapshots);\n  const remainingSnapshots = new Set(snapshots.map(({snapshot}) => snapshot));\n\n  babelTraverse(ast, {\n    CallExpression({node}) {\n      const {arguments: args, callee} = node;\n      if (\n        callee.type !== 'MemberExpression' ||\n        callee.property.type !== 'Identifier' ||\n        callee.property.loc == null\n      ) {\n        return;\n      }\n      const {line, column} = callee.property.loc.start;\n      const snapshotsForFrame = groupedSnapshots[`${line}:${column}`];\n      if (!snapshotsForFrame) {\n        return;\n      }\n      if (snapshotsForFrame.length > 1) {\n        throw new Error(\n          'Jest: Multiple inline snapshots for the same call are not supported.',\n        );\n      }\n\n      snapshotMatcherNames.push(callee.property.name);\n\n      const snapshotIndex = args.findIndex(\n        ({type}) => type === 'TemplateLiteral',\n      );\n      const values = snapshotsForFrame.map(inlineSnapshot => {\n        inlineSnapshot.node = node;\n        const {snapshot} = inlineSnapshot;\n        remainingSnapshots.delete(snapshot);\n\n        return templateLiteral(\n          [templateElement({raw: escapeBacktickString(snapshot)})],\n          [],\n        );\n      });\n      const replacementNode = values[0];\n\n      if (snapshotIndex > -1) {\n        args[snapshotIndex] = replacementNode;\n      } else {\n        args.push(replacementNode);\n      }\n    },\n  });\n\n  if (remainingSnapshots.size) {\n    throw new Error(\"Jest: Couldn't locate all inline snapshots.\");\n  }\n};\n\nconst runPrettier = (\n  prettier: Prettier,\n  sourceFilePath: string,\n  sourceFileWithSnapshots: string,\n  snapshotMatcherNames: Array<string>,\n) => {\n  // Resolve project configuration.\n  // For older versions of Prettier, do not load configuration.\n  const config = prettier.resolveConfig\n    ? prettier.resolveConfig.sync(sourceFilePath, {editorconfig: true})\n    : null;\n\n  // Prioritize parser found in the project config.\n  // If not found detect the parser for the test file.\n  // For older versions of Prettier, fallback to a simple parser detection.\n  // @ts-expect-error - `inferredParser` is `string`\n  const inferredParser: PrettierParserName | null | undefined =\n    (config && typeof config.parser === 'string' && config.parser) ||\n    (prettier.getFileInfo\n      ? prettier.getFileInfo.sync(sourceFilePath).inferredParser\n      : simpleDetectParser(sourceFilePath));\n\n  if (!inferredParser) {\n    throw new Error(\n      `Could not infer Prettier parser for file ${sourceFilePath}`,\n    );\n  }\n\n  // Snapshots have now been inserted. Run prettier to make sure that the code is\n  // formatted, except snapshot indentation. Snapshots cannot be formatted until\n  // after the initial format because we don't know where the call expression\n  // will be placed (specifically its indentation), so we have to do two\n  // prettier.format calls back-to-back.\n  return prettier.format(\n    prettier.format(sourceFileWithSnapshots, {\n      ...config,\n      filepath: sourceFilePath,\n    }),\n    {\n      ...config,\n      filepath: sourceFilePath,\n      parser: createFormattingParser(snapshotMatcherNames, inferredParser),\n    },\n  );\n};\n\n// This parser formats snapshots to the correct indentation.\nconst createFormattingParser =\n  (\n    snapshotMatcherNames: Array<string>,\n    inferredParser: PrettierParserName,\n  ): PrettierCustomParser =>\n  (text, parsers, options) => {\n    // Workaround for https://github.com/prettier/prettier/issues/3150\n    options.parser = inferredParser;\n\n    const ast = resolveAst(parsers[inferredParser](text, options));\n    babelTraverse(ast, {\n      CallExpression({node: {arguments: args, callee}, parent}) {\n        if (\n          callee.type !== 'MemberExpression' ||\n          callee.property.type !== 'Identifier' ||\n          !snapshotMatcherNames.includes(callee.property.name) ||\n          !callee.loc ||\n          callee.computed\n        ) {\n          return;\n        }\n\n        let snapshotIndex: number | undefined;\n        let snapshot: string | undefined;\n        for (let i = 0; i < args.length; i++) {\n          const node = args[i];\n          if (node.type === 'TemplateLiteral') {\n            snapshotIndex = i;\n            snapshot = node.quasis[0].value.raw;\n          }\n        }\n        if (snapshot === undefined || snapshotIndex === undefined) {\n          return;\n        }\n\n        const startColumn =\n          isAwaitExpression(parent) && parent.loc\n            ? parent.loc.start.column\n            : callee.loc.start.column;\n\n        const useSpaces = !options.useTabs;\n        snapshot = indent(\n          snapshot,\n          Math.ceil(\n            useSpaces\n              ? startColumn / (options.tabWidth ?? 1)\n              : // Each tab is 2 characters.\n                startColumn / 2,\n          ),\n          useSpaces ? ' '.repeat(options.tabWidth ?? 1) : '\\t',\n        );\n\n        const replacementNode = templateLiteral(\n          [\n            templateElement({\n              raw: snapshot,\n            }),\n          ],\n          [],\n        );\n        args[snapshotIndex] = replacementNode;\n      },\n    });\n\n    return ast;\n  };\n\nconst simpleDetectParser = (filePath: string): PrettierParserName => {\n  const extname = path.extname(filePath);\n  if (/\\.tsx?$/.test(extname)) {\n    return 'typescript';\n  }\n  return 'babel';\n};\n","/Users/simen/repos/jest/packages/jest-snapshot/src/SnapshotResolver.ts",["135","136"],[],"/**\n * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport * as path from 'path';\nimport chalk = require('chalk');\nimport {createTranspilingRequire} from '@jest/transform';\nimport type {Config} from '@jest/types';\nimport {interopRequireDefault} from 'jest-util';\n\nexport type SnapshotResolver = {\n  /** Resolves from `testPath` to snapshot path. */\n  resolveSnapshotPath(testPath: string, snapshotExtension?: string): string;\n  /** Resolves from `snapshotPath` to test path. */\n  resolveTestPath(snapshotPath: string, snapshotExtension?: string): string;\n  /** Example test path, used for preflight consistency check of the implementation above. */\n  testPathForConsistencyCheck: string;\n};\n\nexport const EXTENSION = 'snap';\nexport const DOT_EXTENSION = `.${EXTENSION}`;\n\nexport const isSnapshotPath = (path: string): boolean =>\n  path.endsWith(DOT_EXTENSION);\n\nconst cache = new Map<string, SnapshotResolver>();\n\ntype LocalRequire = (module: string) => unknown;\n\nexport const buildSnapshotResolver = async (\n  config: Config.ProjectConfig,\n  localRequire: Promise<LocalRequire> | LocalRequire = createTranspilingRequire(\n    config,\n  ),\n): Promise<SnapshotResolver> => {\n  const key = config.rootDir;\n\n  const resolver =\n    cache.get(key) ??\n    (await createSnapshotResolver(await localRequire, config.snapshotResolver));\n\n  cache.set(key, resolver);\n\n  return resolver;\n};\n\nasync function createSnapshotResolver(\n  localRequire: LocalRequire,\n  snapshotResolverPath?: string | null,\n): Promise<SnapshotResolver> {\n  return typeof snapshotResolverPath === 'string'\n    ? createCustomSnapshotResolver(snapshotResolverPath, localRequire)\n    : createDefaultSnapshotResolver();\n}\n\nfunction createDefaultSnapshotResolver(): SnapshotResolver {\n  return {\n    resolveSnapshotPath: (testPath: string) =>\n      path.join(\n        path.join(path.dirname(testPath), '__snapshots__'),\n        path.basename(testPath) + DOT_EXTENSION,\n      ),\n\n    resolveTestPath: (snapshotPath: string) =>\n      path.resolve(\n        path.dirname(snapshotPath),\n        '..',\n        path.basename(snapshotPath, DOT_EXTENSION),\n      ),\n\n    testPathForConsistencyCheck: path.posix.join(\n      'consistency_check',\n      '__tests__',\n      'example.test.js',\n    ),\n  };\n}\n\nasync function createCustomSnapshotResolver(\n  snapshotResolverPath: string,\n  localRequire: LocalRequire,\n): Promise<SnapshotResolver> {\n  const custom: SnapshotResolver = interopRequireDefault(\n    await localRequire(snapshotResolverPath),\n  ).default;\n\n  const keys: Array<[keyof SnapshotResolver, string]> = [\n    ['resolveSnapshotPath', 'function'],\n    ['resolveTestPath', 'function'],\n    ['testPathForConsistencyCheck', 'string'],\n  ];\n  keys.forEach(([propName, requiredType]) => {\n    if (typeof custom[propName] !== requiredType) {\n      throw new TypeError(mustImplement(propName, requiredType));\n    }\n  });\n\n  const customResolver: SnapshotResolver = {\n    resolveSnapshotPath: (testPath: string) =>\n      custom.resolveSnapshotPath(testPath, DOT_EXTENSION),\n    resolveTestPath: (snapshotPath: string) =>\n      custom.resolveTestPath(snapshotPath, DOT_EXTENSION),\n    testPathForConsistencyCheck: custom.testPathForConsistencyCheck,\n  };\n\n  verifyConsistentTransformations(customResolver);\n\n  return customResolver;\n}\n\nfunction mustImplement(propName: string, requiredType: string) {\n  return `${chalk.bold(\n    `Custom snapshot resolver must implement a \\`${propName}\\` as a ${requiredType}.`,\n  )}\\nDocumentation: https://jestjs.io/docs/configuration#snapshotresolver-string`;\n}\n\nfunction verifyConsistentTransformations(custom: SnapshotResolver) {\n  const resolvedSnapshotPath = custom.resolveSnapshotPath(\n    custom.testPathForConsistencyCheck,\n  );\n  const resolvedTestPath = custom.resolveTestPath(resolvedSnapshotPath);\n  if (resolvedTestPath !== custom.testPathForConsistencyCheck) {\n    throw new Error(\n      chalk.bold(\n        `Custom snapshot resolver functions must transform paths consistently, i.e. expects resolveTestPath(resolveSnapshotPath('${custom.testPathForConsistencyCheck}')) === ${resolvedTestPath}`,\n      ),\n    );\n  }\n}\n","/Users/simen/repos/jest/packages/jest-snapshot/src/State.ts",["137","138","139","140","141","142","143","144","145","146","147"],[],"/**\n * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport * as fs from 'graceful-fs';\nimport type {Config} from '@jest/types';\nimport {getStackTraceLines, getTopFrame} from 'jest-message-util';\nimport {InlineSnapshot, saveInlineSnapshots} from './InlineSnapshots';\nimport type {SnapshotData, SnapshotFormat} from './types';\nimport {\n  addExtraLineBreaks,\n  getSnapshotData,\n  keyToTestName,\n  removeExtraLineBreaks,\n  removeLinesBeforeExternalMatcherTrap,\n  saveSnapshotFile,\n  serialize,\n  testNameToKey,\n} from './utils';\n\nexport type SnapshotStateOptions = {\n  readonly updateSnapshot: Config.SnapshotUpdateState;\n  readonly prettierPath?: string | null;\n  readonly expand?: boolean;\n  readonly snapshotFormat: SnapshotFormat;\n  readonly rootDir: string;\n};\n\nexport type SnapshotMatchOptions = {\n  readonly testName: string;\n  readonly received: unknown;\n  readonly key?: string;\n  readonly inlineSnapshot?: string;\n  readonly isInline: boolean;\n  readonly error?: Error;\n};\n\ntype SnapshotReturnOptions = {\n  readonly actual: string;\n  readonly count: number;\n  readonly expected?: string;\n  readonly key: string;\n  readonly pass: boolean;\n};\n\ntype SaveStatus = {\n  deleted: boolean;\n  saved: boolean;\n};\n\nexport default class SnapshotState {\n  private _counters: Map<string, number>;\n  private _dirty: boolean;\n  // @ts-expect-error - seemingly unused?\n  private _index: number;\n  private readonly _updateSnapshot: Config.SnapshotUpdateState;\n  private _snapshotData: SnapshotData;\n  private readonly _initialData: SnapshotData;\n  private readonly _snapshotPath: string;\n  private _inlineSnapshots: Array<InlineSnapshot>;\n  private readonly _uncheckedKeys: Set<string>;\n  private readonly _prettierPath: string | null;\n  private readonly _rootDir: string;\n\n  readonly snapshotFormat: SnapshotFormat;\n\n  added: number;\n  expand: boolean;\n  matched: number;\n  unmatched: number;\n  updated: number;\n\n  constructor(snapshotPath: string, options: SnapshotStateOptions) {\n    this._snapshotPath = snapshotPath;\n    const {data, dirty} = getSnapshotData(\n      this._snapshotPath,\n      options.updateSnapshot,\n    );\n    this._initialData = data;\n    this._snapshotData = data;\n    this._dirty = dirty;\n    this._prettierPath = options.prettierPath ?? null;\n    this._inlineSnapshots = [];\n    this._uncheckedKeys = new Set(Object.keys(this._snapshotData));\n    this._counters = new Map();\n    this._index = 0;\n    this.expand = options.expand || false;\n    this.added = 0;\n    this.matched = 0;\n    this.unmatched = 0;\n    this._updateSnapshot = options.updateSnapshot;\n    this.updated = 0;\n    this.snapshotFormat = options.snapshotFormat;\n    this._rootDir = options.rootDir;\n  }\n\n  markSnapshotsAsCheckedForTest(testName: string): void {\n    this._uncheckedKeys.forEach(uncheckedKey => {\n      if (keyToTestName(uncheckedKey) === testName) {\n        this._uncheckedKeys.delete(uncheckedKey);\n      }\n    });\n  }\n\n  private _addSnapshot(\n    key: string,\n    receivedSerialized: string,\n    options: {isInline: boolean; error?: Error},\n  ): void {\n    this._dirty = true;\n    if (options.isInline) {\n      const error = options.error || new Error();\n      const lines = getStackTraceLines(\n        removeLinesBeforeExternalMatcherTrap(error.stack || ''),\n      );\n      const frame = getTopFrame(lines);\n      if (!frame) {\n        throw new Error(\n          \"Jest: Couldn't infer stack frame for inline snapshot.\",\n        );\n      }\n      this._inlineSnapshots.push({\n        frame,\n        snapshot: receivedSerialized,\n      });\n    } else {\n      this._snapshotData[key] = receivedSerialized;\n    }\n  }\n\n  clear(): void {\n    this._snapshotData = this._initialData;\n    this._inlineSnapshots = [];\n    this._counters = new Map();\n    this._index = 0;\n    this.added = 0;\n    this.matched = 0;\n    this.unmatched = 0;\n    this.updated = 0;\n  }\n\n  save(): SaveStatus {\n    const hasExternalSnapshots = Object.keys(this._snapshotData).length;\n    const hasInlineSnapshots = this._inlineSnapshots.length;\n    const isEmpty = !hasExternalSnapshots && !hasInlineSnapshots;\n\n    const status: SaveStatus = {\n      deleted: false,\n      saved: false,\n    };\n\n    if ((this._dirty || this._uncheckedKeys.size) && !isEmpty) {\n      if (hasExternalSnapshots) {\n        saveSnapshotFile(this._snapshotData, this._snapshotPath);\n      }\n      if (hasInlineSnapshots) {\n        saveInlineSnapshots(\n          this._inlineSnapshots,\n          this._rootDir,\n          this._prettierPath,\n        );\n      }\n      status.saved = true;\n    } else if (!hasExternalSnapshots && fs.existsSync(this._snapshotPath)) {\n      if (this._updateSnapshot === 'all') {\n        fs.unlinkSync(this._snapshotPath);\n      }\n      status.deleted = true;\n    }\n\n    return status;\n  }\n\n  getUncheckedCount(): number {\n    return this._uncheckedKeys.size || 0;\n  }\n\n  getUncheckedKeys(): Array<string> {\n    return Array.from(this._uncheckedKeys);\n  }\n\n  removeUncheckedKeys(): void {\n    if (this._updateSnapshot === 'all' && this._uncheckedKeys.size) {\n      this._dirty = true;\n      this._uncheckedKeys.forEach(key => delete this._snapshotData[key]);\n      this._uncheckedKeys.clear();\n    }\n  }\n\n  match({\n    testName,\n    received,\n    key,\n    inlineSnapshot,\n    isInline,\n    error,\n  }: SnapshotMatchOptions): SnapshotReturnOptions {\n    this._counters.set(testName, (this._counters.get(testName) || 0) + 1);\n    const count = Number(this._counters.get(testName));\n\n    if (!key) {\n      key = testNameToKey(testName, count);\n    }\n\n    // Do not mark the snapshot as \"checked\" if the snapshot is inline and\n    // there's an external snapshot. This way the external snapshot can be\n    // removed with `--updateSnapshot`.\n    if (!(isInline && this._snapshotData[key] !== undefined)) {\n      this._uncheckedKeys.delete(key);\n    }\n\n    const receivedSerialized = addExtraLineBreaks(\n      serialize(received, undefined, this.snapshotFormat),\n    );\n    const expected = isInline ? inlineSnapshot : this._snapshotData[key];\n    const pass = expected === receivedSerialized;\n    const hasSnapshot = expected !== undefined;\n    const snapshotIsPersisted = isInline || fs.existsSync(this._snapshotPath);\n\n    if (pass && !isInline) {\n      // Executing a snapshot file as JavaScript and writing the strings back\n      // when other snapshots have changed loses the proper escaping for some\n      // characters. Since we check every snapshot in every test, use the newly\n      // generated formatted string.\n      // Note that this is only relevant when a snapshot is added and the dirty\n      // flag is set.\n      this._snapshotData[key] = receivedSerialized;\n    }\n\n    // These are the conditions on when to write snapshots:\n    //  * There's no snapshot file in a non-CI environment.\n    //  * There is a snapshot file and we decided to update the snapshot.\n    //  * There is a snapshot file, but it doesn't have this snaphsot.\n    // These are the conditions on when not to write snapshots:\n    //  * The update flag is set to 'none'.\n    //  * There's no snapshot file or a file without this snapshot on a CI environment.\n    if (\n      (hasSnapshot && this._updateSnapshot === 'all') ||\n      ((!hasSnapshot || !snapshotIsPersisted) &&\n        (this._updateSnapshot === 'new' || this._updateSnapshot === 'all'))\n    ) {\n      if (this._updateSnapshot === 'all') {\n        if (!pass) {\n          if (hasSnapshot) {\n            this.updated++;\n          } else {\n            this.added++;\n          }\n          this._addSnapshot(key, receivedSerialized, {error, isInline});\n        } else {\n          this.matched++;\n        }\n      } else {\n        this._addSnapshot(key, receivedSerialized, {error, isInline});\n        this.added++;\n      }\n\n      return {\n        actual: '',\n        count,\n        expected: '',\n        key,\n        pass: true,\n      };\n    } else {\n      if (!pass) {\n        this.unmatched++;\n        return {\n          actual: removeExtraLineBreaks(receivedSerialized),\n          count,\n          expected:\n            expected !== undefined\n              ? removeExtraLineBreaks(expected)\n              : undefined,\n          key,\n          pass: false,\n        };\n      } else {\n        this.matched++;\n        return {\n          actual: '',\n          count,\n          expected: '',\n          key,\n          pass: true,\n        };\n      }\n    }\n  }\n\n  fail(testName: string, _received: unknown, key?: string): string {\n    this._counters.set(testName, (this._counters.get(testName) || 0) + 1);\n    const count = Number(this._counters.get(testName));\n\n    if (!key) {\n      key = testNameToKey(testName, count);\n    }\n\n    this._uncheckedKeys.delete(key);\n    this.unmatched++;\n    return key;\n  }\n}\n","/Users/simen/repos/jest/packages/jest-snapshot/src/__tests__/InlineSnapshots.test.ts",[],[],"/Users/simen/repos/jest/packages/jest-snapshot/src/__tests__/SnapshotResolver.test.ts",[],[],"/Users/simen/repos/jest/packages/jest-snapshot/src/__tests__/dedentLines.test.ts",[],[],"/Users/simen/repos/jest/packages/jest-snapshot/src/__tests__/matcher.test.ts",[],[],"/Users/simen/repos/jest/packages/jest-snapshot/src/__tests__/mockSerializer.test.ts",[],["148"],"/Users/simen/repos/jest/packages/jest-snapshot/src/__tests__/plugins.test.ts",[],[],"/Users/simen/repos/jest/packages/jest-snapshot/src/__tests__/printSnapshot.test.ts",["149","150","151","152","153","154","155","156","157","158","159","160","161","162","163","164","165","166","167","168","169","170","171","172","173","174"],[],"/**\n * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport ansiRegex = require('ansi-regex');\nimport styles = require('ansi-styles');\nimport chalk = require('chalk');\nimport type {SyncExpectationResult} from 'expect';\nimport format from 'pretty-format';\nimport {\n  Context,\n  toMatchInlineSnapshot,\n  toMatchSnapshot,\n  toThrowErrorMatchingInlineSnapshot,\n  toThrowErrorMatchingSnapshot,\n} from '../';\nimport type SnapshotState from '../State';\nimport {\n  aBackground2,\n  aBackground3,\n  aForeground2,\n  aForeground3,\n  bBackground2,\n  bBackground3,\n  bForeground2,\n  bForeground3,\n} from '../colors';\nimport {\n  getReceivedColorForChalkInstance,\n  getSnapshotColorForChalkInstance,\n  noColor,\n  printPropertiesAndReceived,\n  printSnapshotAndReceived,\n} from '../printSnapshot';\nimport {serialize} from '../utils';\n\nconst aOpenForeground1 = styles.magenta.open;\nconst aOpenBackground1 = styles.bgYellowBright.open;\nconst bOpenForeground1 = styles.cyan.open;\nconst bOpenBackground1 = styles.bgWhiteBright.open;\n\nconst aOpenForeground2 = styles.color.ansi256(aForeground2);\nconst bOpenForeground2 = styles.color.ansi256(bForeground2);\nconst aOpenBackground2 = styles.bgColor.ansi256(aBackground2);\nconst bOpenBackground2 = styles.bgColor.ansi256(bBackground2);\n\nconst aOpenForeground3 = styles.color.ansi16m(\n  aForeground3[0],\n  aForeground3[1],\n  aForeground3[2],\n);\nconst bOpenForeground3 = styles.color.ansi16m(\n  bForeground3[0],\n  bForeground3[1],\n  bForeground3[2],\n);\nconst aOpenBackground3 = styles.bgColor.ansi16m(\n  aBackground3[0],\n  aBackground3[1],\n  aBackground3[2],\n);\nconst bOpenBackground3 = styles.bgColor.ansi16m(\n  bBackground3[0],\n  bBackground3[1],\n  bBackground3[2],\n);\n\nconst convertAnsi = (val: string): string => {\n  // Trailing spaces in common lines have yellow background color.\n  let isYellowBackground = false;\n\n  return val.replace(ansiRegex(), match => {\n    switch (match) {\n      case styles.inverse.open:\n        return '<i>';\n      case styles.inverse.close:\n        return '</i>';\n\n      case styles.bold.open:\n        return '<b>';\n      case styles.dim.open:\n        return '<d>';\n      case styles.bold.close:\n      case styles.dim.close:\n        return '</>';\n\n      case styles.green.open:\n        return '<g>';\n      case aOpenForeground1:\n      case aOpenForeground2:\n      case aOpenForeground3:\n        return '<m>';\n      case styles.red.open:\n        return '<r>';\n      case bOpenForeground1:\n      case bOpenForeground2:\n      case bOpenForeground3:\n        return '<t>'; // teal/cyan/aqua\n      case styles.yellow.open:\n        return '<y>';\n      case styles.cyan.close:\n      case styles.green.close:\n      case styles.magenta.close:\n      case styles.red.close:\n      case styles.yellow.close:\n        return '</>';\n\n      case styles.bgYellow.open:\n        isYellowBackground = true;\n        return '<Y>';\n\n      case aOpenBackground1:\n      case bOpenBackground1:\n      case aOpenBackground2:\n      case bOpenBackground2:\n      case aOpenBackground3:\n      case bOpenBackground3:\n        isYellowBackground = false;\n        return '';\n\n      case styles.bgYellow.close:\n        // The same code closes any background color.\n        return isYellowBackground ? '</Y>' : '';\n\n      default:\n        return match;\n    }\n  });\n};\n\nexpect.addSnapshotSerializer({\n  serialize(val: string): string {\n    return convertAnsi(val);\n  },\n  test(val: unknown): val is string {\n    return typeof val === 'string';\n  },\n});\n\ndescribe('chalk', () => {\n  // Because these tests give code coverage of get functions\n  // and give confidence that the escape sequences are correct,\n  // convertAnsi can return same serialization for any chalk level\n  // so snapshot tests pass in any environment with chalk level >= 1.\n\n  // Simulate comparison lines from printSnapshotAndReceived.\n  const formatLines = (chalkInstance: chalk.Chalk) => {\n    const aColor = getSnapshotColorForChalkInstance(chalkInstance);\n    const bColor = getReceivedColorForChalkInstance(chalkInstance);\n    const cColor = chalkInstance.dim;\n    const changeLineTrailingSpaceColor = noColor;\n    const commonLineTrailingSpaceColor = chalkInstance.bgYellow;\n\n    return [\n      aColor(`- delete 1${changeLineTrailingSpaceColor(' ')}`),\n      cColor(`  common 2${commonLineTrailingSpaceColor('  ')}`),\n      bColor('+ insert 0'),\n    ].join('\\n');\n  };\n\n  const expected0 = '- delete 1 \\n  common 2  \\n+ insert 0';\n  const expected1 =\n    '<m>- delete 1 </>\\n<d>  common 2<Y>  </Y></>\\n<t>+ insert 0</>';\n\n  test('level 0', () => {\n    const chalkInstance = new chalk.Instance({level: 0});\n    const formatted = formatLines(chalkInstance);\n    const converted = convertAnsi(formatted);\n\n    expect(converted).toBe(expected0);\n    expect(formatted).toBe(expected0);\n  });\n\n  test('level 1', () => {\n    const chalkInstance = new chalk.Instance({level: 1});\n    const formatted = formatLines(chalkInstance);\n    const converted = convertAnsi(formatted);\n\n    expect(converted).toBe(expected1);\n    expect(formatted).toMatch(`${aOpenForeground1 + aOpenBackground1}-`);\n    expect(formatted).toMatch(`${bOpenForeground1 + bOpenBackground1}+`);\n    expect(formatted).not.toMatch(chalkInstance.bgYellow(' ')); // noColor\n    expect(formatted).toMatch(chalkInstance.bgYellow('  '));\n  });\n\n  test('level 2', () => {\n    const chalkInstance = new chalk.Instance({level: 2});\n    const formatted = formatLines(chalkInstance);\n    const converted = convertAnsi(formatted);\n\n    expect(converted).toBe(expected1);\n    expect(formatted).toMatch(`${aOpenForeground2 + aOpenBackground2}-`);\n    expect(formatted).toMatch(`${bOpenForeground2 + bOpenBackground2}+`);\n    expect(formatted).not.toMatch(chalkInstance.bgYellow(' ')); // noColor\n    expect(formatted).toMatch(chalkInstance.bgYellow('  '));\n  });\n\n  test('level 3', () => {\n    const chalkInstance = new chalk.Instance({level: 3});\n    const formatted = formatLines(chalkInstance);\n    const converted = convertAnsi(formatted);\n\n    expect(converted).toBe(expected1);\n    expect(formatted).toMatch(`${aOpenForeground3 + aOpenBackground3}-`);\n    expect(formatted).toMatch(`${bOpenForeground3 + bOpenBackground3}+`);\n    expect(formatted).not.toMatch(chalkInstance.bgYellow(' ')); // noColor\n    expect(formatted).toMatch(chalkInstance.bgYellow('  '));\n  });\n});\n\ndescribe('matcher error', () => {\n  describe('toMatchInlineSnapshot', () => {\n    const received = {\n      id: 'abcdef',\n      text: 'Throw matcher error',\n      type: 'ADD_ITEM',\n    };\n\n    test('Expected properties must be an object (non-null) without snapshot', () => {\n      const context = {\n        isNot: false,\n        promise: '',\n      } as Context;\n      const properties = false;\n\n      expect(() => {\n        // @ts-expect-error: Testing runtime error\n        toMatchInlineSnapshot.call(context, received, properties);\n      }).toThrowErrorMatchingSnapshot();\n    });\n\n    test('Expected properties must be an object (null) with snapshot', () => {\n      const context = {\n        isNot: false,\n        promise: '',\n      } as Context;\n      const properties = null;\n      const snapshot = '';\n\n      expect(() => {\n        // @ts-expect-error: Testing runtime error\n        toMatchInlineSnapshot.call(context, received, properties, snapshot);\n      }).toThrowErrorMatchingSnapshot();\n    });\n\n    test('Expected properties must be an object (array) with snapshot', () => {\n      const context = {\n        isNot: false,\n        promise: '',\n      } as Context;\n      const properties: Array<unknown> = [];\n      const snapshot = '';\n\n      expect(() => {\n        toMatchInlineSnapshot.call(context, received, properties, snapshot);\n      }).toThrowErrorMatchingSnapshot();\n    });\n\n    test('Inline snapshot must be a string', () => {\n      const context = {\n        isNot: false,\n        promise: 'resolves',\n      } as Context;\n      const properties = {};\n      const snapshot = Symbol('is not a string');\n\n      expect(() => {\n        // @ts-expect-error: Testing runtime error\n        toMatchInlineSnapshot.call(context, received, properties, snapshot);\n      }).toThrowErrorMatchingSnapshot();\n    });\n\n    test('Snapshot matchers cannot be used with not', () => {\n      const context = {\n        isNot: true,\n        promise: '',\n      } as Context;\n      const received = -13;\n      const snapshot = '13';\n\n      expect(() => {\n        toMatchInlineSnapshot.call(context, received, snapshot);\n      }).toThrowErrorMatchingSnapshot();\n    });\n  });\n\n  describe('toMatchSnapshot', () => {\n    const received = {\n      id: 'abcdef',\n      text: 'Throw matcher error',\n      type: 'ADD_ITEM',\n    };\n\n    test('Expected properties must be an object (non-null)', () => {\n      const context = {\n        isNot: false,\n        promise: '',\n      } as Context;\n      const properties = () => {};\n\n      expect(() => {\n        toMatchSnapshot.call(context, received, properties);\n      }).toThrowErrorMatchingSnapshot();\n    });\n\n    test('Expected properties must be an object (null) with hint', () => {\n      const context = {\n        isNot: false,\n        promise: '',\n      } as Context;\n      const properties = null;\n      const hint = 'reminder';\n\n      expect(() => {\n        // @ts-expect-error: Testing runtime error\n        toMatchSnapshot.call(context, received, properties, hint);\n      }).toThrowErrorMatchingSnapshot();\n    });\n\n    test('Expected properties must be an object (null) without hint', () => {\n      const context = {\n        isNot: false,\n        promise: '',\n      } as Context;\n      const properties = null;\n\n      expect(() => {\n        // @ts-expect-error: Testing runtime error\n        toMatchSnapshot.call(context, received, properties);\n      }).toThrowErrorMatchingSnapshot();\n    });\n\n    test('Expected properties must be an object (array)', () => {\n      const context = {\n        isNot: false,\n        promise: '',\n      } as Context;\n      const properties: Array<unknown> = [];\n\n      expect(() => {\n        toMatchSnapshot.call(context, received, properties);\n      }).toThrowErrorMatchingSnapshot();\n    });\n\n    describe('received value must be an object', () => {\n      const context = {\n        currentTestName: '',\n        isNot: false,\n        promise: '',\n        snapshotState: {},\n      } as Context;\n      const properties = {};\n\n      test('(non-null)', () => {\n        expect(() => {\n          toMatchSnapshot.call(context, 'string', properties);\n        }).toThrowErrorMatchingSnapshot();\n      });\n\n      test('(null)', () => {\n        expect(() => {\n          toMatchSnapshot.call(context, null, properties);\n        }).toThrowErrorMatchingSnapshot();\n      });\n    });\n\n    // Future test: Snapshot hint must be a string\n\n    test('Snapshot state must be initialized', () => {\n      const context = {\n        isNot: false,\n        promise: 'resolves',\n      } as Context;\n      const hint = 'initialize me';\n\n      expect(() => {\n        toMatchSnapshot.call(context, received, hint);\n      }).toThrowErrorMatchingSnapshot();\n    });\n  });\n\n  describe('toThrowErrorMatchingInlineSnapshot', () => {\n    test('Inline snapshot must be a string', () => {\n      const context = {\n        isNot: false,\n        promise: '',\n      } as Context;\n      const received = () => {\n        throw new Error('Not found');\n      };\n      const snapshot = 404;\n      const fromPromise = false;\n\n      expect(() => {\n        toThrowErrorMatchingInlineSnapshot.call(\n          context,\n          received,\n          // @ts-expect-error: Testing runtime error\n          snapshot,\n          fromPromise,\n        );\n      }).toThrowErrorMatchingSnapshot();\n    });\n\n    test('Snapshot state must be initialized', () => {\n      const context = {\n        isNot: false,\n        promise: 'rejects',\n      } as Context;\n      const received = new Error('404');\n      const snapshot = '\"Not found\"';\n      const fromPromise = true;\n\n      expect(() => {\n        toThrowErrorMatchingInlineSnapshot.call(\n          context,\n          received,\n          snapshot,\n          fromPromise,\n        );\n      }).toThrowErrorMatchingSnapshot();\n    });\n  });\n\n  describe('toThrowErrorMatchingSnapshot', () => {\n    test('Received value must be a function', () => {\n      const context = {\n        isNot: false,\n        promise: '',\n      } as Context;\n      const received = 13;\n      const fromPromise = false;\n\n      expect(() => {\n        toThrowErrorMatchingSnapshot.call(\n          context,\n          received,\n          undefined,\n          fromPromise,\n        );\n      }).toThrowErrorMatchingSnapshot();\n    });\n\n    test('Snapshot matchers cannot be used with not', () => {\n      const context = {\n        isNot: true,\n        promise: '',\n      } as Context;\n      const received = new Error('received');\n      const hint = 'reminder';\n      const fromPromise = true;\n\n      expect(() => {\n        toThrowErrorMatchingSnapshot.call(context, received, hint, fromPromise);\n      }).toThrowErrorMatchingSnapshot();\n    });\n\n    // Future test: Snapshot hint must be a string\n  });\n});\n\ndescribe('other error', () => {\n  describe('toThrowErrorMatchingSnapshot', () => {\n    test('Received function did not throw', () => {\n      const context = {\n        isNot: false,\n        promise: '',\n      } as Context;\n      const received = () => {};\n      const fromPromise = false;\n\n      expect(() => {\n        toThrowErrorMatchingSnapshot.call(\n          context,\n          received,\n          undefined,\n          fromPromise,\n        );\n      }).toThrowErrorMatchingSnapshot();\n    });\n  });\n});\n\ndescribe('pass false', () => {\n  describe('toMatchInlineSnapshot', () => {\n    describe('with properties', () => {\n      const id = 'abcdef';\n      const properties = {id};\n      const type = 'ADD_ITEM';\n\n      describe('equals false', () => {\n        const context = {\n          currentTestName: 'with properties',\n          equals: () => false,\n          isNot: false,\n          promise: '',\n          snapshotState: {\n            fail: (fullTestName: string) => `${fullTestName} 1`,\n          },\n          utils: {\n            iterableEquality: () => {},\n            subsetEquality: () => {},\n          },\n        } as unknown as Context;\n        const received = {\n          id: 'abcdefg',\n          text: 'Increase code coverage',\n          type,\n        };\n\n        test('with snapshot', () => {\n          const snapshot = '';\n          const {message, pass} = toMatchInlineSnapshot.call(\n            context,\n            received,\n            properties,\n            snapshot,\n          ) as SyncExpectationResult;\n          expect(pass).toBe(false);\n          expect(message()).toMatchSnapshot();\n        });\n\n        test('without snapshot', () => {\n          const {message, pass} = toMatchInlineSnapshot.call(\n            context,\n            received,\n            properties,\n          ) as SyncExpectationResult;\n          expect(pass).toBe(false);\n          expect(message()).toMatchSnapshot();\n        });\n      });\n\n      test('equals true', () => {\n        const context = {\n          currentTestName: 'with properties',\n          equals: () => true,\n          isNot: false,\n          promise: '',\n          snapshotState: {\n            expand: false,\n            match({inlineSnapshot, received}) {\n              return {\n                actual: format(received),\n                count: 1,\n                expected: inlineSnapshot,\n                pass: false,\n              };\n            },\n          } as SnapshotState,\n          utils: {\n            iterableEquality: () => {},\n            subsetEquality: () => {},\n          },\n        } as unknown as Context;\n        const received = {\n          id,\n          text: 'received',\n          type,\n        };\n        const snapshot = format({\n          id,\n          text: 'inline snapshot',\n          type,\n        });\n\n        const {message, pass} = toMatchInlineSnapshot.call(\n          context,\n          received,\n          properties,\n          snapshot,\n        ) as SyncExpectationResult;\n        expect(pass).toBe(false);\n        expect(message()).toMatchSnapshot();\n      });\n    });\n  });\n\n  describe('toMatchSnapshot', () => {\n    test('New snapshot was not written (multi line)', () => {\n      const context = {\n        currentTestName: 'New snapshot was not written',\n        isNot: false,\n        promise: '',\n        snapshotState: {\n          match({received}) {\n            return {\n              actual: format(received),\n              count: 1,\n              expected: undefined,\n              pass: false,\n            };\n          },\n        },\n      } as Context;\n      const received = 'To write or not to write,\\nthat is the question.';\n      const hint = '(CI)';\n\n      const {message, pass} = toMatchSnapshot.call(\n        context,\n        received,\n        hint,\n      ) as SyncExpectationResult;\n      expect(pass).toBe(false);\n      expect(message()).toMatchSnapshot();\n    });\n\n    test('New snapshot was not written (single line)', () => {\n      const context = {\n        currentTestName: 'New snapshot was not written',\n        isNot: false,\n        promise: '',\n        snapshotState: {\n          match({received}) {\n            return {\n              actual: format(received),\n              count: 2,\n              expected: undefined,\n              pass: false,\n            };\n          },\n        },\n      } as Context;\n      const received = 'Write me if you can!';\n      const hint = '(CI)';\n\n      const {message, pass} = toMatchSnapshot.call(\n        context,\n        received,\n        hint,\n      ) as SyncExpectationResult;\n      expect(pass).toBe(false);\n      expect(message()).toMatchSnapshot();\n    });\n\n    describe('with properties', () => {\n      const id = 'abcdef';\n      const properties = {id};\n      const type = 'ADD_ITEM';\n\n      describe('equals false', () => {\n        const context = {\n          currentTestName: 'with properties',\n          equals: () => false,\n          isNot: false,\n          promise: '',\n          snapshotState: {\n            fail: (fullTestName: string) => `${fullTestName} 1`,\n          },\n          utils: {\n            iterableEquality: () => {},\n            subsetEquality: () => {},\n          },\n        } as unknown as Context;\n\n        test('isLineDiffable false', () => {\n          const {message, pass} = toMatchSnapshot.call(\n            context,\n            new RangeError('Invalid array length'),\n            {name: 'Error'},\n          ) as SyncExpectationResult;\n          expect(pass).toBe(false);\n          expect(message()).toMatchSnapshot();\n        });\n\n        test('isLineDiffable true', () => {\n          const received = {\n            id: 'abcdefg',\n            text: 'Increase code coverage',\n            type,\n          };\n\n          const {message, pass} = toMatchSnapshot.call(\n            context,\n            received,\n            properties,\n          ) as SyncExpectationResult;\n          expect(pass).toBe(false);\n          expect(message()).toMatchSnapshot();\n        });\n      });\n\n      test('equals true', () => {\n        const context = {\n          currentTestName: 'with properties',\n          equals: () => true,\n          isNot: false,\n          promise: '',\n          snapshotState: {\n            expand: false,\n            match({received}) {\n              return {\n                actual: format(received),\n                count: 1,\n                expected: format({\n                  id,\n                  text: 'snapshot',\n                  type,\n                }),\n                pass: false,\n              };\n            },\n          } as SnapshotState,\n          utils: {\n            iterableEquality: () => {},\n            subsetEquality: () => {},\n          },\n        } as unknown as Context;\n        const received = {\n          id,\n          text: 'received',\n          type,\n        };\n        const hint = 'change text value';\n\n        const {message, pass} = toMatchSnapshot.call(\n          context,\n          received,\n          properties,\n          hint,\n        ) as SyncExpectationResult;\n        expect(pass).toBe(false);\n        expect(message()).toMatchSnapshot();\n      });\n    });\n  });\n\n  describe('toThrowErrorMatchingInlineSnapshot', () => {\n    test('with snapshot', () => {\n      const context = {\n        currentTestName: 'with snapshot',\n        isNot: false,\n        promise: '',\n        snapshotState: {\n          expand: false,\n          match({inlineSnapshot, received}) {\n            return {\n              actual: format(received),\n              count: 1,\n              expected: inlineSnapshot,\n              pass: false,\n            };\n          },\n        },\n      } as Context;\n      const received = new Error('received');\n      const snapshot = '\"inline snapshot\"';\n      const fromPromise = true;\n\n      const {message, pass} = toThrowErrorMatchingInlineSnapshot.call(\n        context,\n        received,\n        snapshot,\n        fromPromise,\n      ) as SyncExpectationResult;\n      expect(pass).toBe(false);\n      expect(message()).toMatchSnapshot();\n    });\n  });\n});\n\ndescribe('pass true', () => {\n  describe('toMatchSnapshot', () => {\n    test('without properties', () => {\n      const context = {\n        isNot: false,\n        promise: '',\n        snapshotState: {\n          match() {\n            return {\n              expected: '',\n              pass: true,\n            };\n          },\n        },\n      } as unknown as Context;\n      const received = 7;\n\n      const {pass} = toMatchSnapshot.call(\n        context,\n        received,\n      ) as SyncExpectationResult;\n      expect(pass).toBe(true);\n    });\n  });\n});\n\ndescribe('printPropertiesAndReceived', () => {\n  test('omit missing properties', () => {\n    const received = {\n      b: {},\n      branchMap: {},\n      f: {},\n      fnMap: {},\n      // hash is missing\n      path: '…',\n      s: {},\n      statementMap: {},\n    };\n    const properties = {\n      hash: expect.any(String),\n      path: expect.any(String),\n    };\n\n    expect(\n      printPropertiesAndReceived(properties, received, false),\n    ).toMatchSnapshot();\n  });\n});\n\ndescribe('printSnapshotAndReceived', () => {\n  // Simulate default serialization.\n  const testWithStringify = (\n    expected: unknown,\n    received: unknown,\n    expand: boolean,\n  ): string =>\n    printSnapshotAndReceived(\n      serialize(expected),\n      serialize(received),\n      received,\n      expand,\n    );\n\n  // Simulate custom raw string serialization.\n  const testWithoutStringify = (\n    expected: string,\n    received: string,\n    expand: boolean,\n  ): string => printSnapshotAndReceived(expected, received, received, expand);\n\n  describe('backtick', () => {\n    test('single line expected and received', () => {\n      const expected = 'var foo = `backtick`;';\n      const received = 'var foo = tag`backtick`;';\n\n      expect(testWithStringify(expected, received, false)).toMatchSnapshot();\n    });\n  });\n\n  describe('empty string', () => {\n    test('expected and received single line', () => {\n      const expected = '';\n      const received = 'single line string';\n\n      expect(testWithStringify(expected, received, false)).toMatchSnapshot();\n    });\n\n    test('received and expected multi line', () => {\n      const expected = 'multi\\nline\\nstring';\n      const received = '';\n\n      expect(testWithStringify(expected, received, false)).toMatchSnapshot();\n    });\n  });\n\n  describe('escape', () => {\n    test('double quote marks in string', () => {\n      const expected = 'What does \"oobleck\" mean?';\n      const received = 'What does \"ewbleck\" mean?';\n\n      expect(testWithStringify(expected, received, false)).toMatchSnapshot();\n    });\n\n    test('backslash in multi line string', () => {\n      const expected = 'Forward / slash and back \\\\ slash';\n      const received = 'Forward / slash\\nBack \\\\ slash';\n\n      expect(testWithStringify(expected, received, false)).toMatchSnapshot();\n    });\n\n    test('backslash in single line string', () => {\n      const expected = 'forward / slash and back \\\\ slash';\n      const received = 'Forward / slash and back \\\\ slash';\n\n      expect(testWithStringify(expected, received, false)).toMatchSnapshot();\n    });\n\n    test('regexp', () => {\n      const expected = /\\\\(\")/g;\n      const received = /\\\\(\")/;\n\n      expect(testWithStringify(expected, received, false)).toMatchSnapshot();\n    });\n  });\n\n  describe('expand', () => {\n    // prettier/pull/5272\n    const expected = [\n      'type TypeName<T> =',\n      'T extends string ? \"string\" :',\n      'T extends number ? \"number\" :',\n      'T extends boolean ? \"boolean\" :',\n      'T extends undefined ? \"undefined\" :',\n      'T extends Function ? \"function\" :',\n      '\"object\";',\n      '~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~',\n      'type TypeName<T> = T extends string',\n      '? \"string\"',\n      ': T extends number',\n      '? \"number\"',\n      ': T extends boolean',\n      '? \"boolean\"',\n      ': T extends undefined',\n      '? \"undefined\"',\n      ': T extends Function ? \"function\" : \"object\";',\n      '',\n    ].join('\\n');\n    const received = [\n      'type TypeName<T> =',\n      'T extends string ? \"string\" :',\n      'T extends number ? \"number\" :',\n      'T extends boolean ? \"boolean\" :',\n      'T extends undefined ? \"undefined\" :',\n      'T extends Function ? \"function\" :',\n      '\"object\";',\n      '~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~',\n      'type TypeName<T> = T extends string',\n      '? \"string\"',\n      ': T extends number',\n      '? \"number\"',\n      ': T extends boolean',\n      '? \"boolean\"',\n      ': T extends undefined',\n      '? \"undefined\"',\n      ': T extends Function',\n      '? \"function\"',\n      ': \"object\";',\n      '',\n    ].join('\\n');\n\n    test('false', () => {\n      expect(testWithStringify(expected, received, false)).toMatchSnapshot();\n    });\n\n    test('true', () => {\n      expect(testWithStringify(expected, received, true)).toMatchSnapshot();\n    });\n  });\n\n  test('fallback to line diff', () => {\n    const expected = [\n      '[...a, ...b,];',\n      '[...a, ...b];',\n      '~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~',\n      '[...a, ...b];',\n      '[...a, ...b];',\n      '',\n    ].join('\\n');\n    const received = [\n      '====================================options=====================================',\n      'parsers: [\"flow\", \"typescript\"]',\n      'printWidth: 80',\n      '                                                                                | printWidth',\n      '=====================================input======================================',\n      '[...a, ...b,];',\n      '[...a, ...b];',\n      '',\n      '=====================================output=====================================',\n      '[...a, ...b];',\n      '[...a, ...b];',\n      '',\n      '================================================================================',\n    ].join('\\n');\n\n    expect(testWithStringify(expected, received, false)).toMatchSnapshot();\n  });\n\n  describe('has no common after clean up chaff', () => {\n    test('array', () => {\n      const expected = ['delete', 'two'];\n      const received = ['insert', '2'];\n\n      expect(testWithStringify(expected, received, false)).toMatchSnapshot();\n    });\n\n    test('string single line', () => {\n      const expected = 'delete';\n      const received = 'insert';\n\n      expect(testWithStringify(expected, received, false)).toMatchSnapshot();\n    });\n  });\n\n  describe('MAX_DIFF_STRING_LENGTH', () => {\n    describe('unquoted', () => {\n      // Do not call diffStringsUnified if either string is longer than max.\n      const lessChange = chalk.inverse('single ');\n      const less = 'single line';\n      const more = `multi line${'\\n123456789'.repeat(2000)}`; // 10 + 20K chars\n\n      test('both are less', () => {\n        const less2 = 'multi\\nline';\n        const difference = printSnapshotAndReceived(less2, less, less, true);\n\n        expect(difference).toMatch('- multi');\n        expect(difference).toMatch('- line');\n        expect(difference).toMatch(lessChange);\n        expect(difference).not.toMatch('+ single line');\n      });\n\n      test('expected is more', () => {\n        const difference = printSnapshotAndReceived(more, less, less, true);\n\n        expect(difference).toMatch('- multi line');\n        expect(difference).toMatch('+ single line');\n        expect(difference).not.toMatch(lessChange);\n      });\n\n      test('received is more', () => {\n        const difference = printSnapshotAndReceived(less, more, more, true);\n\n        expect(difference).toMatch('- single line');\n        expect(difference).toMatch('+ multi line');\n        expect(difference).not.toMatch(lessChange);\n      });\n    });\n\n    describe('quoted', () => {\n      // Do not call diffStringsRaw if either string is longer than max.\n      const lessChange = chalk.inverse('no');\n      const less = 'no numbers';\n      const more = `many numbers${' 123456789'.repeat(2000)}`; // 12 + 20K chars\n      const lessQuoted = `\"${less}\"`;\n      const moreQuoted = `\"${more}\"`;\n\n      test('both are less', () => {\n        const lessQuoted2 = '\"0 numbers\"';\n        const stringified = printSnapshotAndReceived(\n          lessQuoted2,\n          lessQuoted,\n          less,\n          true,\n        );\n\n        expect(stringified).toMatch('Received:');\n        expect(stringified).toMatch(lessChange);\n        expect(stringified).not.toMatch('+ Received');\n      });\n\n      test('expected is more', () => {\n        const stringified = printSnapshotAndReceived(\n          moreQuoted,\n          lessQuoted,\n          less,\n          true,\n        );\n\n        expect(stringified).toMatch('Received:');\n        expect(stringified).toMatch(less);\n        expect(stringified).not.toMatch('+ Received');\n        expect(stringified).not.toMatch(lessChange);\n      });\n\n      test('received is more', () => {\n        const stringified = printSnapshotAndReceived(\n          lessQuoted,\n          moreQuoted,\n          more,\n          true,\n        );\n\n        expect(stringified).toMatch('Snapshot:');\n        expect(stringified).toMatch(less);\n        expect(stringified).not.toMatch('- Snapshot');\n        expect(stringified).not.toMatch(lessChange);\n      });\n    });\n  });\n\n  describe('isLineDiffable', () => {\n    describe('false', () => {\n      test('asymmetric matcher', () => {\n        const expected = null;\n        const received = {asymmetricMatch: () => {}};\n\n        expect(testWithStringify(expected, received, false)).toMatchSnapshot();\n      });\n\n      test('boolean', () => {\n        const expected = true;\n        const received = false;\n\n        expect(testWithStringify(expected, received, false)).toMatchSnapshot();\n      });\n\n      test('date', () => {\n        const expected = new Date('2019-09-19');\n        const received = new Date('2019-09-20');\n\n        expect(testWithStringify(expected, received, false)).toMatchSnapshot();\n      });\n\n      test('error', () => {\n        const expected = new Error(\n          'Cannot spread fragment \"NameAndAppearances\" within itself.',\n        );\n        const received = new Error(\n          'Cannot spread fragment \"NameAndAppearancesAndFriends\" within itself.',\n        );\n\n        expect(testWithStringify(expected, received, false)).toMatchSnapshot();\n      });\n\n      test('function', () => {\n        const expected = undefined;\n        const received = () => {};\n\n        expect(testWithStringify(expected, received, false)).toMatchSnapshot();\n      });\n\n      test('number', () => {\n        const expected = -0;\n        const received = NaN;\n\n        expect(testWithStringify(expected, received, false)).toMatchSnapshot();\n      });\n    });\n\n    describe('true', () => {\n      test('array', () => {\n        const expected0 = {\n          code: 4011,\n          weight: 2.13,\n        };\n        const expected1 = {\n          code: 4019,\n          count: 4,\n        };\n\n        const expected = [expected0, expected1];\n        const received = [\n          {_id: 'b14680dec683e744ada1f2fe08614086', ...expected0},\n          {_id: '7fc63ff01769c4fa7d9279e97e307829', ...expected1},\n        ];\n\n        expect(testWithStringify(expected, received, false)).toMatchSnapshot();\n      });\n\n      test('object', () => {\n        const type = 'img';\n        const expected = {\n          props: {\n            className: 'logo',\n            src: '/img/jest.png',\n          },\n          type,\n        };\n        const received = {\n          props: {\n            alt: 'Jest logo',\n            class: 'logo',\n            src: '/img/jest.svg',\n          },\n          type,\n        };\n\n        expect(testWithStringify(expected, received, false)).toMatchSnapshot();\n      });\n\n      test('single line expected and received', () => {\n        const expected: Array<unknown> = [];\n        const received = {};\n\n        expect(testWithStringify(expected, received, false)).toMatchSnapshot();\n      });\n\n      test('single line expected and multi line received', () => {\n        const expected: Array<unknown> = [];\n        const received = [0];\n\n        expect(testWithStringify(expected, received, false)).toMatchSnapshot();\n      });\n    });\n  });\n\n  test('multi line small change in one line and other is unchanged', () => {\n    const expected =\n      \"There is no route defined for key 'Settings'.\\nMust be one of: 'Home'\";\n    const received =\n      \"There is no route defined for key Settings.\\nMust be one of: 'Home'\";\n\n    expect(testWithStringify(expected, received, false)).toMatchSnapshot();\n  });\n\n  test('multi line small changes', () => {\n    const expected = [\n      '    69 | ',\n      \"    70 | test('assert.doesNotThrow', () => {\",\n      '  > 71 |   assert.doesNotThrow(() => {',\n      '       |          ^',\n      \"    72 |     throw Error('err!');\",\n      '    73 |   });',\n      '    74 | });',\n      '    at Object.doesNotThrow (__tests__/assertionError.test.js:71:10)',\n    ].join('\\n');\n    const received = [\n      '    68 | ',\n      \"    69 | test('assert.doesNotThrow', () => {\",\n      '  > 70 |   assert.doesNotThrow(() => {',\n      '       |          ^',\n      \"    71 |     throw Error('err!');\",\n      '    72 |   });',\n      '    73 | });',\n      '    at Object.doesNotThrow (__tests__/assertionError.test.js:70:10)',\n    ].join('\\n');\n\n    expect(testWithStringify(expected, received, false)).toMatchSnapshot();\n  });\n\n  test('single line large changes', () => {\n    const expected = 'Array length must be a finite positive integer';\n    const received = 'Invalid array length';\n\n    expect(testWithStringify(expected, received, false)).toMatchSnapshot();\n  });\n\n  describe('ignore indentation', () => {\n    const $$typeof = Symbol.for('react.test.json');\n\n    test('markup delete', () => {\n      const received = {\n        $$typeof,\n        children: [\n          {\n            $$typeof,\n            children: ['Ignore indentation for most serialized objects'],\n            type: 'h3',\n          },\n          {\n            $$typeof,\n            children: [\n              'Call ',\n              {\n                $$typeof,\n                children: ['diffLinesUnified2'],\n                type: 'code',\n              },\n              ' to compare without indentation',\n            ],\n            type: 'p',\n          },\n        ],\n        type: 'div',\n      };\n      const expected = {\n        $$typeof,\n        children: [received],\n        type: 'div',\n      };\n\n      expect(testWithStringify(expected, received, false)).toMatchSnapshot();\n    });\n\n    test('markup fall back', () => {\n      // Because text has more than one adjacent line.\n      const text = [\n        'for (key in foo) {',\n        '  if (Object.prototype.hasOwnProperty.call(foo, key)) {',\n        '    doSomething(key);',\n        '  }',\n        '}',\n      ].join('\\n');\n\n      const expected = {\n        $$typeof,\n        children: [text],\n        props: {\n          className: 'language-js',\n        },\n        type: 'pre',\n      };\n      const received = {\n        $$typeof,\n        children: [expected],\n        type: 'div',\n      };\n\n      expect(testWithStringify(expected, received, false)).toMatchSnapshot();\n    });\n\n    test('markup insert', () => {\n      const text = 'when';\n      const expected = {\n        $$typeof,\n        children: [text],\n        type: 'th',\n      };\n      const received = {\n        $$typeof,\n        children: [\n          {\n            $$typeof,\n            children: [text],\n            type: 'span',\n          },\n          {\n            $$typeof,\n            children: ['↓'],\n            props: {\n              title: 'ascending from older to newer',\n            },\n            type: 'abbr',\n          },\n        ],\n        type: 'th',\n      };\n\n      expect(testWithStringify(expected, received, false)).toMatchSnapshot();\n    });\n\n    describe('object', () => {\n      const text = 'Ignore indentation in snapshot';\n      const time = '2019-11-11';\n      const type = 'CREATE_ITEM';\n      const less = {\n        text,\n        time,\n        type,\n      };\n      const more = {\n        payload: {\n          text,\n          time,\n        },\n        type,\n      };\n\n      test('delete', () => {\n        expect(testWithStringify(more, less, false)).toMatchSnapshot();\n      });\n\n      test('insert', () => {\n        expect(testWithStringify(less, more, false)).toMatchSnapshot();\n      });\n    });\n  });\n\n  describe('without serialize', () => {\n    test('backtick single line expected and received', () => {\n      const expected = 'var foo = `backtick`;';\n      const received = 'var foo = `back${x}tick`;';\n\n      expect(testWithoutStringify(expected, received, false)).toMatchSnapshot();\n    });\n\n    test('backtick single line expected and multi line received', () => {\n      const expected = 'var foo = `backtick`;';\n      const received = 'var foo = `back\\ntick`;';\n\n      expect(testWithoutStringify(expected, received, false)).toMatchSnapshot();\n    });\n\n    test('has no common after clean up chaff multi line', () => {\n      const expected = 'delete\\ntwo';\n      const received = 'insert\\n2';\n\n      expect(testWithoutStringify(expected, received, false)).toMatchSnapshot();\n    });\n\n    test('has no common after clean up chaff single line', () => {\n      const expected = 'delete';\n      const received = 'insert';\n\n      expect(testWithoutStringify(expected, received, false)).toMatchSnapshot();\n    });\n\n    test('prettier/pull/5590', () => {\n      const expected = [\n        '====================================options=====================================',\n        'parsers: [\"html\"]',\n        'printWidth: 80',\n        '                                                                                | printWidth',\n        '=====================================input======================================',\n        '<img src=\"test.png\" alt=\\'John \"ShotGun\" Nelson\\'>',\n        '',\n        '=====================================output=====================================',\n        '<img src=\"test.png\" alt=\"John &quot;ShotGun&quot; Nelson\" />',\n        '',\n        '================================================================================',\n      ].join('\\n');\n      const received = [\n        '====================================options=====================================',\n        'parsers: [\"html\"]',\n        'printWidth: 80',\n        '                                                                                | printWidth',\n        '=====================================input======================================',\n        '<img src=\"test.png\" alt=\\'John \"ShotGun\" Nelson\\'>',\n        '',\n        '=====================================output=====================================',\n        '<img src=\"test.png\" alt=\\'John \"ShotGun\" Nelson\\' />',\n        '',\n        '================================================================================',\n      ].join('\\n');\n\n      expect(testWithoutStringify(expected, received, false)).toMatchSnapshot();\n    });\n  });\n});\n","/Users/simen/repos/jest/packages/jest-snapshot/src/__tests__/throwMatcher.test.ts",["175","176","177"],[],"/**\n * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport {type Context, toThrowErrorMatchingSnapshot} from '../';\n\nconst mockedMatch = jest.fn(() => ({\n  actual: 'coconut',\n  expected: 'coconut',\n}));\n\nconst mockedContext = {\n  snapshotState: {match: mockedMatch},\n} as unknown as Context;\n\nafterEach(() => {\n  jest.clearAllMocks();\n});\n\nit('throw matcher can take func', () => {\n  toThrowErrorMatchingSnapshot.call(\n    mockedContext,\n    () => {\n      throw new Error('coconut');\n    },\n    undefined,\n    false,\n  );\n\n  expect(mockedMatch).toHaveBeenCalledTimes(1);\n  expect(mockedMatch).toHaveBeenCalledWith(\n    expect.objectContaining({received: 'coconut', testName: ''}),\n  );\n});\n\ndescribe('throw matcher from promise', () => {\n  it('can take error', () => {\n    toThrowErrorMatchingSnapshot.call(\n      mockedContext,\n      new Error('coco'),\n      'testName',\n      true,\n    );\n\n    expect(mockedMatch).toHaveBeenCalledTimes(1);\n    expect(mockedMatch).toHaveBeenCalledWith(\n      expect.objectContaining({received: 'coco', testName: ''}),\n    );\n  });\n\n  it('can take custom error', () => {\n    class CustomError extends Error {}\n\n    toThrowErrorMatchingSnapshot.call(\n      mockedContext,\n      new CustomError('nut'),\n      'testName',\n      true,\n    );\n\n    expect(mockedMatch).toHaveBeenCalledTimes(1);\n    expect(mockedMatch).toHaveBeenCalledWith(\n      expect.objectContaining({received: 'nut', testName: ''}),\n    );\n  });\n});\n","/Users/simen/repos/jest/packages/jest-snapshot/src/__tests__/utils.test.ts",["178","179","180","181","182","183"],["184","185","186","187","188","189","190","191","192","193","194","195","196","197"],"/**\n * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\njest.mock('graceful-fs', () => ({\n  ...jest.createMockFromModule<typeof import('fs')>('fs'),\n  existsSync: jest.fn().mockReturnValue(true),\n}));\n\nimport {strict as assert} from 'assert';\nimport * as path from 'path';\nimport chalk = require('chalk');\nimport * as fs from 'graceful-fs';\nimport {\n  SNAPSHOT_GUIDE_LINK,\n  SNAPSHOT_VERSION,\n  SNAPSHOT_VERSION_WARNING,\n  addExtraLineBreaks,\n  deepMerge,\n  getSnapshotData,\n  keyToTestName,\n  removeExtraLineBreaks,\n  removeLinesBeforeExternalMatcherTrap,\n  saveSnapshotFile,\n  serialize,\n  testNameToKey,\n} from '../utils';\n\ntest('keyToTestName()', () => {\n  expect(keyToTestName('abc cde 12')).toBe('abc cde');\n  expect(keyToTestName('abc cde   12')).toBe('abc cde  ');\n  expect(() => keyToTestName('abc cde')).toThrow(\n    'Snapshot keys must end with a number.',\n  );\n});\n\ntest('testNameToKey', () => {\n  expect(testNameToKey('abc cde', 1)).toBe('abc cde 1');\n  expect(testNameToKey('abc cde ', 12)).toBe('abc cde  12');\n});\n\ntest('saveSnapshotFile() works with \\r\\n', () => {\n  const filename = path.join(__dirname, 'remove-newlines.snap');\n  const data = {\n    myKey: '<div>\\r\\n</div>',\n  };\n\n  saveSnapshotFile(data, filename);\n  expect(fs.writeFileSync).toHaveBeenCalledWith(\n    filename,\n    `// Jest Snapshot v1, ${SNAPSHOT_GUIDE_LINK}\\n\\n` +\n      'exports[`myKey`] = `<div>\\n</div>`;\\n',\n  );\n});\n\ntest('saveSnapshotFile() works with \\r', () => {\n  const filename = path.join(__dirname, 'remove-newlines.snap');\n  const data = {\n    myKey: '<div>\\r</div>',\n  };\n\n  saveSnapshotFile(data, filename);\n  expect(fs.writeFileSync).toHaveBeenCalledWith(\n    filename,\n    `// Jest Snapshot v1, ${SNAPSHOT_GUIDE_LINK}\\n\\n` +\n      'exports[`myKey`] = `<div>\\n</div>`;\\n',\n  );\n});\n\ntest('getSnapshotData() throws when no snapshot version', () => {\n  const filename = path.join(__dirname, 'old-snapshot.snap');\n  jest\n    .mocked(fs.readFileSync)\n    .mockReturnValue('exports[`myKey`] = `<div>\\n</div>`;\\n');\n  const update = 'none';\n\n  expect(() => getSnapshotData(filename, update)).toThrow(\n    chalk.red(\n      `${chalk.bold('Outdated snapshot')}: No snapshot header found. ` +\n        'Jest 19 introduced versioned snapshots to ensure all developers on ' +\n        'a project are using the same version of Jest. ' +\n        'Please update all snapshots during this upgrade of Jest.\\n\\n',\n    ) + SNAPSHOT_VERSION_WARNING,\n  );\n});\n\ntest('getSnapshotData() throws for older snapshot version', () => {\n  const filename = path.join(__dirname, 'old-snapshot.snap');\n  jest\n    .mocked(fs.readFileSync)\n    .mockReturnValue(\n      `// Jest Snapshot v0.99, ${SNAPSHOT_GUIDE_LINK}\\n\\n` +\n        'exports[`myKey`] = `<div>\\n</div>`;\\n',\n    );\n  const update = 'none';\n\n  expect(() => getSnapshotData(filename, update)).toThrow(\n    `${chalk.red(\n      `${chalk.red.bold('Outdated snapshot')}: The version of the snapshot ` +\n        'file associated with this test is outdated. The snapshot file ' +\n        'version ensures that all developers on a project are using ' +\n        'the same version of Jest. ' +\n        'Please update all snapshots during this upgrade of Jest.',\n    )}\\n\\nExpected: v${SNAPSHOT_VERSION}\\n` +\n      `Received: v0.99\\n\\n${SNAPSHOT_VERSION_WARNING}`,\n  );\n});\n\ntest('getSnapshotData() throws for newer snapshot version', () => {\n  const filename = path.join(__dirname, 'old-snapshot.snap');\n  jest\n    .mocked(fs.readFileSync)\n    .mockReturnValue(\n      `// Jest Snapshot v2, ${SNAPSHOT_GUIDE_LINK}\\n\\n` +\n        'exports[`myKey`] = `<div>\\n</div>`;\\n',\n    );\n  const update = 'none';\n\n  expect(() => getSnapshotData(filename, update)).toThrow(\n    `${chalk.red(\n      `${chalk.red.bold('Outdated Jest version')}: The version of this ` +\n        'snapshot file indicates that this project is meant to be used ' +\n        'with a newer version of Jest. ' +\n        'The snapshot file version ensures that all developers on a project ' +\n        'are using the same version of Jest. ' +\n        'Please update your version of Jest and re-run the tests.',\n    )}\\n\\nExpected: v${SNAPSHOT_VERSION}\\nReceived: v2`,\n  );\n});\n\ntest('getSnapshotData() does not throw for when updating', () => {\n  const filename = path.join(__dirname, 'old-snapshot.snap');\n  jest\n    .mocked(fs.readFileSync)\n    .mockReturnValue('exports[`myKey`] = `<div>\\n</div>`;\\n');\n  const update = 'all';\n\n  expect(() => getSnapshotData(filename, update)).not.toThrow();\n});\n\ntest('getSnapshotData() marks invalid snapshot dirty when updating', () => {\n  const filename = path.join(__dirname, 'old-snapshot.snap');\n  jest\n    .mocked(fs.readFileSync)\n    .mockReturnValue('exports[`myKey`] = `<div>\\n</div>`;\\n');\n  const update = 'all';\n\n  expect(getSnapshotData(filename, update)).toMatchObject({dirty: true});\n});\n\ntest('getSnapshotData() marks valid snapshot not dirty when updating', () => {\n  const filename = path.join(__dirname, 'old-snapshot.snap');\n  jest\n    .mocked(fs.readFileSync)\n    .mockReturnValue(\n      `// Jest Snapshot v${SNAPSHOT_VERSION}, ${SNAPSHOT_GUIDE_LINK}\\n\\n` +\n        'exports[`myKey`] = `<div>\\n</div>`;\\n',\n    );\n  const update = 'all';\n\n  expect(getSnapshotData(filename, update)).toMatchObject({dirty: false});\n});\n\ntest('escaping', () => {\n  const filename = path.join(__dirname, 'escaping.snap');\n  const data = '\"\\'\\\\';\n  const writeFileSync = jest.mocked(fs.writeFileSync);\n\n  writeFileSync.mockReset();\n  saveSnapshotFile({key: data}, filename);\n  const writtenData = writeFileSync.mock.calls[0][1];\n  expect(writtenData).toBe(\n    `// Jest Snapshot v1, ${SNAPSHOT_GUIDE_LINK}\\n\\n` +\n      'exports[`key`] = `\"\\'\\\\\\\\`;\\n',\n  );\n\n  // @ts-expect-error: used in `eval`\n  const exports = {};\n  // eslint-disable-next-line no-eval\n  const readData = eval(`var exports = {}; ${writtenData} exports`);\n  expect(readData).toEqual({key: data});\n  const snapshotData = readData.key;\n  expect(data).toEqual(snapshotData);\n});\n\ntest('serialize handles \\\\r\\\\n', () => {\n  const data = '<div>\\r\\n</div>';\n  const serializedData = serialize(data);\n\n  expect(serializedData).toBe('\"<div>\\n</div>\"');\n});\n\ndescribe('ExtraLineBreaks', () => {\n  test('0 empty string', () => {\n    const expected = '';\n\n    const added = addExtraLineBreaks(expected);\n    const removed = removeExtraLineBreaks(added);\n\n    expect(added).toBe(expected);\n    expect(removed).toBe(expected);\n  });\n\n  test('1 line has double quote marks at edges', () => {\n    const expected = '\" one line \"';\n\n    const added = addExtraLineBreaks(expected);\n    const removed = removeExtraLineBreaks(added);\n\n    expect(added).toBe(expected);\n    expect(removed).toBe(expected);\n  });\n\n  test('1 line has spaces at edges', () => {\n    const expected = ' one line ';\n\n    const added = addExtraLineBreaks(expected);\n    const removed = removeExtraLineBreaks(added);\n\n    expect(added).toBe(expected);\n    expect(removed).toBe(expected);\n  });\n\n  test('2 lines both are blank', () => {\n    const expected = '\\n';\n\n    const added = addExtraLineBreaks(expected);\n    const removed = removeExtraLineBreaks(added);\n\n    expect(added).toBe(`\\n${expected}\\n`);\n    expect(removed).toBe(expected);\n  });\n\n  test('2 lines have double quote marks at edges', () => {\n    const expected = '\"\\n\"';\n\n    const added = addExtraLineBreaks(expected);\n    const removed = removeExtraLineBreaks(added);\n\n    expect(added).toBe(`\\n${expected}\\n`);\n    expect(removed).toBe(expected);\n  });\n\n  test('2 lines first is blank', () => {\n    const expected = '\\nsecond line ';\n\n    const added = addExtraLineBreaks(expected);\n    const removed = removeExtraLineBreaks(added);\n\n    expect(added).toBe(`\\n${expected}\\n`);\n    expect(removed).toBe(expected);\n  });\n\n  test('2 lines last is blank', () => {\n    const expected = ' first line\\n';\n\n    const added = addExtraLineBreaks(expected);\n    const removed = removeExtraLineBreaks(added);\n\n    expect(added).toBe(`\\n${expected}\\n`);\n    expect(removed).toBe(expected);\n  });\n});\n\ndescribe('removeLinesBeforeExternalMatcherTrap', () => {\n  test('contains external matcher trap', () => {\n    const stack = `Error:\n    at SnapshotState._addSnapshot (/jest/packages/jest-snapshot/build/State.js:150:9)\n    at SnapshotState.match (/jest/packages/jest-snapshot/build/State.js:303:14)\n    at _toMatchSnapshot (/jest/packages/jest-snapshot/build/index.js:399:32)\n    at _toThrowErrorMatchingSnapshot (/jest/packages/jest-snapshot/build/index.js:585:10)\n    at Object.toThrowErrorMatchingInlineSnapshot (/jest/packages/jest-snapshot/build/index.js:504:10)\n    at Object.<anonymous> (/jest/packages/expect/build/index.js:138:20)\n    at __EXTERNAL_MATCHER_TRAP__ (/jest/packages/expect/build/index.js:378:30)\n    at throwingMatcher (/jest/packages/expect/build/index.js:379:15)\n    at /jest/packages/expect/build/index.js:285:72\n    at Object.<anonymous> (/jest/e2e/to-throw-error-matching-inline-snapshot/__tests__/should-support-rejecting-promises.test.js:3:7)`;\n\n    const expected = `    at throwingMatcher (/jest/packages/expect/build/index.js:379:15)\n    at /jest/packages/expect/build/index.js:285:72\n    at Object.<anonymous> (/jest/e2e/to-throw-error-matching-inline-snapshot/__tests__/should-support-rejecting-promises.test.js:3:7)`;\n\n    expect(removeLinesBeforeExternalMatcherTrap(stack)).toBe(expected);\n  });\n\n  test(\"doesn't contain external matcher trap\", () => {\n    const stack = `Error:\n    at SnapshotState._addSnapshot (/jest/packages/jest-snapshot/build/State.js:150:9)\n    at SnapshotState.match (/jest/packages/jest-snapshot/build/State.js:303:14)\n    at _toMatchSnapshot (/jest/packages/jest-snapshot/build/index.js:399:32)\n    at _toThrowErrorMatchingSnapshot (/jest/packages/jest-snapshot/build/index.js:585:10)\n    at Object.toThrowErrorMatchingInlineSnapshot (/jest/packages/jest-snapshot/build/index.js:504:10)\n    at Object.<anonymous> (/jest/packages/expect/build/index.js:138:20)\n    at throwingMatcher (/jest/packages/expect/build/index.js:379:15)\n    at /jest/packages/expect/build/index.js:285:72\n    at Object.<anonymous> (/jest/e2e/to-throw-error-matching-inline-snapshot/__tests__/should-support-rejecting-promises.test.js:3:7)`;\n\n    expect(removeLinesBeforeExternalMatcherTrap(stack)).toBe(stack);\n  });\n});\n\ndescribe('DeepMerge with property matchers', () => {\n  const matcher = expect.any(String);\n\n  it.each(\n    /* eslint-disable sort-keys */\n    // to keep keys in numerical order rather than alphabetical\n    [\n      [\n        'a nested object',\n        // Target\n        {\n          data: {\n            one: 'one',\n            two: 'two',\n          },\n        },\n        // Matchers\n        {\n          data: {\n            two: matcher,\n          },\n        },\n        // Expected\n        {\n          data: {\n            one: 'one',\n            two: matcher,\n          },\n        },\n      ],\n\n      [\n        'an object with an array of objects',\n        // Target\n        {\n          data: {\n            one: [\n              {\n                two: 'two',\n                three: 'three',\n              },\n              // Include an array element not present in the propertyMatchers\n              {\n                four: 'four',\n                five: 'five',\n              },\n            ],\n            six: [{seven: 'seven'}],\n            nine: [[{ten: 'ten'}]],\n          },\n        },\n        // Matchers\n        {\n          data: {\n            one: [\n              {\n                two: matcher,\n              },\n            ],\n            six: [\n              {seven: matcher},\n              // Include an array element not present in the target\n              {eight: matcher},\n            ],\n            nine: [[{ten: matcher}]],\n          },\n        },\n        // Expected\n        {\n          data: {\n            one: [\n              {\n                two: matcher,\n                three: 'three',\n              },\n              {\n                four: 'four',\n                five: 'five',\n              },\n            ],\n            six: [{seven: matcher}, {eight: matcher}],\n            nine: [[{ten: matcher}]],\n          },\n        },\n      ],\n\n      [\n        'an object with an array of strings',\n        // Target\n        {\n          data: {\n            one: ['one'],\n            two: ['two'],\n            three: ['three', 'four'],\n            five: ['five'],\n          },\n        },\n        // Matchers\n        {\n          data: {\n            one: [matcher],\n            two: ['two'],\n            three: [matcher],\n            five: 'five',\n          },\n        },\n        // Expected\n        {\n          data: {\n            one: [matcher],\n            two: ['two'],\n            three: [matcher, 'four'],\n            five: 'five',\n          },\n        },\n      ],\n\n      [\n        'an array of objects',\n        // Target\n        [{name: 'one'}, {name: 'two'}, {name: 'three'}],\n        // Matchers\n        [{name: 'one'}, {name: matcher}, {name: matcher}],\n        // Expected\n        [{name: 'one'}, {name: matcher}, {name: matcher}],\n      ],\n\n      [\n        'an array of arrays',\n        // Target\n        [['one'], ['two'], ['three']],\n        // Matchers\n        [['one'], [matcher], [matcher]],\n        // Expected\n        [['one'], [matcher], [matcher]],\n      ],\n    ],\n    /* eslint-enable sort-keys */\n  )('Correctly merges %s', (_case, target, propertyMatchers, expected) => {\n    const originalTarget = JSON.parse(JSON.stringify(target));\n    const mergedOutput = deepMerge(target, propertyMatchers);\n\n    // Use assert.deepStrictEqual() instead of expect().toStrictEqual()\n    // since we want to actually validate that we got the matcher\n    // rather than treat it specially the way that expect() does\n    assert.deepStrictEqual(mergedOutput, expected);\n\n    // Ensure original target is not modified\n    expect(target).toStrictEqual(originalTarget);\n  });\n});\n","/Users/simen/repos/jest/packages/jest-snapshot/src/colors.ts",[],[],"/Users/simen/repos/jest/packages/jest-snapshot/src/dedentLines.ts",[],[],"/Users/simen/repos/jest/packages/jest-snapshot/src/index.ts",["198","199","200","201","202","203","204","205","206","207","208","209","210","211","212","213","214","215","216"],[],"/**\n * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport * as fs from 'graceful-fs';\nimport type {Config} from '@jest/types';\nimport type {MatcherFunctionWithContext} from 'expect';\nimport type {IHasteFS} from 'jest-haste-map';\nimport {\n  BOLD_WEIGHT,\n  EXPECTED_COLOR,\n  MatcherHintOptions,\n  RECEIVED_COLOR,\n  matcherErrorMessage,\n  matcherHint,\n  printWithType,\n  stringify,\n} from 'jest-matcher-utils';\nimport {EXTENSION, SnapshotResolver} from './SnapshotResolver';\nimport {\n  PROPERTIES_ARG,\n  SNAPSHOT_ARG,\n  bReceivedColor,\n  matcherHintFromConfig,\n  noColor,\n  printExpected,\n  printPropertiesAndReceived,\n  printReceived,\n  printSnapshotAndReceived,\n} from './printSnapshot';\nimport type {Context, MatchSnapshotConfig} from './types';\nimport {deepMerge, escapeBacktickString, serialize} from './utils';\n\nexport {addSerializer, getSerializers} from './plugins';\nexport {\n  EXTENSION,\n  buildSnapshotResolver,\n  isSnapshotPath,\n} from './SnapshotResolver';\nexport type {SnapshotResolver} from './SnapshotResolver';\nexport {default as SnapshotState} from './State';\nexport type {Context, SnapshotMatchers} from './types';\n\nconst DID_NOT_THROW = 'Received function did not throw'; // same as toThrow\nconst NOT_SNAPSHOT_MATCHERS = `Snapshot matchers cannot be used with ${BOLD_WEIGHT(\n  'not',\n)}`;\n\nconst INDENTATION_REGEX = /^([^\\S\\n]*)\\S/m;\n\n// Display name in report when matcher fails same as in snapshot file,\n// but with optional hint argument in bold weight.\nconst printSnapshotName = (\n  concatenatedBlockNames = '',\n  hint = '',\n  count: number,\n): string => {\n  const hasNames = concatenatedBlockNames.length !== 0;\n  const hasHint = hint.length !== 0;\n\n  return `Snapshot name: \\`${\n    hasNames ? escapeBacktickString(concatenatedBlockNames) : ''\n  }${hasNames && hasHint ? ': ' : ''}${\n    hasHint ? BOLD_WEIGHT(escapeBacktickString(hint)) : ''\n  } ${count}\\``;\n};\n\nfunction stripAddedIndentation(inlineSnapshot: string) {\n  // Find indentation if exists.\n  const match = inlineSnapshot.match(INDENTATION_REGEX);\n  if (!match || !match[1]) {\n    // No indentation.\n    return inlineSnapshot;\n  }\n\n  const indentation = match[1];\n  const lines = inlineSnapshot.split('\\n');\n  if (lines.length <= 2) {\n    // Must be at least 3 lines.\n    return inlineSnapshot;\n  }\n\n  if (lines[0].trim() !== '' || lines[lines.length - 1].trim() !== '') {\n    // If not blank first and last lines, abort.\n    return inlineSnapshot;\n  }\n\n  for (let i = 1; i < lines.length - 1; i++) {\n    if (lines[i] !== '') {\n      if (lines[i].indexOf(indentation) !== 0) {\n        // All lines except first and last should either be blank or have the same\n        // indent as the first line (or more). If this isn't the case we don't\n        // want to touch the snapshot at all.\n        return inlineSnapshot;\n      }\n\n      lines[i] = lines[i].substring(indentation.length);\n    }\n  }\n\n  // Last line is a special case because it won't have the same indent as others\n  // but may still have been given some indent to line up.\n  lines[lines.length - 1] = '';\n\n  // Return inline snapshot, now at indent 0.\n  inlineSnapshot = lines.join('\\n');\n  return inlineSnapshot;\n}\n\nconst fileExists = (filePath: string, hasteFS: IHasteFS): boolean =>\n  hasteFS.exists(filePath) || fs.existsSync(filePath);\n\nexport const cleanup = (\n  hasteFS: IHasteFS,\n  update: Config.SnapshotUpdateState,\n  snapshotResolver: SnapshotResolver,\n  testPathIgnorePatterns?: Config.ProjectConfig['testPathIgnorePatterns'],\n): {\n  filesRemoved: number;\n  filesRemovedList: Array<string>;\n} => {\n  const pattern = `\\\\.${EXTENSION}$`;\n  const files = hasteFS.matchFiles(pattern);\n  let testIgnorePatternsRegex: RegExp | null = null;\n  if (testPathIgnorePatterns && testPathIgnorePatterns.length > 0) {\n    testIgnorePatternsRegex = new RegExp(testPathIgnorePatterns.join('|'));\n  }\n\n  const list = files.filter(snapshotFile => {\n    const testPath = snapshotResolver.resolveTestPath(snapshotFile);\n\n    // ignore snapshots of ignored tests\n    if (testIgnorePatternsRegex && testIgnorePatternsRegex.test(testPath)) {\n      return false;\n    }\n\n    if (!fileExists(testPath, hasteFS)) {\n      if (update === 'all') {\n        fs.unlinkSync(snapshotFile);\n      }\n      return true;\n    }\n\n    return false;\n  });\n\n  return {\n    filesRemoved: list.length,\n    filesRemovedList: list,\n  };\n};\n\nexport const toMatchSnapshot: MatcherFunctionWithContext<\n  Context,\n  [propertiesOrHint?: object | string, hint?: string]\n> = function (received, propertiesOrHint, hint) {\n  const matcherName = 'toMatchSnapshot';\n  let properties;\n\n  const length = arguments.length;\n  if (length === 2 && typeof propertiesOrHint === 'string') {\n    hint = propertiesOrHint;\n  } else if (length >= 2) {\n    if (\n      Array.isArray(propertiesOrHint) ||\n      typeof propertiesOrHint !== 'object' ||\n      propertiesOrHint === null\n    ) {\n      const options: MatcherHintOptions = {\n        isNot: this.isNot,\n        promise: this.promise,\n      };\n      let printedWithType = printWithType(\n        'Expected properties',\n        propertiesOrHint,\n        printExpected,\n      );\n\n      if (length === 3) {\n        options.secondArgument = 'hint';\n        options.secondArgumentColor = BOLD_WEIGHT;\n\n        if (propertiesOrHint == null) {\n          printedWithType +=\n            \"\\n\\nTo provide a hint without properties: toMatchSnapshot('hint')\";\n        }\n      }\n\n      throw new Error(\n        matcherErrorMessage(\n          matcherHint(matcherName, undefined, PROPERTIES_ARG, options),\n          `Expected ${EXPECTED_COLOR('properties')} must be an object`,\n          printedWithType,\n        ),\n      );\n    }\n\n    // Future breaking change: Snapshot hint must be a string\n    // if (arguments.length === 3 && typeof hint !== 'string') {}\n\n    properties = propertiesOrHint;\n  }\n\n  return _toMatchSnapshot({\n    context: this,\n    hint,\n    isInline: false,\n    matcherName,\n    properties,\n    received,\n  });\n};\n\nexport const toMatchInlineSnapshot: MatcherFunctionWithContext<\n  Context,\n  [propertiesOrSnapshot?: object | string, inlineSnapshot?: string]\n> = function (received, propertiesOrSnapshot, inlineSnapshot) {\n  const matcherName = 'toMatchInlineSnapshot';\n  let properties;\n\n  const length = arguments.length;\n  if (length === 2 && typeof propertiesOrSnapshot === 'string') {\n    inlineSnapshot = propertiesOrSnapshot;\n  } else if (length >= 2) {\n    const options: MatcherHintOptions = {\n      isNot: this.isNot,\n      promise: this.promise,\n    };\n    if (length === 3) {\n      options.secondArgument = SNAPSHOT_ARG;\n      options.secondArgumentColor = noColor;\n    }\n\n    if (\n      Array.isArray(propertiesOrSnapshot) ||\n      typeof propertiesOrSnapshot !== 'object' ||\n      propertiesOrSnapshot === null\n    ) {\n      throw new Error(\n        matcherErrorMessage(\n          matcherHint(matcherName, undefined, PROPERTIES_ARG, options),\n          `Expected ${EXPECTED_COLOR('properties')} must be an object`,\n          printWithType(\n            'Expected properties',\n            propertiesOrSnapshot,\n            printExpected,\n          ),\n        ),\n      );\n    }\n\n    if (length === 3 && typeof inlineSnapshot !== 'string') {\n      throw new Error(\n        matcherErrorMessage(\n          matcherHint(matcherName, undefined, PROPERTIES_ARG, options),\n          'Inline snapshot must be a string',\n          printWithType('Inline snapshot', inlineSnapshot, serialize),\n        ),\n      );\n    }\n\n    properties = propertiesOrSnapshot;\n  }\n\n  return _toMatchSnapshot({\n    context: this,\n    inlineSnapshot:\n      inlineSnapshot !== undefined\n        ? stripAddedIndentation(inlineSnapshot)\n        : undefined,\n    isInline: true,\n    matcherName,\n    properties,\n    received,\n  });\n};\n\nconst _toMatchSnapshot = (config: MatchSnapshotConfig) => {\n  const {context, hint, inlineSnapshot, isInline, matcherName, properties} =\n    config;\n  let {received} = config;\n\n  context.dontThrow && context.dontThrow();\n\n  const {currentTestName, isNot, snapshotState} = context;\n\n  if (isNot) {\n    throw new Error(\n      matcherErrorMessage(\n        matcherHintFromConfig(config, false),\n        NOT_SNAPSHOT_MATCHERS,\n      ),\n    );\n  }\n\n  if (snapshotState == null) {\n    // Because the state is the problem, this is not a matcher error.\n    // Call generic stringify from jest-matcher-utils package\n    // because uninitialized snapshot state does not need snapshot serializers.\n    throw new Error(\n      `${matcherHintFromConfig(config, false)}\\n\\n` +\n        'Snapshot state must be initialized' +\n        `\\n\\n${printWithType('Snapshot state', snapshotState, stringify)}`,\n    );\n  }\n\n  const fullTestName =\n    currentTestName && hint\n      ? `${currentTestName}: ${hint}`\n      : currentTestName || ''; // future BREAKING change: || hint\n\n  if (typeof properties === 'object') {\n    if (typeof received !== 'object' || received === null) {\n      throw new Error(\n        matcherErrorMessage(\n          matcherHintFromConfig(config, false),\n          `${RECEIVED_COLOR(\n            'received',\n          )} value must be an object when the matcher has ${EXPECTED_COLOR(\n            'properties',\n          )}`,\n          printWithType('Received', received, printReceived),\n        ),\n      );\n    }\n\n    const propertyPass = context.equals(received, properties, [\n      context.utils.iterableEquality,\n      context.utils.subsetEquality,\n    ]);\n\n    if (!propertyPass) {\n      const key = snapshotState.fail(fullTestName, received);\n      const matched = /(\\d+)$/.exec(key);\n      const count = matched === null ? 1 : Number(matched[1]);\n\n      const message = () =>\n        `${matcherHintFromConfig(config, false)}\\n\\n${printSnapshotName(\n          currentTestName,\n          hint,\n          count,\n        )}\\n\\n${printPropertiesAndReceived(\n          properties,\n          received,\n          snapshotState.expand,\n        )}`;\n\n      return {\n        message,\n        name: matcherName,\n        pass: false,\n      };\n    } else {\n      received = deepMerge(received, properties);\n    }\n  }\n\n  const result = snapshotState.match({\n    error: context.error,\n    inlineSnapshot,\n    isInline,\n    received,\n    testName: fullTestName,\n  });\n  const {actual, count, expected, pass} = result;\n\n  if (pass) {\n    return {message: () => '', pass: true};\n  }\n\n  const message =\n    expected === undefined\n      ? () =>\n          `${matcherHintFromConfig(config, true)}\\n\\n${printSnapshotName(\n            currentTestName,\n            hint,\n            count,\n          )}\\n\\n` +\n          `New snapshot was ${BOLD_WEIGHT('not written')}. The update flag ` +\n          'must be explicitly passed to write a new snapshot.\\n\\n' +\n          'This is likely because this test is run in a continuous integration ' +\n          '(CI) environment in which snapshots are not written by default.\\n\\n' +\n          `Received:${actual.includes('\\n') ? '\\n' : ' '}${bReceivedColor(\n            actual,\n          )}`\n      : () =>\n          `${matcherHintFromConfig(config, true)}\\n\\n${printSnapshotName(\n            currentTestName,\n            hint,\n            count,\n          )}\\n\\n${printSnapshotAndReceived(\n            expected,\n            actual,\n            received,\n            snapshotState.expand,\n            snapshotState.snapshotFormat,\n          )}`;\n\n  // Passing the actual and expected objects so that a custom reporter\n  // could access them, for example in order to display a custom visual diff,\n  // or create a different error message\n  return {\n    actual,\n    expected,\n    message,\n    name: matcherName,\n    pass: false,\n  };\n};\n\nexport const toThrowErrorMatchingSnapshot: MatcherFunctionWithContext<\n  Context,\n  [hint?: string, fromPromise?: boolean]\n> = function (received, hint, fromPromise) {\n  const matcherName = 'toThrowErrorMatchingSnapshot';\n\n  // Future breaking change: Snapshot hint must be a string\n  // if (hint !== undefined && typeof hint !== string) {}\n\n  return _toThrowErrorMatchingSnapshot(\n    {\n      context: this,\n      hint,\n      isInline: false,\n      matcherName,\n      received,\n    },\n    fromPromise,\n  );\n};\n\nexport const toThrowErrorMatchingInlineSnapshot: MatcherFunctionWithContext<\n  Context,\n  [inlineSnapshot?: string, fromPromise?: boolean]\n> = function (received, inlineSnapshot, fromPromise) {\n  const matcherName = 'toThrowErrorMatchingInlineSnapshot';\n\n  if (inlineSnapshot !== undefined && typeof inlineSnapshot !== 'string') {\n    const options: MatcherHintOptions = {\n      expectedColor: noColor,\n      isNot: this.isNot,\n      promise: this.promise,\n    };\n\n    throw new Error(\n      matcherErrorMessage(\n        matcherHint(matcherName, undefined, SNAPSHOT_ARG, options),\n        'Inline snapshot must be a string',\n        printWithType('Inline snapshot', inlineSnapshot, serialize),\n      ),\n    );\n  }\n\n  return _toThrowErrorMatchingSnapshot(\n    {\n      context: this,\n      inlineSnapshot:\n        inlineSnapshot !== undefined\n          ? stripAddedIndentation(inlineSnapshot)\n          : undefined,\n      isInline: true,\n      matcherName,\n      received,\n    },\n    fromPromise,\n  );\n};\n\nconst _toThrowErrorMatchingSnapshot = (\n  config: MatchSnapshotConfig,\n  fromPromise?: boolean,\n) => {\n  const {context, hint, inlineSnapshot, isInline, matcherName, received} =\n    config;\n\n  context.dontThrow && context.dontThrow();\n\n  const {isNot, promise} = context;\n\n  if (!fromPromise) {\n    if (typeof received !== 'function') {\n      const options: MatcherHintOptions = {isNot, promise};\n\n      throw new Error(\n        matcherErrorMessage(\n          matcherHint(matcherName, undefined, '', options),\n          `${RECEIVED_COLOR('received')} value must be a function`,\n          printWithType('Received', received, printReceived),\n        ),\n      );\n    }\n  }\n\n  if (isNot) {\n    throw new Error(\n      matcherErrorMessage(\n        matcherHintFromConfig(config, false),\n        NOT_SNAPSHOT_MATCHERS,\n      ),\n    );\n  }\n\n  let error;\n\n  if (fromPromise) {\n    error = received;\n  } else {\n    try {\n      received();\n    } catch (e) {\n      error = e;\n    }\n  }\n\n  if (error === undefined) {\n    // Because the received value is a function, this is not a matcher error.\n    throw new Error(\n      `${matcherHintFromConfig(config, false)}\\n\\n${DID_NOT_THROW}`,\n    );\n  }\n\n  return _toMatchSnapshot({\n    context,\n    hint,\n    inlineSnapshot,\n    isInline,\n    matcherName,\n    received: error.message,\n  });\n};\n","/Users/simen/repos/jest/packages/jest-snapshot/src/mockSerializer.ts",["217","218","219","220","221","222","223","224","225","226","227"],[],"/**\n * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport type {NewPlugin} from 'pretty-format';\n\nexport const serialize: NewPlugin['serialize'] = (\n  val,\n  config,\n  indentation,\n  depth,\n  refs,\n  printer,\n): string => {\n  // Serialize a non-default name, even if config.printFunctionName is false.\n  const name = val.getMockName();\n  const nameString = name === 'jest.fn()' ? '' : ` ${name}`;\n\n  let callsString = '';\n  if (val.mock.calls.length !== 0) {\n    const indentationNext = indentation + config.indent;\n    callsString = ` {${config.spacingOuter}${indentationNext}\"calls\": ${printer(\n      val.mock.calls,\n      config,\n      indentationNext,\n      depth,\n      refs,\n    )}${config.min ? ', ' : ','}${\n      config.spacingOuter\n    }${indentationNext}\"results\": ${printer(\n      val.mock.results,\n      config,\n      indentationNext,\n      depth,\n      refs,\n    )}${config.min ? '' : ','}${config.spacingOuter}${indentation}}`;\n  }\n\n  return `[MockFunction${nameString}]${callsString}`;\n};\n\nexport const test: NewPlugin['test'] = val => val && !!val._isMockFunction;\n\nconst plugin: NewPlugin = {serialize, test};\n\nexport default plugin;\n","/Users/simen/repos/jest/packages/jest-snapshot/src/plugins.ts",[],[],"/Users/simen/repos/jest/packages/jest-snapshot/src/printSnapshot.ts",["228"],[],"/**\n * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport chalk = require('chalk');\nimport {getObjectSubset} from '@jest/expect-utils';\nimport {\n  DIFF_DELETE,\n  DIFF_EQUAL,\n  DIFF_INSERT,\n  Diff,\n  DiffOptionsColor,\n  diffLinesUnified,\n  diffLinesUnified2,\n  diffStringsRaw,\n  diffStringsUnified,\n} from 'jest-diff';\nimport {getType, isPrimitive} from 'jest-get-type';\nimport {\n  BOLD_WEIGHT,\n  EXPECTED_COLOR,\n  INVERTED_COLOR,\n  MatcherHintOptions,\n  RECEIVED_COLOR,\n  getLabelPrinter,\n  matcherHint,\n} from 'jest-matcher-utils';\nimport {format as prettyFormat} from 'pretty-format';\nimport {\n  aBackground2,\n  aBackground3,\n  aForeground2,\n  aForeground3,\n  bBackground2,\n  bBackground3,\n  bForeground2,\n  bForeground3,\n} from './colors';\nimport {dedentLines} from './dedentLines';\nimport type {MatchSnapshotConfig, SnapshotFormat} from './types';\nimport {deserializeString, minify, serialize} from './utils';\n\ntype Chalk = chalk.Chalk;\n\nexport const getSnapshotColorForChalkInstance = (\n  chalkInstance: Chalk,\n): DiffOptionsColor => {\n  const level = chalkInstance.level;\n\n  if (level === 3) {\n    return chalkInstance\n      .rgb(aForeground3[0], aForeground3[1], aForeground3[2])\n      .bgRgb(aBackground3[0], aBackground3[1], aBackground3[2]);\n  }\n\n  if (level === 2) {\n    return chalkInstance.ansi256(aForeground2).bgAnsi256(aBackground2);\n  }\n\n  return chalkInstance.magenta.bgYellowBright;\n};\n\nexport const getReceivedColorForChalkInstance = (\n  chalkInstance: Chalk,\n): DiffOptionsColor => {\n  const level = chalkInstance.level;\n\n  if (level === 3) {\n    return chalkInstance\n      .rgb(bForeground3[0], bForeground3[1], bForeground3[2])\n      .bgRgb(bBackground3[0], bBackground3[1], bBackground3[2]);\n  }\n\n  if (level === 2) {\n    return chalkInstance.ansi256(bForeground2).bgAnsi256(bBackground2);\n  }\n\n  return chalkInstance.cyan.bgWhiteBright; // also known as teal\n};\n\nexport const aSnapshotColor = getSnapshotColorForChalkInstance(chalk);\nexport const bReceivedColor = getReceivedColorForChalkInstance(chalk);\n\nexport const noColor = (string: string): string => string;\n\nexport const HINT_ARG = 'hint';\nexport const SNAPSHOT_ARG = 'snapshot';\nexport const PROPERTIES_ARG = 'properties';\n\nexport const matcherHintFromConfig = (\n  {\n    context: {isNot, promise},\n    hint,\n    inlineSnapshot,\n    matcherName,\n    properties,\n  }: MatchSnapshotConfig,\n  isUpdatable: boolean,\n): string => {\n  const options: MatcherHintOptions = {isNot, promise};\n  if (isUpdatable) {\n    options.receivedColor = bReceivedColor;\n  }\n\n  let expectedArgument = '';\n\n  if (typeof properties === 'object') {\n    expectedArgument = PROPERTIES_ARG;\n    if (isUpdatable) {\n      options.expectedColor = noColor;\n    }\n\n    if (typeof hint === 'string' && hint.length !== 0) {\n      options.secondArgument = HINT_ARG;\n      options.secondArgumentColor = BOLD_WEIGHT;\n    } else if (typeof inlineSnapshot === 'string') {\n      options.secondArgument = SNAPSHOT_ARG;\n      if (isUpdatable) {\n        options.secondArgumentColor = aSnapshotColor;\n      } else {\n        options.secondArgumentColor = noColor;\n      }\n    }\n  } else {\n    if (typeof hint === 'string' && hint.length !== 0) {\n      expectedArgument = HINT_ARG;\n      options.expectedColor = BOLD_WEIGHT;\n    } else if (typeof inlineSnapshot === 'string') {\n      expectedArgument = SNAPSHOT_ARG;\n      if (isUpdatable) {\n        options.expectedColor = aSnapshotColor;\n      }\n    }\n  }\n\n  return matcherHint(matcherName, undefined, expectedArgument, options);\n};\n\n// Given array of diffs, return string:\n// * include common substrings\n// * exclude change substrings which have opposite op\n// * include change substrings which have argument op\n//   with change color only if there is a common substring\nconst joinDiffs = (\n  diffs: Array<Diff>,\n  op: number,\n  hasCommon: boolean,\n): string =>\n  diffs.reduce(\n    (reduced: string, diff: Diff): string =>\n      reduced +\n      (diff[0] === DIFF_EQUAL\n        ? diff[1]\n        : diff[0] !== op\n        ? ''\n        : hasCommon\n        ? INVERTED_COLOR(diff[1])\n        : diff[1]),\n    '',\n  );\n\nconst isLineDiffable = (received: unknown): boolean => {\n  const receivedType = getType(received);\n\n  if (isPrimitive(received)) {\n    return typeof received === 'string';\n  }\n\n  if (\n    receivedType === 'date' ||\n    receivedType === 'function' ||\n    receivedType === 'regexp'\n  ) {\n    return false;\n  }\n\n  if (received instanceof Error) {\n    return false;\n  }\n\n  if (\n    receivedType === 'object' &&\n    typeof (received as any).asymmetricMatch === 'function'\n  ) {\n    return false;\n  }\n\n  return true;\n};\n\nexport const printExpected = (val: unknown): string =>\n  EXPECTED_COLOR(minify(val));\nexport const printReceived = (val: unknown): string =>\n  RECEIVED_COLOR(minify(val));\n\nexport const printPropertiesAndReceived = (\n  properties: object,\n  received: object,\n  expand: boolean, // CLI options: true if `--expand` or false if `--no-expand`\n): string => {\n  const aAnnotation = 'Expected properties';\n  const bAnnotation = 'Received value';\n\n  if (isLineDiffable(properties) && isLineDiffable(received)) {\n    return diffLinesUnified(\n      serialize(properties).split('\\n'),\n      serialize(getObjectSubset(received, properties)).split('\\n'),\n      {\n        aAnnotation,\n        aColor: EXPECTED_COLOR,\n        bAnnotation,\n        bColor: RECEIVED_COLOR,\n        changeLineTrailingSpaceColor: chalk.bgYellow,\n        commonLineTrailingSpaceColor: chalk.bgYellow,\n        emptyFirstOrLastLinePlaceholder: '↵', // U+21B5\n        expand,\n        includeChangeCounts: true,\n      },\n    );\n  }\n\n  const printLabel = getLabelPrinter(aAnnotation, bAnnotation);\n  return `${printLabel(aAnnotation) + printExpected(properties)}\\n${printLabel(\n    bAnnotation,\n  )}${printReceived(received)}`;\n};\n\nconst MAX_DIFF_STRING_LENGTH = 20000;\n\nexport const printSnapshotAndReceived = (\n  a: string, // snapshot without extra line breaks\n  b: string, // received serialized but without extra line breaks\n  received: unknown,\n  expand: boolean, // CLI options: true if `--expand` or false if `--no-expand`\n  snapshotFormat?: SnapshotFormat,\n): string => {\n  const aAnnotation = 'Snapshot';\n  const bAnnotation = 'Received';\n  const aColor = aSnapshotColor;\n  const bColor = bReceivedColor;\n  const options = {\n    aAnnotation,\n    aColor,\n    bAnnotation,\n    bColor,\n    changeLineTrailingSpaceColor: noColor,\n    commonLineTrailingSpaceColor: chalk.bgYellow,\n    emptyFirstOrLastLinePlaceholder: '↵', // U+21B5\n    expand,\n    includeChangeCounts: true,\n  };\n\n  if (typeof received === 'string') {\n    if (\n      a.length >= 2 &&\n      a.startsWith('\"') &&\n      a.endsWith('\"') &&\n      b === prettyFormat(received)\n    ) {\n      // If snapshot looks like default serialization of a string\n      // and received is string which has default serialization.\n\n      if (!a.includes('\\n') && !b.includes('\\n')) {\n        // If neither string is multiline,\n        // display as labels and quoted strings.\n        let aQuoted = a;\n        let bQuoted = b;\n\n        if (\n          a.length - 2 <= MAX_DIFF_STRING_LENGTH &&\n          b.length - 2 <= MAX_DIFF_STRING_LENGTH\n        ) {\n          const diffs = diffStringsRaw(a.slice(1, -1), b.slice(1, -1), true);\n          const hasCommon = diffs.some(diff => diff[0] === DIFF_EQUAL);\n          aQuoted = `\"${joinDiffs(diffs, DIFF_DELETE, hasCommon)}\"`;\n          bQuoted = `\"${joinDiffs(diffs, DIFF_INSERT, hasCommon)}\"`;\n        }\n\n        const printLabel = getLabelPrinter(aAnnotation, bAnnotation);\n        return `${printLabel(aAnnotation) + aColor(aQuoted)}\\n${printLabel(\n          bAnnotation,\n        )}${bColor(bQuoted)}`;\n      }\n\n      // Else either string is multiline, so display as unquoted strings.\n      a = deserializeString(a); //  hypothetical expected string\n      b = received; // not serialized\n    }\n    // Else expected had custom serialization or was not a string\n    // or received has custom serialization.\n\n    return a.length <= MAX_DIFF_STRING_LENGTH &&\n      b.length <= MAX_DIFF_STRING_LENGTH\n      ? diffStringsUnified(a, b, options)\n      : diffLinesUnified(a.split('\\n'), b.split('\\n'), options);\n  }\n\n  if (isLineDiffable(received)) {\n    const aLines2 = a.split('\\n');\n    const bLines2 = b.split('\\n');\n\n    // Fall through to fix a regression for custom serializers\n    // like jest-snapshot-serializer-raw that ignore the indent option.\n    const b0 = serialize(received, 0, snapshotFormat);\n    if (b0 !== b) {\n      const aLines0 = dedentLines(aLines2);\n\n      if (aLines0 !== null) {\n        // Compare lines without indentation.\n        const bLines0 = b0.split('\\n');\n\n        return diffLinesUnified2(aLines2, bLines2, aLines0, bLines0, options);\n      }\n    }\n\n    // Fall back because:\n    // * props include a multiline string\n    // * text has more than one adjacent line\n    // * markup does not close\n    return diffLinesUnified(aLines2, bLines2, options);\n  }\n\n  const printLabel = getLabelPrinter(aAnnotation, bAnnotation);\n  return `${printLabel(aAnnotation) + aColor(a)}\\n${printLabel(\n    bAnnotation,\n  )}${bColor(b)}`;\n};\n","/Users/simen/repos/jest/packages/jest-snapshot/src/types.ts",[],[],"/Users/simen/repos/jest/packages/jest-snapshot/src/utils.ts",["229","230","231","232","233","234","235","236","237","238","239","240","241","242","243","244","245","246","247","248","249","250","251","252","253","254","255","256","257","258","259","260"],["261","262","263","264","265"],"/**\n * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport * as path from 'path';\nimport chalk = require('chalk');\nimport * as fs from 'graceful-fs';\nimport naturalCompare = require('natural-compare');\nimport type {Config} from '@jest/types';\nimport {\n  OptionsReceived as PrettyFormatOptions,\n  format as prettyFormat,\n} from 'pretty-format';\nimport {getSerializers} from './plugins';\nimport type {SnapshotData} from './types';\n\nexport const SNAPSHOT_VERSION = '1';\nconst SNAPSHOT_VERSION_REGEXP = /^\\/\\/ Jest Snapshot v(.+),/;\nexport const SNAPSHOT_GUIDE_LINK = 'https://goo.gl/fbAQLP';\nexport const SNAPSHOT_VERSION_WARNING = chalk.yellow(\n  `${chalk.bold('Warning')}: Before you upgrade snapshots, ` +\n    'we recommend that you revert any local changes to tests or other code, ' +\n    'to ensure that you do not store invalid state.',\n);\n\nconst writeSnapshotVersion = () =>\n  `// Jest Snapshot v${SNAPSHOT_VERSION}, ${SNAPSHOT_GUIDE_LINK}`;\n\nconst validateSnapshotVersion = (snapshotContents: string) => {\n  const versionTest = SNAPSHOT_VERSION_REGEXP.exec(snapshotContents);\n  const version = versionTest && versionTest[1];\n\n  if (!version) {\n    return new Error(\n      chalk.red(\n        `${chalk.bold('Outdated snapshot')}: No snapshot header found. ` +\n          'Jest 19 introduced versioned snapshots to ensure all developers ' +\n          'on a project are using the same version of Jest. ' +\n          'Please update all snapshots during this upgrade of Jest.\\n\\n',\n      ) + SNAPSHOT_VERSION_WARNING,\n    );\n  }\n\n  if (version < SNAPSHOT_VERSION) {\n    return new Error(\n      // eslint-disable-next-line prefer-template\n      chalk.red(\n        `${chalk.red.bold('Outdated snapshot')}: The version of the snapshot ` +\n          'file associated with this test is outdated. The snapshot file ' +\n          'version ensures that all developers on a project are using ' +\n          'the same version of Jest. ' +\n          'Please update all snapshots during this upgrade of Jest.',\n      ) +\n        '\\n\\n' +\n        `Expected: v${SNAPSHOT_VERSION}\\n` +\n        `Received: v${version}\\n\\n` +\n        SNAPSHOT_VERSION_WARNING,\n    );\n  }\n\n  if (version > SNAPSHOT_VERSION) {\n    return new Error(\n      // eslint-disable-next-line prefer-template\n      chalk.red(\n        `${chalk.red.bold('Outdated Jest version')}: The version of this ` +\n          'snapshot file indicates that this project is meant to be used ' +\n          'with a newer version of Jest. The snapshot file version ensures ' +\n          'that all developers on a project are using the same version of ' +\n          'Jest. Please update your version of Jest and re-run the tests.',\n      ) +\n        '\\n\\n' +\n        `Expected: v${SNAPSHOT_VERSION}\\n` +\n        `Received: v${version}`,\n    );\n  }\n\n  return null;\n};\n\nfunction isObject(item: unknown): boolean {\n  return item != null && typeof item === 'object' && !Array.isArray(item);\n}\n\nexport const testNameToKey = (testName: string, count: number): string =>\n  `${testName} ${count}`;\n\nexport const keyToTestName = (key: string): string => {\n  if (!/ \\d+$/.test(key)) {\n    throw new Error('Snapshot keys must end with a number.');\n  }\n\n  return key.replace(/ \\d+$/, '');\n};\n\nexport const getSnapshotData = (\n  snapshotPath: string,\n  update: Config.SnapshotUpdateState,\n): {\n  data: SnapshotData;\n  dirty: boolean;\n} => {\n  const data = Object.create(null);\n  let snapshotContents = '';\n  let dirty = false;\n\n  if (fs.existsSync(snapshotPath)) {\n    try {\n      snapshotContents = fs.readFileSync(snapshotPath, 'utf8');\n      // eslint-disable-next-line no-new-func\n      const populate = new Function('exports', snapshotContents);\n      populate(data);\n    } catch {}\n  }\n\n  const validationResult = validateSnapshotVersion(snapshotContents);\n  const isInvalid = snapshotContents && validationResult;\n\n  if (update === 'none' && isInvalid) {\n    throw validationResult;\n  }\n\n  if ((update === 'all' || update === 'new') && isInvalid) {\n    dirty = true;\n  }\n\n  return {data, dirty};\n};\n\n// Add extra line breaks at beginning and end of multiline snapshot\n// to make the content easier to read.\nexport const addExtraLineBreaks = (string: string): string =>\n  string.includes('\\n') ? `\\n${string}\\n` : string;\n\n// Remove extra line breaks at beginning and end of multiline snapshot.\n// Instead of trim, which can remove additional newlines or spaces\n// at beginning or end of the content from a custom serializer.\nexport const removeExtraLineBreaks = (string: string): string =>\n  string.length > 2 && string.startsWith('\\n') && string.endsWith('\\n')\n    ? string.slice(1, -1)\n    : string;\n\nexport const removeLinesBeforeExternalMatcherTrap = (stack: string): string => {\n  const lines = stack.split('\\n');\n\n  for (let i = 0; i < lines.length; i += 1) {\n    // It's a function name specified in `packages/expect/src/index.ts`\n    // for external custom matchers.\n    if (lines[i].includes('__EXTERNAL_MATCHER_TRAP__')) {\n      return lines.slice(i + 1).join('\\n');\n    }\n  }\n\n  return stack;\n};\n\nconst escapeRegex = true;\nconst printFunctionName = false;\n\nexport const serialize = (\n  val: unknown,\n  indent = 2,\n  formatOverrides: PrettyFormatOptions = {},\n): string =>\n  normalizeNewlines(\n    prettyFormat(val, {\n      escapeRegex,\n      indent,\n      plugins: getSerializers(),\n      printFunctionName,\n      ...formatOverrides,\n    }),\n  );\n\nexport const minify = (val: unknown): string =>\n  prettyFormat(val, {\n    escapeRegex,\n    min: true,\n    plugins: getSerializers(),\n    printFunctionName,\n  });\n\n// Remove double quote marks and unescape double quotes and backslashes.\nexport const deserializeString = (stringified: string): string =>\n  stringified.slice(1, -1).replace(/\\\\(\"|\\\\)/g, '$1');\n\nexport const escapeBacktickString = (str: string): string =>\n  str.replace(/`|\\\\|\\${/g, '\\\\$&');\n\nconst printBacktickString = (str: string): string =>\n  `\\`${escapeBacktickString(str)}\\``;\n\nexport const ensureDirectoryExists = (filePath: string): void => {\n  try {\n    fs.mkdirSync(path.join(path.dirname(filePath)), {recursive: true});\n  } catch {}\n};\n\nconst normalizeNewlines = (string: string) => string.replace(/\\r\\n|\\r/g, '\\n');\n\nexport const saveSnapshotFile = (\n  snapshotData: SnapshotData,\n  snapshotPath: string,\n): void => {\n  const snapshots = Object.keys(snapshotData)\n    .sort(naturalCompare)\n    .map(\n      key =>\n        `exports[${printBacktickString(key)}] = ${printBacktickString(\n          normalizeNewlines(snapshotData[key]),\n        )};`,\n    );\n\n  ensureDirectoryExists(snapshotPath);\n  fs.writeFileSync(\n    snapshotPath,\n    `${writeSnapshotVersion()}\\n\\n${snapshots.join('\\n\\n')}\\n`,\n  );\n};\n\nconst deepMergeArray = (target: Array<any>, source: Array<any>) => {\n  const mergedOutput = Array.from(target);\n\n  source.forEach((sourceElement, index) => {\n    const targetElement = mergedOutput[index];\n\n    if (Array.isArray(target[index])) {\n      mergedOutput[index] = deepMergeArray(target[index], sourceElement);\n    } else if (isObject(targetElement)) {\n      mergedOutput[index] = deepMerge(target[index], sourceElement);\n    } else {\n      // Source does not exist in target or target is primitive and cannot be deep merged\n      mergedOutput[index] = sourceElement;\n    }\n  });\n\n  return mergedOutput;\n};\n\n// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\nexport const deepMerge = (target: any, source: any): any => {\n  if (isObject(target) && isObject(source)) {\n    const mergedOutput = {...target};\n\n    Object.keys(source).forEach(key => {\n      if (isObject(source[key]) && !source[key].$$typeof) {\n        if (!(key in target)) Object.assign(mergedOutput, {[key]: source[key]});\n        else mergedOutput[key] = deepMerge(target[key], source[key]);\n      } else if (Array.isArray(source[key])) {\n        mergedOutput[key] = deepMergeArray(target[key], source[key]);\n      } else {\n        Object.assign(mergedOutput, {[key]: source[key]});\n      }\n    });\n\n    return mergedOutput;\n  } else if (Array.isArray(target) && Array.isArray(source)) {\n    return deepMergeArray(target, source);\n  }\n\n  return target;\n};\n",{"ruleId":"266","severity":2,"message":"267","line":23,"column":3,"nodeType":"268","messageId":"269","endLine":23,"endColumn":17},{"ruleId":"266","severity":2,"message":"267","line":28,"column":3,"nodeType":"268","messageId":"269","endLine":28,"endColumn":17},{"ruleId":"266","severity":2,"message":"267","line":31,"column":50,"nodeType":"268","messageId":"269","endLine":31,"endColumn":64},{"ruleId":"266","severity":2,"message":"267","line":35,"column":21,"nodeType":"268","messageId":"269","endLine":35,"endColumn":35},{"ruleId":"270","severity":2,"message":"271","line":53,"column":7,"nodeType":"268","messageId":"272","endLine":53,"endColumn":19,"suggestions":"273"},{"ruleId":"266","severity":2,"message":"267","line":56,"column":18,"nodeType":"268","messageId":"269","endLine":56,"endColumn":32},{"ruleId":"270","severity":2,"message":"274","line":109,"column":9,"nodeType":"275","messageId":"276","endLine":109,"endColumn":59,"suggestions":"277"},{"ruleId":"278","severity":2,"message":"279","line":109,"column":9,"nodeType":"280","messageId":"281","endLine":109,"endColumn":22},{"ruleId":"266","severity":2,"message":"267","line":109,"column":9,"nodeType":"280","messageId":"269","endLine":109,"endColumn":31},{"ruleId":"270","severity":2,"message":"282","line":175,"column":36,"nodeType":"280","messageId":"283","endLine":175,"endColumn":47},{"ruleId":"284","severity":2,"message":"285","line":220,"column":7,"nodeType":"286","messageId":"287","endLine":220,"endColumn":26},{"ruleId":"278","severity":2,"message":"288","line":221,"column":7,"nodeType":"280","messageId":"281","endLine":221,"endColumn":15},{"ruleId":"289","severity":2,"message":"290","line":222,"column":16,"nodeType":"268","messageId":"291","endLine":222,"endColumn":19},{"ruleId":"289","severity":2,"message":"292","line":222,"column":21,"nodeType":"280","messageId":"291","endLine":222,"endColumn":33},{"ruleId":"278","severity":2,"message":"293","line":222,"column":21,"nodeType":"280","messageId":"281","endLine":222,"endColumn":33},{"ruleId":"289","severity":2,"message":"294","line":222,"column":35,"nodeType":"280","messageId":"291","endLine":222,"endColumn":45},{"ruleId":"278","severity":2,"message":"295","line":222,"column":35,"nodeType":"280","messageId":"281","endLine":222,"endColumn":45},{"ruleId":"278","severity":2,"message":"296","line":223,"column":12,"nodeType":"280","messageId":"281","endLine":223,"endColumn":23},{"ruleId":"297","severity":2,"message":"298","line":225,"column":3,"nodeType":"299","messageId":"300","endLine":225,"endColumn":14},{"ruleId":"270","severity":2,"message":"282","line":249,"column":12,"nodeType":"268","messageId":"283","endLine":249,"endColumn":29},{"ruleId":"270","severity":2,"message":"282","line":296,"column":18,"nodeType":"280","messageId":"283","endLine":296,"endColumn":40},{"ruleId":"270","severity":2,"message":"282","line":306,"column":6,"nodeType":"280","messageId":"283","endLine":306,"endColumn":26},{"ruleId":"270","severity":2,"message":"301","line":375,"column":28,"nodeType":"280","messageId":"302","endLine":375,"endColumn":43,"suggestions":"303"},{"ruleId":"284","severity":2,"message":"285","line":86,"column":9,"nodeType":"286","messageId":"287","endLine":88,"endColumn":12},{"ruleId":"278","severity":2,"message":"304","line":86,"column":36,"nodeType":"280","messageId":"281","endLine":88,"endColumn":12},{"ruleId":"270","severity":2,"message":"301","line":90,"column":19,"nodeType":"280","messageId":"302","endLine":90,"endColumn":33,"suggestions":"305"},{"ruleId":"306","severity":2,"message":"307","line":90,"column":34,"nodeType":"308","messageId":"309","endLine":90,"endColumn":36,"suggestions":"310"},{"ruleId":"306","severity":2,"message":"307","line":115,"column":35,"nodeType":"308","messageId":"309","endLine":115,"endColumn":37,"suggestions":"311"},{"ruleId":"270","severity":2,"message":"271","line":117,"column":46,"nodeType":"280","messageId":"272","endLine":117,"endColumn":57,"suggestions":"312"},{"ruleId":"306","severity":2,"message":"307","line":117,"column":58,"nodeType":"308","messageId":"309","endLine":117,"endColumn":60,"suggestions":"313"},{"ruleId":"270","severity":2,"message":"314","line":201,"column":35,"nodeType":"275","messageId":"315","endLine":201,"endColumn":63,"suggestions":"316"},{"ruleId":"306","severity":2,"message":"307","line":201,"column":64,"nodeType":"308","messageId":"309","endLine":201,"endColumn":66,"suggestions":"317"},{"ruleId":"270","severity":2,"message":"271","line":204,"column":10,"nodeType":"268","messageId":"272","endLine":204,"endColumn":13,"suggestions":"318"},{"ruleId":"270","severity":2,"message":"314","line":295,"column":35,"nodeType":"275","messageId":"315","endLine":295,"endColumn":63,"suggestions":"319"},{"ruleId":"306","severity":2,"message":"307","line":295,"column":64,"nodeType":"308","messageId":"309","endLine":295,"endColumn":66,"suggestions":"320"},{"ruleId":"270","severity":2,"message":"271","line":298,"column":10,"nodeType":"268","messageId":"272","endLine":298,"endColumn":13,"suggestions":"321"},{"ruleId":"322","severity":1,"message":"323","line":59,"column":3,"nodeType":"324","messageId":"325","endLine":59,"endColumn":36,"suppressions":"326"},{"ruleId":"327","severity":2,"message":"328","line":231,"column":9,"nodeType":"324","messageId":"329","endLine":231,"endColumn":67,"suggestions":"330"},{"ruleId":"327","severity":2,"message":"328","line":245,"column":9,"nodeType":"324","messageId":"329","endLine":245,"endColumn":77,"suggestions":"331"},{"ruleId":"327","severity":2,"message":"328","line":258,"column":9,"nodeType":"324","messageId":"329","endLine":258,"endColumn":77,"suggestions":"332"},{"ruleId":"327","severity":2,"message":"328","line":272,"column":9,"nodeType":"324","messageId":"329","endLine":272,"endColumn":77,"suggestions":"333"},{"ruleId":"327","severity":2,"message":"328","line":285,"column":9,"nodeType":"324","messageId":"329","endLine":285,"endColumn":65,"suggestions":"334"},{"ruleId":"327","severity":2,"message":"328","line":305,"column":9,"nodeType":"324","messageId":"329","endLine":305,"endColumn":61,"suggestions":"335"},{"ruleId":"327","severity":2,"message":"328","line":319,"column":9,"nodeType":"324","messageId":"329","endLine":319,"endColumn":67,"suggestions":"336"},{"ruleId":"327","severity":2,"message":"328","line":332,"column":9,"nodeType":"324","messageId":"329","endLine":332,"endColumn":61,"suggestions":"337"},{"ruleId":"327","severity":2,"message":"328","line":344,"column":9,"nodeType":"324","messageId":"329","endLine":344,"endColumn":61,"suggestions":"338"},{"ruleId":"327","severity":2,"message":"328","line":359,"column":11,"nodeType":"324","messageId":"329","endLine":359,"endColumn":63,"suggestions":"339"},{"ruleId":"327","severity":2,"message":"328","line":365,"column":11,"nodeType":"324","messageId":"329","endLine":365,"endColumn":59,"suggestions":"340"},{"ruleId":"327","severity":2,"message":"328","line":380,"column":9,"nodeType":"324","messageId":"329","endLine":380,"endColumn":55,"suggestions":"341"},{"ruleId":"327","severity":2,"message":"328","line":398,"column":9,"nodeType":"324","messageId":"329","endLine":404,"endColumn":11,"suggestions":"342"},{"ruleId":"327","severity":2,"message":"328","line":418,"column":9,"nodeType":"324","messageId":"329","endLine":423,"endColumn":11,"suggestions":"343"},{"ruleId":"327","severity":2,"message":"328","line":438,"column":9,"nodeType":"324","messageId":"329","endLine":443,"endColumn":11,"suggestions":"344"},{"ruleId":"327","severity":2,"message":"328","line":457,"column":9,"nodeType":"324","messageId":"329","endLine":457,"endColumn":81,"suggestions":"345"},{"ruleId":"327","severity":2,"message":"328","line":476,"column":9,"nodeType":"324","messageId":"329","endLine":481,"endColumn":11,"suggestions":"346"},{"ruleId":"347","severity":2,"message":"348","line":516,"column":17,"nodeType":"286","messageId":"349","endLine":521,"endColumn":37},{"ruleId":"347","severity":2,"message":"348","line":527,"column":17,"nodeType":"286","messageId":"349","endLine":531,"endColumn":37},{"ruleId":"347","severity":2,"message":"348","line":570,"column":15,"nodeType":"286","messageId":"349","endLine":575,"endColumn":35},{"ruleId":"347","severity":2,"message":"348","line":602,"column":13,"nodeType":"286","messageId":"349","endLine":606,"endColumn":33},{"ruleId":"347","severity":2,"message":"348","line":630,"column":13,"nodeType":"286","messageId":"349","endLine":634,"endColumn":33},{"ruleId":"347","severity":2,"message":"348","line":660,"column":17,"nodeType":"286","messageId":"349","endLine":664,"endColumn":37},{"ruleId":"347","severity":2,"message":"348","line":676,"column":17,"nodeType":"286","messageId":"349","endLine":680,"endColumn":37},{"ruleId":"347","severity":2,"message":"348","line":719,"column":15,"nodeType":"286","messageId":"349","endLine":724,"endColumn":35},{"ruleId":"347","severity":2,"message":"348","line":753,"column":13,"nodeType":"286","messageId":"349","endLine":758,"endColumn":33},{"ruleId":"327","severity":2,"message":"328","line":24,"column":3,"nodeType":"324","messageId":"329","endLine":31,"endColumn":5,"suggestions":"350"},{"ruleId":"327","severity":2,"message":"328","line":41,"column":5,"nodeType":"324","messageId":"329","endLine":46,"endColumn":7,"suggestions":"351"},{"ruleId":"327","severity":2,"message":"328","line":57,"column":5,"nodeType":"324","messageId":"329","endLine":62,"endColumn":7,"suggestions":"352"},{"ruleId":"284","severity":2,"message":"285","line":183,"column":9,"nodeType":"286","messageId":"287","endLine":183,"endColumn":68},{"ruleId":"353","severity":2,"message":"354","line":183,"column":46,"nodeType":"268","messageId":"355","endLine":183,"endColumn":57},{"ruleId":"284","severity":2,"message":"285","line":185,"column":9,"nodeType":"286","messageId":"287","endLine":185,"endColumn":36},{"ruleId":"278","severity":2,"message":"356","line":185,"column":24,"nodeType":"280","messageId":"281","endLine":185,"endColumn":36},{"ruleId":"284","severity":2,"message":"285","line":444,"column":11,"nodeType":"286","messageId":"287","endLine":444,"endColumn":62},{"ruleId":"284","severity":2,"message":"285","line":445,"column":11,"nodeType":"286","messageId":"287","endLine":445,"endColumn":61},{"ruleId":"357","severity":2,"message":"358","line":183,"column":20,"nodeType":"275","messageId":"359","endLine":183,"endColumn":24,"suppressions":"360"},{"ruleId":"361","severity":2,"message":"362","line":344,"column":17,"nodeType":"363","messageId":"364","endLine":344,"endColumn":22,"suppressions":"365"},{"ruleId":"361","severity":2,"message":"366","line":349,"column":17,"nodeType":"363","messageId":"364","endLine":349,"endColumn":21,"suppressions":"367"},{"ruleId":"361","severity":2,"message":"368","line":353,"column":13,"nodeType":"363","messageId":"364","endLine":353,"endColumn":17,"suppressions":"369"},{"ruleId":"361","severity":2,"message":"368","line":369,"column":13,"nodeType":"363","messageId":"364","endLine":369,"endColumn":17,"suppressions":"370"},{"ruleId":"361","severity":2,"message":"362","line":378,"column":17,"nodeType":"363","messageId":"364","endLine":378,"endColumn":22,"suppressions":"371"},{"ruleId":"361","severity":2,"message":"366","line":382,"column":17,"nodeType":"363","messageId":"364","endLine":382,"endColumn":21,"suppressions":"372"},{"ruleId":"361","severity":2,"message":"368","line":386,"column":13,"nodeType":"363","messageId":"364","endLine":386,"endColumn":17,"suppressions":"373"},{"ruleId":"361","severity":2,"message":"362","line":398,"column":13,"nodeType":"363","messageId":"364","endLine":398,"endColumn":18,"suppressions":"374"},{"ruleId":"361","severity":2,"message":"375","line":399,"column":13,"nodeType":"363","messageId":"364","endLine":399,"endColumn":17,"suppressions":"376"},{"ruleId":"361","severity":2,"message":"362","line":407,"column":13,"nodeType":"363","messageId":"364","endLine":407,"endColumn":18,"suppressions":"377"},{"ruleId":"361","severity":2,"message":"375","line":408,"column":13,"nodeType":"363","messageId":"364","endLine":408,"endColumn":17,"suppressions":"378"},{"ruleId":"361","severity":2,"message":"362","line":416,"column":13,"nodeType":"363","messageId":"364","endLine":416,"endColumn":18,"suppressions":"379"},{"ruleId":"361","severity":2,"message":"375","line":417,"column":13,"nodeType":"363","messageId":"364","endLine":417,"endColumn":17,"suppressions":"380"},{"ruleId":"284","severity":2,"message":"381","line":284,"column":8,"nodeType":"268","messageId":"382","endLine":284,"endColumn":16},{"ruleId":"270","severity":2,"message":"282","line":286,"column":3,"nodeType":"280","messageId":"283","endLine":286,"endColumn":20},{"ruleId":"270","severity":2,"message":"301","line":290,"column":7,"nodeType":"268","messageId":"302","endLine":290,"endColumn":12,"suggestions":"383"},{"ruleId":"270","severity":2,"message":"271","line":311,"column":5,"nodeType":"268","messageId":"272","endLine":311,"endColumn":20,"suggestions":"384"},{"ruleId":"270","severity":2,"message":"271","line":311,"column":24,"nodeType":"268","messageId":"272","endLine":311,"endColumn":28,"suggestions":"385"},{"ruleId":"270","severity":2,"message":"271","line":313,"column":9,"nodeType":"268","messageId":"272","endLine":313,"endColumn":24,"suggestions":"386"},{"ruleId":"306","severity":2,"message":"307","line":313,"column":25,"nodeType":"308","messageId":"309","endLine":313,"endColumn":27,"suggestions":"387"},{"ruleId":"289","severity":2,"message":"388","line":347,"column":11,"nodeType":"268","messageId":"291","endLine":347,"endColumn":19},{"ruleId":"284","severity":2,"message":"285","line":357,"column":7,"nodeType":"389","messageId":"287","endLine":357,"endColumn":49},{"ruleId":"284","severity":2,"message":"285","line":365,"column":5,"nodeType":"363","messageId":"287","endLine":365,"endColumn":13},{"ruleId":"284","severity":2,"message":"381","line":476,"column":64,"nodeType":"268","messageId":"382","endLine":476,"endColumn":72},{"ruleId":"270","severity":2,"message":"282","line":479,"column":3,"nodeType":"280","messageId":"283","endLine":479,"endColumn":20},{"ruleId":"270","severity":2,"message":"301","line":483,"column":8,"nodeType":"268","messageId":"302","endLine":483,"endColumn":19,"suggestions":"390"},{"ruleId":"270","severity":2,"message":"301","line":497,"column":7,"nodeType":"268","messageId":"302","endLine":497,"endColumn":12,"suggestions":"391"},{"ruleId":"270","severity":2,"message":"301","line":508,"column":7,"nodeType":"268","messageId":"302","endLine":508,"endColumn":18,"suggestions":"392"},{"ruleId":"284","severity":2,"message":"285","line":509,"column":5,"nodeType":"389","messageId":"287","endLine":509,"endColumn":21},{"ruleId":"266","severity":2,"message":"267","line":512,"column":7,"nodeType":"268","messageId":"269","endLine":512,"endColumn":15},{"ruleId":"284","severity":2,"message":"285","line":531,"column":5,"nodeType":"363","messageId":"287","endLine":531,"endColumn":28},{"ruleId":"278","severity":2,"message":"279","line":531,"column":15,"nodeType":"280","messageId":"281","endLine":531,"endColumn":28},{"ruleId":"284","severity":2,"message":"285","line":19,"column":9,"nodeType":"286","messageId":"287","endLine":19,"endColumn":33},{"ruleId":"278","severity":2,"message":"393","line":19,"column":16,"nodeType":"280","messageId":"281","endLine":19,"endColumn":31},{"ruleId":"266","severity":2,"message":"267","line":19,"column":16,"nodeType":"280","messageId":"269","endLine":19,"endColumn":31},{"ruleId":"353","severity":2,"message":"394","line":20,"column":54,"nodeType":"268","messageId":"355","endLine":20,"endColumn":58},{"ruleId":"278","severity":2,"message":"395","line":23,"column":7,"nodeType":"280","messageId":"281","endLine":23,"endColumn":15},{"ruleId":"278","severity":2,"message":"395","line":26,"column":7,"nodeType":"280","messageId":"281","endLine":26,"endColumn":15},{"ruleId":"278","severity":2,"message":"395","line":34,"column":7,"nodeType":"280","messageId":"281","endLine":34,"endColumn":15},{"ruleId":"270","severity":2,"message":"274","line":45,"column":47,"nodeType":"268","messageId":"276","endLine":45,"endColumn":50,"suggestions":"396"},{"ruleId":"297","severity":2,"message":"298","line":45,"column":47,"nodeType":"397","messageId":"300","endLine":45,"endColumn":75},{"ruleId":"270","severity":2,"message":"274","line":45,"column":56,"nodeType":"280","messageId":"276","endLine":45,"endColumn":75,"suggestions":"398"},{"ruleId":"278","severity":2,"message":"399","line":45,"column":56,"nodeType":"280","messageId":"281","endLine":45,"endColumn":75},{"ruleId":"278","severity":2,"message":"400","line":186,"column":12,"nodeType":"280","messageId":"281","endLine":186,"endColumn":45},{"ruleId":"270","severity":2,"message":"271","line":36,"column":8,"nodeType":"268","messageId":"272","endLine":36,"endColumn":15,"suggestions":"401"},{"ruleId":"284","severity":2,"message":"285","line":105,"column":9,"nodeType":"286","messageId":"287","endLine":105,"endColumn":35},{"ruleId":"402","severity":2,"message":"403","line":113,"column":24,"nodeType":"404","messageId":"405","endLine":113,"endColumn":65},{"ruleId":"270","severity":2,"message":"406","line":121,"column":28,"nodeType":"268","messageId":"407","endLine":121,"endColumn":37},{"ruleId":"270","severity":2,"message":"406","line":125,"column":49,"nodeType":"268","messageId":"407","endLine":125,"endColumn":58},{"ruleId":"284","severity":2,"message":"285","line":129,"column":11,"nodeType":"363","messageId":"287","endLine":129,"endColumn":15},{"ruleId":"284","severity":2,"message":"285","line":227,"column":11,"nodeType":"286","messageId":"287","endLine":227,"endColumn":46},{"ruleId":"289","severity":2,"message":"408","line":230,"column":44,"nodeType":"280","messageId":"291","endLine":230,"endColumn":57},{"ruleId":"289","severity":2,"message":"408","line":230,"column":59,"nodeType":"268","messageId":"291","endLine":230,"endColumn":72},{"ruleId":"284","severity":2,"message":"285","line":232,"column":7,"nodeType":"389","messageId":"287","endLine":232,"endColumn":68},{"ruleId":"284","severity":2,"message":"285","line":235,"column":7,"nodeType":"389","messageId":"287","endLine":235,"endColumn":42},{"ruleId":"297","severity":2,"message":"409","line":239,"column":3,"nodeType":"299","messageId":"300","endLine":239,"endColumn":23},{"ruleId":"284","severity":2,"message":"285","line":245,"column":11,"nodeType":"286","messageId":"287","endLine":245,"endColumn":37},{"ruleId":"289","severity":2,"message":"410","line":247,"column":17,"nodeType":"268","messageId":"291","endLine":247,"endColumn":23},{"ruleId":"278","severity":2,"message":"411","line":248,"column":20,"nodeType":"280","messageId":"281","endLine":248,"endColumn":31},{"ruleId":"270","severity":2,"message":"274","line":248,"column":37,"nodeType":"280","messageId":"276","endLine":248,"endColumn":57,"suggestions":"412"},{"ruleId":"278","severity":2,"message":"411","line":248,"column":37,"nodeType":"280","messageId":"281","endLine":248,"endColumn":48},{"ruleId":"284","severity":2,"message":"285","line":249,"column":60,"nodeType":"363","messageId":"287","endLine":249,"endColumn":78},{"ruleId":"278","severity":2,"message":"411","line":249,"column":67,"nodeType":"280","messageId":"281","endLine":249,"endColumn":78},{"ruleId":"284","severity":2,"message":"285","line":250,"column":14,"nodeType":"389","messageId":"287","endLine":250,"endColumn":69},{"ruleId":"278","severity":2,"message":"411","line":250,"column":14,"nodeType":"280","messageId":"281","endLine":250,"endColumn":31},{"ruleId":"278","severity":2,"message":"411","line":250,"column":44,"nodeType":"280","messageId":"281","endLine":250,"endColumn":55},{"ruleId":"278","severity":2,"message":"411","line":250,"column":57,"nodeType":"280","messageId":"281","endLine":250,"endColumn":68},{"ruleId":"278","severity":2,"message":"411","line":251,"column":32,"nodeType":"280","messageId":"281","endLine":251,"endColumn":43},{"ruleId":"278","severity":2,"message":"411","line":252,"column":9,"nodeType":"280","messageId":"281","endLine":252,"endColumn":26},{"ruleId":"289","severity":2,"message":"408","line":252,"column":44,"nodeType":"280","messageId":"291","endLine":252,"endColumn":55},{"ruleId":"278","severity":2,"message":"411","line":252,"column":44,"nodeType":"280","messageId":"281","endLine":252,"endColumn":55},{"ruleId":"289","severity":2,"message":"408","line":252,"column":57,"nodeType":"280","messageId":"291","endLine":252,"endColumn":68},{"ruleId":"278","severity":2,"message":"411","line":252,"column":57,"nodeType":"280","messageId":"281","endLine":252,"endColumn":68},{"ruleId":"284","severity":2,"message":"285","line":254,"column":38,"nodeType":"363","messageId":"287","endLine":254,"endColumn":56},{"ruleId":"278","severity":2,"message":"411","line":254,"column":45,"nodeType":"280","messageId":"281","endLine":254,"endColumn":56},{"ruleId":"297","severity":2,"message":"409","line":260,"column":5,"nodeType":"299","messageId":"300","endLine":260,"endColumn":43},{"ruleId":"413","severity":2,"message":"414","line":50,"column":7,"nodeType":"415","messageId":"416","endLine":60,"endColumn":33,"fix":"417","suppressions":"418"},{"ruleId":"413","severity":2,"message":"414","line":67,"column":7,"nodeType":"415","messageId":"416","endLine":76,"endColumn":32,"fix":"419","suppressions":"420"},{"ruleId":"421","severity":2,"message":"422","line":113,"column":24,"nodeType":"404","messageId":"405","endLine":113,"endColumn":65,"suppressions":"423"},{"ruleId":"424","severity":2,"message":"425","line":243,"column":27,"nodeType":"268","messageId":"426","endLine":243,"endColumn":38,"suppressions":"427"},{"ruleId":"424","severity":2,"message":"428","line":243,"column":40,"nodeType":"268","messageId":"426","endLine":243,"endColumn":51,"suppressions":"429"},"@typescript-eslint/no-unsafe-call","Unsafe call of an `any` typed value.","Identifier","unsafeCall","@typescript-eslint/strict-boolean-expressions","Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.","conditionErrorNullableString",["430","431","432"],"Unexpected any value in conditional. An explicit comparison or type cast is required.","CallExpression","conditionErrorAny",["433"],"@typescript-eslint/no-unsafe-member-access","Unsafe member access .message on an `any` value.","MemberExpression","unsafeMemberExpression","Unexpected object value in conditional. The condition is always true.","conditionErrorObject","@typescript-eslint/no-unsafe-assignment","Unsafe assignment of an `any` value.","VariableDeclarator","anyAssignment","Unsafe member access .type on an `any` value.","@typescript-eslint/no-unsafe-argument","Unsafe argument of type `any` assigned to a parameter of type `Program`.","unsafeArgument","Unsafe argument of type `any` assigned to a parameter of type `(CommentBlock | CommentLine)[] | null | undefined`.","Unsafe member access .comments on an `any` value.","Unsafe argument of type `any` assigned to a parameter of type `any[] | null | undefined`.","Unsafe member access .tokens on an `any` value.","Unsafe member access .program on an `any` value.","@typescript-eslint/no-unsafe-return","Unsafe return of an `any` typed value.","ReturnStatement","unsafeReturn","Unexpected nullable boolean value in conditional. Please handle the nullish case explicitly.","conditionErrorNullableBoolean",["434","435"],"Unsafe member access .default on an `any` value.",["436","437"],"@typescript-eslint/prefer-nullish-coalescing","Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.","Punctuator","preferNullishOverOr",["438"],["439"],["440","441","442"],["443"],"Unexpected nullable number value in conditional. Please handle the nullish/zero/NaN cases explicitly.","conditionErrorNullableNumber",["444","445","446"],["447"],["448","449","450"],["451","452","453"],["454"],["455","456","457"],"no-new","Do not use 'new' for side effects.","ExpressionStatement","noNewStatement",["458"],"@typescript-eslint/no-floating-promises","Promises must be awaited, end with a call to .catch, end with a call to .then with a rejection handler or be explicitly marked as ignored with the `void` operator.","floatingVoid",["459"],["460"],["461"],["462"],["463"],["464"],["465"],["466"],["467"],["468"],["469"],["470"],["471"],["472"],["473"],["474"],["475"],"jest/unbound-method","Avoid referencing unbound methods which may cause unintentional scoping of `this`.\nIf your function does not access `this`, you can annotate it with `this: void`, or consider using an arrow function instead.","unboundWithoutThisAnnotation",["476"],["477"],["478"],"@typescript-eslint/restrict-template-expressions","Invalid type \"string | ArrayBufferView\" of template literal expression.","invalidType","Unsafe member access .key on an `any` value.","no-eval","eval can be harmful.","unexpected",["479"],"sort-keys","Expected object keys to be in ascending order. 'three' should be before 'two'.","Property","sortKeys",["480"],"Expected object keys to be in ascending order. 'five' should be before 'four'.",["481"],"Expected object keys to be in ascending order. 'nine' should be before 'six'.",["482"],["483"],["484"],["485"],["486"],["487"],"Expected object keys to be in ascending order. 'five' should be before 'three'.",["488"],["489"],["490"],["491"],["492"],"Unsafe array destructuring of a tuple element with an `any` value.","unsafeArrayPatternFromTuple",["493","494"],["495","496","497"],["498","499","500"],["501","502","503"],["504"],"Unsafe argument of type `any` assigned to a parameter of type `object`.","AssignmentExpression",["505","506"],["507","508"],["509","510"],"Unsafe member access .getMockName on an `any` value.","Invalid type \"any\" of template literal expression.","Unsafe member access .mock on an `any` value.",["511"],"LogicalExpression",["512"],"Unsafe member access ._isMockFunction on an `any` value.","Unsafe member access .asymmetricMatch on an `any` value.",["513","514","515"],"@typescript-eslint/no-implied-eval","Implied eval. Do not use the Function constructor to create functions.","NewExpression","noFunctionConstructor","Unexpected value in conditional. A boolean expression is required.","conditionErrorOther","Unsafe argument of type `any` assigned to a parameter of type `any[]`.","Unsafe return of an `any[]` typed value.","Unsafe argument of type `any` assigned to a parameter of type `{}`.","Unsafe member access [key] on an `any` value.",["516"],"prefer-template","Unexpected string concatenation.","BinaryExpression","unexpectedStringConcatenation",{"range":"517","text":"518"},["519"],{"range":"520","text":"521"},["522"],"no-new-func","The Function constructor is eval.",["523"],"@typescript-eslint/explicit-module-boundary-types","Argument 'target' should be typed with a non-any type.","anyTypedArg",["524"],"Argument 'source' should be typed with a non-any type.",["525"],{"messageId":"526","fix":"527","desc":"528"},{"messageId":"529","fix":"530","desc":"531"},{"messageId":"532","fix":"533","desc":"534"},{"messageId":"532","fix":"535","desc":"534"},{"messageId":"536","fix":"537","desc":"538"},{"messageId":"539","fix":"540","desc":"541"},{"messageId":"536","fix":"542","desc":"538"},{"messageId":"543","fix":"544","desc":"545"},{"messageId":"546","fix":"547","desc":"548"},{"messageId":"546","fix":"549","desc":"548"},{"messageId":"526","fix":"550","desc":"528"},{"messageId":"529","fix":"551","desc":"531"},{"messageId":"532","fix":"552","desc":"534"},{"messageId":"546","fix":"553","desc":"548"},{"messageId":"526","fix":"554","desc":"528"},{"messageId":"555","fix":"556","desc":"557"},{"messageId":"532","fix":"558","desc":"534"},{"messageId":"546","fix":"559","desc":"548"},{"messageId":"526","fix":"560","desc":"528"},{"messageId":"529","fix":"561","desc":"531"},{"messageId":"532","fix":"562","desc":"534"},{"messageId":"526","fix":"563","desc":"528"},{"messageId":"555","fix":"564","desc":"557"},{"messageId":"532","fix":"565","desc":"534"},{"messageId":"546","fix":"566","desc":"548"},{"messageId":"526","fix":"567","desc":"528"},{"messageId":"529","fix":"568","desc":"531"},{"messageId":"532","fix":"569","desc":"534"},{"kind":"570","justification":"571"},{"messageId":"572","fix":"573","desc":"574"},{"messageId":"572","fix":"575","desc":"574"},{"messageId":"572","fix":"576","desc":"574"},{"messageId":"572","fix":"577","desc":"574"},{"messageId":"572","fix":"578","desc":"574"},{"messageId":"572","fix":"579","desc":"574"},{"messageId":"572","fix":"580","desc":"574"},{"messageId":"572","fix":"581","desc":"574"},{"messageId":"572","fix":"582","desc":"574"},{"messageId":"572","fix":"583","desc":"574"},{"messageId":"572","fix":"584","desc":"574"},{"messageId":"572","fix":"585","desc":"574"},{"messageId":"572","fix":"586","desc":"574"},{"messageId":"572","fix":"587","desc":"574"},{"messageId":"572","fix":"588","desc":"574"},{"messageId":"572","fix":"589","desc":"574"},{"messageId":"572","fix":"590","desc":"574"},{"messageId":"572","fix":"591","desc":"574"},{"messageId":"572","fix":"592","desc":"574"},{"messageId":"572","fix":"593","desc":"574"},{"kind":"570","justification":"571"},{"kind":"570","justification":"571"},{"kind":"570","justification":"571"},{"kind":"570","justification":"571"},{"kind":"570","justification":"571"},{"kind":"570","justification":"571"},{"kind":"570","justification":"571"},{"kind":"570","justification":"571"},{"kind":"570","justification":"571"},{"kind":"570","justification":"571"},{"kind":"570","justification":"571"},{"kind":"570","justification":"571"},{"kind":"570","justification":"571"},{"kind":"570","justification":"571"},{"messageId":"536","fix":"594","desc":"538"},{"messageId":"543","fix":"595","desc":"545"},{"messageId":"526","fix":"596","desc":"528"},{"messageId":"529","fix":"597","desc":"531"},{"messageId":"532","fix":"598","desc":"534"},{"messageId":"526","fix":"599","desc":"528"},{"messageId":"529","fix":"600","desc":"531"},{"messageId":"532","fix":"601","desc":"534"},{"messageId":"526","fix":"602","desc":"528"},{"messageId":"529","fix":"603","desc":"531"},{"messageId":"532","fix":"604","desc":"534"},{"messageId":"546","fix":"605","desc":"548"},{"messageId":"536","fix":"606","desc":"538"},{"messageId":"539","fix":"607","desc":"541"},{"messageId":"536","fix":"608","desc":"538"},{"messageId":"543","fix":"609","desc":"545"},{"messageId":"536","fix":"610","desc":"538"},{"messageId":"543","fix":"611","desc":"545"},{"messageId":"532","fix":"612","desc":"534"},{"messageId":"532","fix":"613","desc":"534"},{"messageId":"526","fix":"614","desc":"528"},{"messageId":"529","fix":"615","desc":"531"},{"messageId":"532","fix":"616","desc":"534"},{"messageId":"532","fix":"617","desc":"534"},[1801,2297],"`${chalk.red(\n        `${chalk.red.bold('Outdated snapshot')}: The version of the snapshot ` +\n          'file associated with this test is outdated. The snapshot file ' +\n          'version ensures that all developers on a project are using ' +\n          'the same version of Jest. ' +\n          'Please update all snapshots during this upgrade of Jest.',\n      ) \n        }\\n\\n` +\n        `Expected: v${SNAPSHOT_VERSION}\\n` +\n        `Received: v${version}\\n\\n${ \n        SNAPSHOT_VERSION_WARNING}`",{"kind":"570","justification":"571"},[2425,2926],"`${chalk.red(\n        `${chalk.red.bold('Outdated Jest version')}: The version of this ` +\n          'snapshot file indicates that this project is meant to be used ' +\n          'with a newer version of Jest. The snapshot file version ensures ' +\n          'that all developers on a project are using the same version of ' +\n          'Jest. Please update your version of Jest and re-run the tests.',\n      ) \n        }\\n\\n` +\n        `Expected: v${SNAPSHOT_VERSION}\\n` +\n        `Received: v${version}`",{"kind":"570","justification":"571"},{"kind":"570","justification":"571"},{"kind":"570","justification":"571"},{"kind":"570","justification":"571"},"conditionFixCompareNullish",{"range":"618","text":"619"},"Change condition to check for null/undefined (`value != null`)","conditionFixDefaultEmptyString",{"range":"618","text":"620"},"Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)","conditionFixCastBoolean",{"range":"618","text":"621"},"Explicitly cast value to a boolean (`Boolean(value)`)",{"range":"622","text":"623"},"conditionFixDefaultFalse",{"range":"624","text":"625"},"Explicitly treat nullish value the same as false (`value ?? false`)","conditionFixCompareFalse",{"range":"626","text":"627"},"Change condition to check if false (`value === false`)",{"range":"628","text":"629"},"conditionFixCompareTrue",{"range":"628","text":"630"},"Change condition to check if true (`value === true`)","suggestNullish",{"range":"631","text":"632"},"Fix to nullish coalescing operator (`??`).",{"range":"633","text":"632"},{"range":"634","text":"635"},{"range":"634","text":"636"},{"range":"634","text":"637"},{"range":"638","text":"632"},{"range":"639","text":"640"},"conditionFixDefaultZero",{"range":"639","text":"641"},"Explicitly treat nullish value the same as 0 (`value ?? 0`)",{"range":"639","text":"642"},{"range":"643","text":"632"},{"range":"644","text":"645"},{"range":"646","text":"647"},{"range":"644","text":"648"},{"range":"649","text":"640"},{"range":"649","text":"641"},{"range":"649","text":"642"},{"range":"650","text":"632"},{"range":"651","text":"645"},{"range":"652","text":"647"},{"range":"651","text":"648"},"directive","","floatingFixVoid",{"range":"653","text":"654"},"Add void operator to ignore.",{"range":"655","text":"656"},{"range":"657","text":"656"},{"range":"658","text":"656"},{"range":"659","text":"660"},{"range":"661","text":"662"},{"range":"663","text":"664"},{"range":"665","text":"662"},{"range":"666","text":"662"},{"range":"667","text":"668"},{"range":"669","text":"670"},{"range":"671","text":"672"},{"range":"673","text":"674"},{"range":"675","text":"676"},{"range":"677","text":"678"},{"range":"679","text":"680"},{"range":"681","text":"678"},{"range":"682","text":"683"},{"range":"684","text":"685"},{"range":"686","text":"687"},{"range":"688","text":"689"},{"range":"688","text":"690"},{"range":"691","text":"692"},{"range":"691","text":"693"},{"range":"691","text":"694"},{"range":"695","text":"696"},{"range":"695","text":"697"},{"range":"695","text":"698"},{"range":"699","text":"692"},{"range":"699","text":"693"},{"range":"699","text":"694"},{"range":"700","text":"632"},{"range":"701","text":"702"},{"range":"703","text":"704"},{"range":"705","text":"689"},{"range":"705","text":"690"},{"range":"706","text":"707"},{"range":"706","text":"708"},{"range":"709","text":"710"},{"range":"711","text":"712"},{"range":"713","text":"714"},{"range":"715","text":"716"},{"range":"713","text":"717"},{"range":"718","text":"719"},[1633,1645],"prettierPath != null","prettierPath ?? \"\"","Boolean(prettierPath)",[3333,3383],"Boolean(error.message.includes('@babel/plugin-syntax-jsx'))",[11582,11597],"(options.useTabs ?? false)",[11581,11597],"options.useTabs === false",[2587,2601],"(options.expand ?? false)","(options.expand === true)",[2602,2604],"??",[3296,3298],[3397,3408],"(error.stack != null)","(error.stack ?? \"\")","(Boolean(error.stack))",[3409,3411],[5510,5538],"(this._counters.get(testName) != null)","(this._counters.get(testName) ?? 0)","(Boolean(this._counters.get(testName)))",[5539,5541],[5616,5620],"key == null",[5617,5620],"(key ?? \"\")","!Boolean(key)",[8624,8652],[8653,8655],[8730,8734],[8731,8734],[6946,7004],"void toMatchInlineSnapshot.call(context, received, properties);",[7360,7428],"void toMatchInlineSnapshot.call(context, received, properties, snapshot);",[7748,7816],[8175,8243],[8529,8585],"void toMatchInlineSnapshot.call(context, received, snapshot);",[9011,9063],"void toMatchSnapshot.call(context, received, properties);",[9419,9477],"void toMatchSnapshot.call(context, received, properties, hint);",[9805,9857],[10136,10188],[10535,10587],"void toMatchSnapshot.call(context, 'string', properties);",[10704,10752],"void toMatchSnapshot.call(context, null, properties);",[11083,11129],"void toMatchSnapshot.call(context, received, hint);",[11552,11738],"void toThrowErrorMatchingInlineSnapshot.call(\n          context,\n          received,\n          // @ts-expect-error: Testing runtime error\n          snapshot,\n          fromPromise,\n        );",[12079,12212],"void toThrowErrorMatchingInlineSnapshot.call(\n          context,\n          received,\n          snapshot,\n          fromPromise,\n        );",[12551,12679],"void toThrowErrorMatchingSnapshot.call(\n          context,\n          received,\n          undefined,\n          fromPromise,\n        );",[13017,13089],"void toThrowErrorMatchingSnapshot.call(context, received, hint, fromPromise);",[13520,13648],[543,680],"void toThrowErrorMatchingSnapshot.call(\n    mockedContext,\n    () => {\n      throw new Error('coconut');\n    },\n    undefined,\n    false,\n  );",[932,1049],"void toThrowErrorMatchingSnapshot.call(\n      mockedContext,\n      new Error('coco'),\n      'testName',\n      true,\n    );",[1308,1430],"void toThrowErrorMatchingSnapshot.call(\n      mockedContext,\n      new CustomError('nut'),\n      'testName',\n      true,\n    );",[8202,8207],"isNot ?? false","isNot === true",[8837,8852],"(currentTestName != null)","(currentTestName ?? \"\")","(Boolean(currentTestName))",[8856,8860],"(hint != null)","(hint ?? \"\")","(Boolean(hint))",[8907,8922],[8923,8925],[13563,13574],"(fromPromise ?? false)",[13562,13574],"fromPromise === false",[13960,13965],[14135,14146],"fromPromise ?? false","fromPromise === true",[1212,1215],"(Boolean(val))",[1221,1240],"(Boolean(val._isMockFunction))",[1296,1304],"version == null",[1297,1304],"(version ?? \"\")","!Boolean(version)",[7743,7763],"(Boolean(source[key].$$typeof))"]