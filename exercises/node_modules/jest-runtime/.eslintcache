[{"/Users/simen/repos/jest/packages/jest-runtime/src/__tests__/instrumentation.test.ts":"1","/Users/simen/repos/jest/packages/jest-runtime/src/__tests__/runtime_require_resolve.test.ts":"2","/Users/simen/repos/jest/packages/jest-runtime/src/helpers.ts":"3","/Users/simen/repos/jest/packages/jest-runtime/src/index.ts":"4"},{"size":1150,"mtime":1663311355510,"results":"5","hashOfConfig":"6"},{"size":4298,"mtime":1665737657508,"results":"7","hashOfConfig":"6"},{"size":2371,"mtime":1664535326143,"results":"8","hashOfConfig":"6"},{"size":71925,"mtime":1665737657508,"results":"9","hashOfConfig":"6"},{"filePath":"10","messages":"11","suppressedMessages":"12","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},"1liie77",{"filePath":"13","messages":"14","suppressedMessages":"15","errorCount":2,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"16"},{"filePath":"17","messages":"18","suppressedMessages":"19","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"20","messages":"21","suppressedMessages":"22","errorCount":163,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"23"},"/Users/simen/repos/jest/packages/jest-runtime/src/__tests__/instrumentation.test.ts",[],[],"/Users/simen/repos/jest/packages/jest-runtime/src/__tests__/runtime_require_resolve.test.ts",["24","25"],[],"/**\n * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nimport * as os from 'os';\nimport * as path from 'path';\nimport {promises as fs} from 'graceful-fs';\nimport type {Config} from '@jest/types';\nimport type Runtime from '..';\nimport {createOutsideJestVmPath} from '../helpers';\n\nlet createRuntime: (\n  path: string,\n  config?: Config.InitialOptions,\n) => Promise<Runtime & {__mockRootPath: string}>;\n\nconst getTmpDir = async () =>\n  fs.mkdtemp(path.join(os.tmpdir(), 'jest-resolve-test-'));\n\ndescribe('Runtime require.resolve', () => {\n  beforeEach(() => {\n    createRuntime = require('createRuntime');\n  });\n\n  it('resolves a module path', async () => {\n    const runtime = await createRuntime(__filename);\n    const resolved = runtime.requireModule(\n      runtime.__mockRootPath,\n      './resolve_self.js',\n    );\n    expect(resolved).toEqual(require.resolve('./test_root/resolve_self.js'));\n  });\n\n  it('resolves an absolute module path', async () => {\n    const absoluteFilePath = path.join(await getTmpDir(), 'test.js');\n    await fs.writeFile(\n      absoluteFilePath,\n      'module.exports = require.resolve(__filename);',\n      'utf-8',\n    );\n\n    const runtime = await createRuntime(__filename);\n    const resolved = runtime.requireModule(\n      runtime.__mockRootPath,\n      absoluteFilePath,\n    );\n\n    expect(resolved).toEqual(require.resolve(absoluteFilePath));\n  });\n\n  it('required modules can resolve absolute module paths with no paths entries passed', async () => {\n    const tmpdir = await getTmpDir();\n    const entrypoint = path.join(tmpdir, 'test.js');\n    const target = path.join(tmpdir, 'target.js');\n\n    // we want to test the require.resolve implementation within a\n    // runtime-required module, so we need to create a module that then resolves\n    // an absolute path, so we need two files: the entrypoint, and an absolute\n    // target to require.\n    await fs.writeFile(\n      entrypoint,\n      `module.exports = require.resolve(${JSON.stringify(\n        target,\n      )}, {paths: []});`,\n      'utf-8',\n    );\n\n    await fs.writeFile(target, 'module.exports = {}', 'utf-8');\n\n    const runtime = await createRuntime(__filename);\n    const resolved = runtime.requireModule(runtime.__mockRootPath, entrypoint);\n    expect(resolved).toEqual(require.resolve(target, {paths: []}));\n  });\n\n  it('resolves a module path with moduleNameMapper', async () => {\n    const runtime = await createRuntime(__filename, {\n      moduleNameMapper: {\n        '^testMapped/(.*)': '<rootDir>/mapped_dir/$1',\n      },\n    });\n    const resolved = runtime.requireModule(\n      runtime.__mockRootPath,\n      './resolve_mapped.js',\n    );\n    expect(resolved).toEqual(\n      require.resolve('./test_root/mapped_dir/moduleInMapped.js'),\n    );\n  });\n\n  describe('with the jest-resolve-outside-vm-option', () => {\n    it('forwards to the real Node require in an internal context', async () => {\n      const runtime = await createRuntime(__filename);\n      const module = runtime.requireInternalModule(\n        runtime.__mockRootPath,\n        './resolve_and_require_outside.js',\n      );\n      expect(module.required).toBe(\n        require('./test_root/create_require_module'),\n      );\n    });\n\n    it('ignores the option in an external context', async () => {\n      const runtime = await createRuntime(__filename);\n      const module = runtime.requireModule(\n        runtime.__mockRootPath,\n        './resolve_and_require_outside.js',\n      );\n      expect(module.required.foo).toBe('foo');\n      expect(module.required).not.toBe(\n        require('./test_root/create_require_module'),\n      );\n    });\n\n    // make sure we also check isInternal during require, not just during resolve\n    it('does not understand a self-constructed outsideJestVmPath in an external context', async () => {\n      const runtime = await createRuntime(__filename);\n      expect(() =>\n        runtime.requireModule(\n          runtime.__mockRootPath,\n          createOutsideJestVmPath(\n            require.resolve('./test_root/create_require_module.js'),\n          ),\n        ),\n      ).toThrow(/cannot find.+create_require_module/i);\n    });\n  });\n});\n","/Users/simen/repos/jest/packages/jest-runtime/src/helpers.ts",[],[],"/Users/simen/repos/jest/packages/jest-runtime/src/index.ts",["26","27","28","29","30","31","32","33","34","35","36","37","38","39","40","41","42","43","44","45","46","47","48","49","50","51","52","53","54","55","56","57","58","59","60","61","62","63","64","65","66","67","68","69","70","71","72","73","74","75","76","77","78","79","80","81","82","83","84","85","86","87","88","89","90","91","92","93","94","95","96","97","98","99","100","101","102","103","104","105","106","107","108","109","110","111","112","113","114","115","116","117","118","119","120","121","122","123","124","125","126","127","128","129","130","131","132","133","134","135","136","137","138","139","140","141","142","143","144","145","146","147","148","149","150","151","152","153","154","155","156","157","158","159","160","161","162","163","164","165","166","167","168","169","170","171","172","173","174","175","176","177","178","179","180","181","182","183","184","185","186","187","188"],["189"],"/**\n * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport nativeModule = require('module');\nimport * as path from 'path';\nimport {URL, fileURLToPath, pathToFileURL} from 'url';\nimport {\n  Script,\n  // @ts-expect-error: experimental, not added to the types\n  SourceTextModule,\n  // @ts-expect-error: experimental, not added to the types\n  SyntheticModule,\n  Context as VMContext,\n  // @ts-expect-error: experimental, not added to the types\n  Module as VMModule,\n} from 'vm';\nimport {parse as parseCjs} from 'cjs-module-lexer';\nimport {CoverageInstrumenter, V8Coverage} from 'collect-v8-coverage';\nimport * as fs from 'graceful-fs';\nimport slash = require('slash');\nimport stripBOM = require('strip-bom');\nimport type {\n  Jest,\n  JestEnvironment,\n  JestImportMeta,\n  Module,\n  ModuleWrapper,\n} from '@jest/environment';\nimport type {LegacyFakeTimers, ModernFakeTimers} from '@jest/fake-timers';\nimport type {expect, jest} from '@jest/globals';\nimport type {SourceMapRegistry} from '@jest/source-map';\nimport type {\n  RuntimeTransformResult,\n  TestContext,\n  V8CoverageResult,\n} from '@jest/test-result';\nimport {\n  CallerTransformOptions,\n  ScriptTransformer,\n  ShouldInstrumentOptions,\n  TransformResult,\n  TransformationOptions,\n  handlePotentialSyntaxError,\n  shouldInstrument,\n} from '@jest/transform';\nimport type {Config, Global} from '@jest/types';\nimport HasteMap, {IHasteMap, IModuleMap} from 'jest-haste-map';\nimport {formatStackTrace, separateMessageFromStack} from 'jest-message-util';\nimport type {MockMetadata, ModuleMocker} from 'jest-mock';\nimport {escapePathForRegex} from 'jest-regex-util';\nimport Resolver, {ResolveModuleConfig} from 'jest-resolve';\nimport {EXTENSION as SnapshotExtension} from 'jest-snapshot';\nimport {createDirectory, deepCyclicCopy} from 'jest-util';\nimport {\n  createOutsideJestVmPath,\n  decodePossibleOutsideJestVmPath,\n  findSiblingsWithFileExtension,\n} from './helpers';\n\nconst esmIsAvailable = typeof SourceTextModule === 'function';\n\nconst dataURIRegex =\n  /^data:(?<mime>text\\/javascript|application\\/json|application\\/wasm)(?:;(?<encoding>charset=utf-8|base64))?,(?<code>.*)$/;\n\ninterface JestGlobals extends Global.TestFrameworkGlobals {\n  expect: typeof expect;\n}\n\ninterface JestGlobalsWithJest extends JestGlobals {\n  jest: typeof jest;\n}\n\ntype HasteMapOptions = {\n  console?: Console;\n  maxWorkers: number;\n  resetCache: boolean;\n  watch?: boolean;\n  watchman: boolean;\n};\n\ninterface InternalModuleOptions extends Required<CallerTransformOptions> {\n  isInternalModule: boolean;\n}\n\nconst defaultTransformOptions: InternalModuleOptions = {\n  isInternalModule: false,\n  supportsDynamicImport: esmIsAvailable,\n  supportsExportNamespaceFrom: false,\n  supportsStaticESM: false,\n  supportsTopLevelAwait: false,\n};\n\ntype InitialModule = Omit<Module, 'require' | 'parent' | 'paths'>;\ntype ModuleRegistry = Map<string, InitialModule | Module>;\n\n// These are modules that we know\n// * are safe to require from the outside (not stateful, not prone to errors passing in instances from different realms), and\n// * take sufficiently long to require to warrant an optimization.\n// When required from the outside, they use the worker's require cache and are thus\n// only loaded once per worker, not once per test file.\n// Use /benchmarks/test-file-overhead to measure the impact.\n// Note that this only applies when they are required in an internal context;\n// users who require one of these modules in their tests will still get the module from inside the VM.\n// Prefer listing a module here only if it is impractical to use the jest-resolve-outside-vm-option where it is required,\n// e.g. because there are many require sites spread across the dependency graph.\nconst INTERNAL_MODULE_REQUIRE_OUTSIDE_OPTIMIZED_MODULES = new Set(['chalk']);\nconst JEST_RESOLVE_OUTSIDE_VM_OPTION = Symbol.for(\n  'jest-resolve-outside-vm-option',\n);\ntype ResolveOptions = Parameters<typeof require.resolve>[1] & {\n  [JEST_RESOLVE_OUTSIDE_VM_OPTION]?: true;\n};\n\nconst testTimeoutSymbol = Symbol.for('TEST_TIMEOUT_SYMBOL');\nconst retryTimesSymbol = Symbol.for('RETRY_TIMES');\nconst logErrorsBeforeRetrySymbol = Symbol.for('LOG_ERRORS_BEFORE_RETRY');\n\nconst NODE_MODULES = `${path.sep}node_modules${path.sep}`;\n\nconst getModuleNameMapper = (config: Config.ProjectConfig) => {\n  if (\n    Array.isArray(config.moduleNameMapper) &&\n    config.moduleNameMapper.length\n  ) {\n    return config.moduleNameMapper.map(([regex, moduleName]) => ({\n      moduleName,\n      regex: new RegExp(regex),\n    }));\n  }\n  return null;\n};\n\nconst unmockRegExpCache = new WeakMap();\n\nconst EVAL_RESULT_VARIABLE = 'Object.<anonymous>';\n\ntype RunScriptEvalResult = {[EVAL_RESULT_VARIABLE]: ModuleWrapper};\n\nconst runtimeSupportsVmModules = typeof SyntheticModule === 'function';\n\nconst supportsNodeColonModulePrefixInRequire = (() => {\n  try {\n    require('node:fs');\n\n    return true;\n  } catch {\n    return false;\n  }\n})();\n\nexport default class Runtime {\n  private readonly _cacheFS: Map<string, string>;\n  private readonly _config: Config.ProjectConfig;\n  private readonly _globalConfig?: Config.GlobalConfig;\n  private readonly _coverageOptions: ShouldInstrumentOptions;\n  private _currentlyExecutingModulePath: string;\n  private readonly _environment: JestEnvironment;\n  private readonly _explicitShouldMock: Map<string, boolean>;\n  private readonly _explicitShouldMockModule: Map<string, boolean>;\n  private _fakeTimersImplementation:\n    | LegacyFakeTimers<unknown>\n    | ModernFakeTimers\n    | null;\n  private readonly _internalModuleRegistry: ModuleRegistry;\n  private _isCurrentlyExecutingManualMock: string | null;\n  private _mainModule: Module | null;\n  private readonly _mockFactories: Map<string, () => unknown>;\n  private readonly _mockMetaDataCache: Map<string, MockMetadata<any>>;\n  private _mockRegistry: Map<string, any>;\n  private _isolatedMockRegistry: Map<string, any> | null;\n  private readonly _moduleMockRegistry: Map<string, VMModule>;\n  private readonly _moduleMockFactories: Map<string, () => unknown>;\n  private readonly _moduleMocker: ModuleMocker;\n  private _isolatedModuleRegistry: ModuleRegistry | null;\n  private _moduleRegistry: ModuleRegistry;\n  private readonly _esmoduleRegistry: Map<string, VMModule>;\n  private readonly _cjsNamedExports: Map<string, Set<string>>;\n  private readonly _esmModuleLinkingMap: WeakMap<VMModule, Promise<unknown>>;\n  private readonly _testPath: string;\n  private readonly _resolver: Resolver;\n  private _shouldAutoMock: boolean;\n  private readonly _shouldMockModuleCache: Map<string, boolean>;\n  private readonly _shouldUnmockTransitiveDependenciesCache: Map<\n    string,\n    boolean\n  >;\n  private readonly _sourceMapRegistry: SourceMapRegistry;\n  private readonly _scriptTransformer: ScriptTransformer;\n  private readonly _fileTransforms: Map<string, RuntimeTransformResult>;\n  private readonly _fileTransformsMutex: Map<string, Promise<void>>;\n  private _v8CoverageInstrumenter: CoverageInstrumenter | undefined;\n  private _v8CoverageResult: V8Coverage | undefined;\n  private _v8CoverageSources: Map<string, RuntimeTransformResult> | undefined;\n  private readonly _transitiveShouldMock: Map<string, boolean>;\n  private _unmockList: RegExp | undefined;\n  private readonly _virtualMocks: Map<string, boolean>;\n  private readonly _virtualModuleMocks: Map<string, boolean>;\n  private _moduleImplementation?: typeof nativeModule.Module;\n  private readonly jestObjectCaches: Map<string, Jest>;\n  private jestGlobals?: JestGlobals;\n  private readonly esmConditions: Array<string>;\n  private readonly cjsConditions: Array<string>;\n  private isTornDown = false;\n\n  constructor(\n    config: Config.ProjectConfig,\n    environment: JestEnvironment,\n    resolver: Resolver,\n    transformer: ScriptTransformer,\n    cacheFS: Map<string, string>,\n    coverageOptions: ShouldInstrumentOptions,\n    testPath: string,\n    // TODO: make mandatory in Jest 30\n    globalConfig?: Config.GlobalConfig,\n  ) {\n    this._cacheFS = cacheFS;\n    this._config = config;\n    this._coverageOptions = coverageOptions;\n    this._currentlyExecutingModulePath = '';\n    this._environment = environment;\n    this._globalConfig = globalConfig;\n    this._explicitShouldMock = new Map();\n    this._explicitShouldMockModule = new Map();\n    this._internalModuleRegistry = new Map();\n    this._isCurrentlyExecutingManualMock = null;\n    this._mainModule = null;\n    this._mockFactories = new Map();\n    this._mockRegistry = new Map();\n    this._moduleMockRegistry = new Map();\n    this._moduleMockFactories = new Map();\n    invariant(\n      this._environment.moduleMocker,\n      '`moduleMocker` must be set on an environment when created',\n    );\n    this._moduleMocker = this._environment.moduleMocker;\n    this._isolatedModuleRegistry = null;\n    this._isolatedMockRegistry = null;\n    this._moduleRegistry = new Map();\n    this._esmoduleRegistry = new Map();\n    this._cjsNamedExports = new Map();\n    this._esmModuleLinkingMap = new WeakMap();\n    this._testPath = testPath;\n    this._resolver = resolver;\n    this._scriptTransformer = transformer;\n    this._shouldAutoMock = config.automock;\n    this._sourceMapRegistry = new Map();\n    this._fileTransforms = new Map();\n    this._fileTransformsMutex = new Map();\n    this._virtualMocks = new Map();\n    this._virtualModuleMocks = new Map();\n    this.jestObjectCaches = new Map();\n\n    this._mockMetaDataCache = new Map();\n    this._shouldMockModuleCache = new Map();\n    this._shouldUnmockTransitiveDependenciesCache = new Map();\n    this._transitiveShouldMock = new Map();\n\n    this._fakeTimersImplementation = config.fakeTimers.legacyFakeTimers\n      ? this._environment.fakeTimers\n      : this._environment.fakeTimersModern;\n\n    this._unmockList = unmockRegExpCache.get(config);\n    if (!this._unmockList && config.unmockedModulePathPatterns) {\n      this._unmockList = new RegExp(\n        config.unmockedModulePathPatterns.join('|'),\n      );\n      unmockRegExpCache.set(config, this._unmockList);\n    }\n\n    const envExportConditions = this._environment.exportConditions?.() ?? [];\n\n    this.esmConditions = Array.from(\n      new Set(['import', 'default', ...envExportConditions]),\n    );\n    this.cjsConditions = Array.from(\n      new Set(['require', 'default', ...envExportConditions]),\n    );\n\n    if (config.automock) {\n      config.setupFiles.forEach(filePath => {\n        if (filePath.includes(NODE_MODULES)) {\n          const moduleID = this._resolver.getModuleID(\n            this._virtualMocks,\n            filePath,\n            undefined,\n            // shouldn't really matter, but in theory this will make sure the caching is correct\n            {\n              conditions: this.unstable_shouldLoadAsEsm(filePath)\n                ? this.esmConditions\n                : this.cjsConditions,\n            },\n          );\n          this._transitiveShouldMock.set(moduleID, false);\n        }\n      });\n    }\n\n    this.resetModules();\n  }\n\n  static shouldInstrument = shouldInstrument;\n\n  static async createContext(\n    config: Config.ProjectConfig,\n    options: {\n      console?: Console;\n      maxWorkers: number;\n      watch?: boolean;\n      watchman: boolean;\n    },\n  ): Promise<TestContext> {\n    createDirectory(config.cacheDirectory);\n    const instance = await Runtime.createHasteMap(config, {\n      console: options.console,\n      maxWorkers: options.maxWorkers,\n      resetCache: !config.cache,\n      watch: options.watch,\n      watchman: options.watchman,\n    });\n    const hasteMap = await instance.build();\n\n    return {\n      config,\n      hasteFS: hasteMap.hasteFS,\n      moduleMap: hasteMap.moduleMap,\n      resolver: Runtime.createResolver(config, hasteMap.moduleMap),\n    };\n  }\n\n  static createHasteMap(\n    config: Config.ProjectConfig,\n    options?: HasteMapOptions,\n  ): Promise<IHasteMap> {\n    const ignorePatternParts = [\n      ...config.modulePathIgnorePatterns,\n      ...(options && options.watch ? config.watchPathIgnorePatterns : []),\n      config.cacheDirectory.startsWith(config.rootDir + path.sep) &&\n        config.cacheDirectory,\n    ].filter(Boolean);\n    const ignorePattern =\n      ignorePatternParts.length > 0\n        ? new RegExp(ignorePatternParts.join('|'))\n        : undefined;\n\n    return HasteMap.create({\n      cacheDirectory: config.cacheDirectory,\n      computeSha1: config.haste.computeSha1,\n      console: options?.console,\n      dependencyExtractor: config.dependencyExtractor,\n      enableSymlinks: config.haste.enableSymlinks,\n      extensions: [SnapshotExtension].concat(config.moduleFileExtensions),\n      forceNodeFilesystemAPI: config.haste.forceNodeFilesystemAPI,\n      hasteImplModulePath: config.haste.hasteImplModulePath,\n      hasteMapModulePath: config.haste.hasteMapModulePath,\n      id: config.id,\n      ignorePattern,\n      maxWorkers: options?.maxWorkers || 1,\n      mocksPattern: escapePathForRegex(`${path.sep}__mocks__${path.sep}`),\n      platforms: config.haste.platforms || ['ios', 'android'],\n      resetCache: options?.resetCache,\n      retainAllFiles: config.haste.retainAllFiles || false,\n      rootDir: config.rootDir,\n      roots: config.roots,\n      throwOnModuleCollision: config.haste.throwOnModuleCollision,\n      useWatchman: options?.watchman,\n      watch: options?.watch,\n    });\n  }\n\n  static createResolver(\n    config: Config.ProjectConfig,\n    moduleMap: IModuleMap,\n  ): Resolver {\n    return new Resolver(moduleMap, {\n      defaultPlatform: config.haste.defaultPlatform,\n      extensions: config.moduleFileExtensions.map(extension => `.${extension}`),\n      hasCoreModules: true,\n      moduleDirectories: config.moduleDirectories,\n      moduleNameMapper: getModuleNameMapper(config),\n      modulePaths: config.modulePaths,\n      platforms: config.haste.platforms,\n      resolver: config.resolver,\n      rootDir: config.rootDir,\n    });\n  }\n\n  static async runCLI(): Promise<never> {\n    throw new Error('The jest-runtime CLI has been moved into jest-repl');\n  }\n\n  static getCLIOptions(): never {\n    throw new Error('The jest-runtime CLI has been moved into jest-repl');\n  }\n\n  // unstable as it should be replaced by https://github.com/nodejs/modules/issues/393, and we don't want people to use it\n  unstable_shouldLoadAsEsm(path: string): boolean {\n    return Resolver.unstable_shouldLoadAsEsm(\n      path,\n      this._config.extensionsToTreatAsEsm,\n    );\n  }\n\n  // not async _now_, but transform will be\n  private async loadEsmModule(\n    modulePath: string,\n    query = '',\n  ): Promise<VMModule> {\n    const cacheKey = modulePath + query;\n\n    if (this._fileTransformsMutex.has(cacheKey)) {\n      await this._fileTransformsMutex.get(cacheKey);\n    }\n\n    if (!this._esmoduleRegistry.has(cacheKey)) {\n      invariant(\n        typeof this._environment.getVmContext === 'function',\n        'ES Modules are only supported if your test environment has the `getVmContext` function',\n      );\n\n      const context = this._environment.getVmContext();\n\n      invariant(context, 'Test environment has been torn down');\n\n      let transformResolve: () => void;\n      let transformReject: (error?: unknown) => void;\n\n      this._fileTransformsMutex.set(\n        cacheKey,\n        new Promise((resolve, reject) => {\n          transformResolve = resolve;\n          transformReject = reject;\n        }),\n      );\n\n      invariant(\n        transformResolve! && transformReject!,\n        'Promise initialization should be sync - please report this bug to Jest!',\n      );\n\n      if (this._resolver.isCoreModule(modulePath)) {\n        const core = this._importCoreModule(modulePath, context);\n        this._esmoduleRegistry.set(cacheKey, core);\n\n        transformResolve();\n\n        return core;\n      }\n\n      const transformedCode = await this.transformFileAsync(modulePath, {\n        isInternalModule: false,\n        supportsDynamicImport: true,\n        supportsExportNamespaceFrom: true,\n        supportsStaticESM: true,\n        supportsTopLevelAwait: true,\n      });\n\n      try {\n        const module = new SourceTextModule(transformedCode, {\n          context,\n          identifier: modulePath,\n          importModuleDynamically: async (\n            specifier: string,\n            referencingModule: VMModule,\n          ) => {\n            invariant(\n              runtimeSupportsVmModules,\n              'You need to run with a version of node that supports ES Modules in the VM API. See https://jestjs.io/docs/ecmascript-modules',\n            );\n            const module = await this.resolveModule(\n              specifier,\n              referencingModule.identifier,\n              referencingModule.context,\n            );\n\n            return this.linkAndEvaluateModule(module);\n          },\n          initializeImportMeta: (meta: JestImportMeta) => {\n            meta.url = pathToFileURL(modulePath).href;\n\n            let jest = this.jestObjectCaches.get(modulePath);\n\n            if (!jest) {\n              jest = this._createJestObjectFor(modulePath);\n\n              this.jestObjectCaches.set(modulePath, jest);\n            }\n\n            meta.jest = jest;\n          },\n        });\n\n        invariant(\n          !this._esmoduleRegistry.has(cacheKey),\n          `Module cache already has entry ${cacheKey}. This is a bug in Jest, please report it!`,\n        );\n\n        this._esmoduleRegistry.set(cacheKey, module);\n\n        transformResolve();\n      } catch (error) {\n        transformReject(error);\n        throw error;\n      }\n    }\n\n    const module = this._esmoduleRegistry.get(cacheKey);\n\n    invariant(\n      module,\n      'Module cache does not contain module. This is a bug in Jest, please open up an issue',\n    );\n\n    return module;\n  }\n\n  private async resolveModule<T = unknown>(\n    specifier: string,\n    referencingIdentifier: string,\n    context: VMContext,\n  ): Promise<T> {\n    if (this.isTornDown) {\n      this._logFormattedReferenceError(\n        'You are trying to `import` a file after the Jest environment has been torn down.',\n      );\n      process.exitCode = 1;\n      // @ts-expect-error - exiting\n      return;\n    }\n\n    if (specifier === '@jest/globals') {\n      const fromCache = this._esmoduleRegistry.get('@jest/globals');\n\n      if (fromCache) {\n        return fromCache;\n      }\n      const globals = this.getGlobalsForEsm(referencingIdentifier, context);\n      this._esmoduleRegistry.set('@jest/globals', globals);\n\n      return globals;\n    }\n\n    if (specifier.startsWith('data:')) {\n      if (\n        await this._shouldMockModule(\n          referencingIdentifier,\n          specifier,\n          this._explicitShouldMockModule,\n        )\n      ) {\n        return this.importMock(referencingIdentifier, specifier, context);\n      }\n\n      const fromCache = this._esmoduleRegistry.get(specifier);\n\n      if (fromCache) {\n        return fromCache;\n      }\n\n      const match = specifier.match(dataURIRegex);\n\n      if (!match || !match.groups) {\n        throw new Error('Invalid data URI');\n      }\n\n      const mime = match.groups.mime;\n      if (mime === 'application/wasm') {\n        throw new Error('WASM is currently not supported');\n      }\n\n      const encoding = match.groups.encoding;\n      let code = match.groups.code;\n      if (!encoding || encoding === 'charset=utf-8') {\n        code = decodeURIComponent(code);\n      } else if (encoding === 'base64') {\n        code = Buffer.from(code, 'base64').toString();\n      } else {\n        throw new Error(`Invalid data URI encoding: ${encoding}`);\n      }\n\n      let module;\n      if (mime === 'application/json') {\n        module = new SyntheticModule(\n          ['default'],\n          function () {\n            const obj = JSON.parse(code);\n            // @ts-expect-error: TS doesn't know what `this` is\n            this.setExport('default', obj);\n          },\n          {context, identifier: specifier},\n        );\n      } else {\n        module = new SourceTextModule(code, {\n          context,\n          identifier: specifier,\n          importModuleDynamically: async (\n            specifier: string,\n            referencingModule: VMModule,\n          ) => {\n            invariant(\n              runtimeSupportsVmModules,\n              'You need to run with a version of node that supports ES Modules in the VM API. See https://jestjs.io/docs/ecmascript-modules',\n            );\n            const module = await this.resolveModule(\n              specifier,\n              referencingModule.identifier,\n              referencingModule.context,\n            );\n\n            return this.linkAndEvaluateModule(module);\n          },\n          initializeImportMeta(meta: ImportMeta) {\n            // no `jest` here as it's not loaded in a file\n            meta.url = specifier;\n          },\n        });\n      }\n\n      this._esmoduleRegistry.set(specifier, module);\n      return module;\n    }\n\n    if (specifier.startsWith('file://')) {\n      specifier = fileURLToPath(specifier);\n    }\n\n    const [path, query] = specifier.split('?');\n\n    if (\n      await this._shouldMockModule(\n        referencingIdentifier,\n        path,\n        this._explicitShouldMockModule,\n      )\n    ) {\n      return this.importMock(referencingIdentifier, path, context);\n    }\n\n    const resolved = await this._resolveModule(referencingIdentifier, path);\n\n    if (\n      this._resolver.isCoreModule(resolved) ||\n      this.unstable_shouldLoadAsEsm(resolved)\n    ) {\n      return this.loadEsmModule(resolved, query);\n    }\n\n    return this.loadCjsAsEsm(referencingIdentifier, resolved, context);\n  }\n\n  private async linkAndEvaluateModule(\n    module: VMModule,\n  ): Promise<VMModule | void> {\n    if (this.isTornDown) {\n      this._logFormattedReferenceError(\n        'You are trying to `import` a file after the Jest environment has been torn down.',\n      );\n      process.exitCode = 1;\n      return;\n    }\n\n    if (module.status === 'unlinked') {\n      // since we might attempt to link the same module in parallel, stick the promise in a weak map so every call to\n      // this method can await it\n      this._esmModuleLinkingMap.set(\n        module,\n        module.link((specifier: string, referencingModule: VMModule) =>\n          this.resolveModule(\n            specifier,\n            referencingModule.identifier,\n            referencingModule.context,\n          ),\n        ),\n      );\n    }\n\n    await this._esmModuleLinkingMap.get(module);\n\n    if (module.status === 'linked') {\n      await module.evaluate();\n    }\n\n    return module;\n  }\n\n  async unstable_importModule(\n    from: string,\n    moduleName?: string,\n  ): Promise<void> {\n    invariant(\n      runtimeSupportsVmModules,\n      'You need to run with a version of node that supports ES Modules in the VM API. See https://jestjs.io/docs/ecmascript-modules',\n    );\n\n    const [path, query] = (moduleName ?? '').split('?');\n\n    const modulePath = await this._resolveModule(from, path);\n\n    const module = await this.loadEsmModule(modulePath, query);\n\n    return this.linkAndEvaluateModule(module);\n  }\n\n  private loadCjsAsEsm(from: string, modulePath: string, context: VMContext) {\n    // CJS loaded via `import` should share cache with other CJS: https://github.com/nodejs/modules/issues/503\n    const cjs = this.requireModuleOrMock(from, modulePath);\n\n    const parsedExports = this.getExportsOfCjs(modulePath);\n\n    const cjsExports = [...parsedExports].filter(exportName => {\n      // we don't wanna respect any exports _named_ default as a named export\n      if (exportName === 'default') {\n        return false;\n      }\n      return Object.hasOwnProperty.call(cjs, exportName);\n    });\n\n    const module = new SyntheticModule(\n      [...cjsExports, 'default'],\n      function () {\n        cjsExports.forEach(exportName => {\n          // @ts-expect-error: TS doesn't know what `this` is\n          this.setExport(exportName, cjs[exportName]);\n        });\n        // @ts-expect-error: TS doesn't know what `this` is\n        this.setExport('default', cjs);\n      },\n      {context, identifier: modulePath},\n    );\n\n    return evaluateSyntheticModule(module);\n  }\n\n  private async importMock<T = unknown>(\n    from: string,\n    moduleName: string,\n    context: VMContext,\n  ): Promise<T> {\n    const moduleID = await this._resolver.getModuleIDAsync(\n      this._virtualModuleMocks,\n      from,\n      moduleName,\n      {conditions: this.esmConditions},\n    );\n\n    if (this._moduleMockRegistry.has(moduleID)) {\n      return this._moduleMockRegistry.get(moduleID);\n    }\n\n    if (this._moduleMockFactories.has(moduleID)) {\n      const invokedFactory: any = await this._moduleMockFactories.get(\n        moduleID,\n        // has check above makes this ok\n      )!();\n\n      const module = new SyntheticModule(\n        Object.keys(invokedFactory),\n        function () {\n          Object.entries(invokedFactory).forEach(([key, value]) => {\n            // @ts-expect-error: TS doesn't know what `this` is\n            this.setExport(key, value);\n          });\n        },\n        {context, identifier: moduleName},\n      );\n\n      this._moduleMockRegistry.set(moduleID, module);\n\n      return evaluateSyntheticModule(module);\n    }\n\n    throw new Error('Attempting to import a mock without a factory');\n  }\n\n  private getExportsOfCjs(modulePath: string) {\n    const cachedNamedExports = this._cjsNamedExports.get(modulePath);\n\n    if (cachedNamedExports) {\n      return cachedNamedExports;\n    }\n\n    const transformedCode =\n      this._fileTransforms.get(modulePath)?.code ?? this.readFile(modulePath);\n\n    const {exports, reexports} = parseCjs(transformedCode);\n\n    const namedExports = new Set(exports);\n\n    reexports.forEach(reexport => {\n      const resolved = this._resolveCjsModule(modulePath, reexport);\n\n      const exports = this.getExportsOfCjs(resolved);\n\n      exports.forEach(namedExports.add, namedExports);\n    });\n\n    this._cjsNamedExports.set(modulePath, namedExports);\n\n    return namedExports;\n  }\n\n  requireModule<T = unknown>(\n    from: string,\n    moduleName?: string,\n    options?: InternalModuleOptions,\n    isRequireActual = false,\n  ): T {\n    const isInternal = options?.isInternalModule ?? false;\n    const moduleID = this._resolver.getModuleID(\n      this._virtualMocks,\n      from,\n      moduleName,\n      {conditions: this.cjsConditions},\n    );\n    let modulePath: string | undefined;\n\n    // Some old tests rely on this mocking behavior. Ideally we'll change this\n    // to be more explicit.\n    const moduleResource = moduleName && this._resolver.getModule(moduleName);\n    const manualMock =\n      moduleName && this._resolver.getMockModule(from, moduleName);\n    if (\n      !options?.isInternalModule &&\n      !isRequireActual &&\n      !moduleResource &&\n      manualMock &&\n      manualMock !== this._isCurrentlyExecutingManualMock &&\n      this._explicitShouldMock.get(moduleID) !== false\n    ) {\n      modulePath = manualMock;\n    }\n\n    if (moduleName && this._resolver.isCoreModule(moduleName)) {\n      return this._requireCoreModule(\n        moduleName,\n        supportsNodeColonModulePrefixInRequire,\n      );\n    }\n\n    if (!modulePath) {\n      modulePath = this._resolveCjsModule(from, moduleName);\n    }\n\n    if (this.unstable_shouldLoadAsEsm(modulePath)) {\n      // Node includes more info in the message\n      const error: NodeJS.ErrnoException = new Error(\n        `Must use import to load ES Module: ${modulePath}`,\n      );\n\n      error.code = 'ERR_REQUIRE_ESM';\n\n      throw error;\n    }\n\n    let moduleRegistry;\n\n    if (isInternal) {\n      moduleRegistry = this._internalModuleRegistry;\n    } else if (this._isolatedModuleRegistry) {\n      moduleRegistry = this._isolatedModuleRegistry;\n    } else {\n      moduleRegistry = this._moduleRegistry;\n    }\n\n    const module = moduleRegistry.get(modulePath);\n    if (module) {\n      return module.exports;\n    }\n\n    // We must register the pre-allocated module object first so that any\n    // circular dependencies that may arise while evaluating the module can\n    // be satisfied.\n    const localModule: InitialModule = {\n      children: [],\n      exports: {},\n      filename: modulePath,\n      id: modulePath,\n      loaded: false,\n      path: path.dirname(modulePath),\n    };\n    moduleRegistry.set(modulePath, localModule);\n\n    try {\n      this._loadModule(\n        localModule,\n        from,\n        moduleName,\n        modulePath,\n        options,\n        moduleRegistry,\n      );\n    } catch (error) {\n      moduleRegistry.delete(modulePath);\n      throw error;\n    }\n\n    return localModule.exports;\n  }\n\n  requireInternalModule<T = unknown>(from: string, to?: string): T {\n    if (to) {\n      const require = (\n        nativeModule.createRequire ?? nativeModule.createRequireFromPath\n      )(from);\n      if (INTERNAL_MODULE_REQUIRE_OUTSIDE_OPTIMIZED_MODULES.has(to)) {\n        return require(to);\n      }\n      const outsideJestVmPath = decodePossibleOutsideJestVmPath(to);\n      if (outsideJestVmPath) {\n        return require(outsideJestVmPath);\n      }\n    }\n\n    return this.requireModule<T>(from, to, {\n      isInternalModule: true,\n      supportsDynamicImport: esmIsAvailable,\n      supportsExportNamespaceFrom: false,\n      supportsStaticESM: false,\n      supportsTopLevelAwait: false,\n    });\n  }\n\n  requireActual<T = unknown>(from: string, moduleName: string): T {\n    return this.requireModule<T>(from, moduleName, undefined, true);\n  }\n\n  requireMock<T = unknown>(from: string, moduleName: string): T {\n    const moduleID = this._resolver.getModuleID(\n      this._virtualMocks,\n      from,\n      moduleName,\n      {conditions: this.cjsConditions},\n    );\n\n    if (this._isolatedMockRegistry?.has(moduleID)) {\n      return this._isolatedMockRegistry.get(moduleID);\n    } else if (this._mockRegistry.has(moduleID)) {\n      return this._mockRegistry.get(moduleID);\n    }\n\n    const mockRegistry = this._isolatedMockRegistry || this._mockRegistry;\n\n    if (this._mockFactories.has(moduleID)) {\n      // has check above makes this ok\n      const module = this._mockFactories.get(moduleID)!();\n      mockRegistry.set(moduleID, module);\n      return module as T;\n    }\n\n    const manualMockOrStub = this._resolver.getMockModule(from, moduleName);\n\n    let modulePath =\n      this._resolver.getMockModule(from, moduleName) ||\n      this._resolveCjsModule(from, moduleName);\n\n    let isManualMock =\n      manualMockOrStub &&\n      !this._resolver.resolveStubModuleName(from, moduleName);\n    if (!isManualMock) {\n      // If the actual module file has a __mocks__ dir sitting immediately next\n      // to it, look to see if there is a manual mock for this file.\n      //\n      // subDir1/my_module.js\n      // subDir1/__mocks__/my_module.js\n      // subDir2/my_module.js\n      // subDir2/__mocks__/my_module.js\n      //\n      // Where some other module does a relative require into each of the\n      // respective subDir{1,2} directories and expects a manual mock\n      // corresponding to that particular my_module.js file.\n\n      const moduleDir = path.dirname(modulePath);\n      const moduleFileName = path.basename(modulePath);\n      const potentialManualMock = path.join(\n        moduleDir,\n        '__mocks__',\n        moduleFileName,\n      );\n      if (fs.existsSync(potentialManualMock)) {\n        isManualMock = true;\n        modulePath = potentialManualMock;\n      }\n    }\n    if (isManualMock) {\n      const localModule: InitialModule = {\n        children: [],\n        exports: {},\n        filename: modulePath,\n        id: modulePath,\n        loaded: false,\n        path: path.dirname(modulePath),\n      };\n\n      this._loadModule(\n        localModule,\n        from,\n        moduleName,\n        modulePath,\n        undefined,\n        mockRegistry,\n      );\n\n      mockRegistry.set(moduleID, localModule.exports);\n    } else {\n      // Look for a real module to generate an automock from\n      mockRegistry.set(moduleID, this._generateMock(from, moduleName));\n    }\n\n    return mockRegistry.get(moduleID);\n  }\n\n  private _loadModule(\n    localModule: InitialModule,\n    from: string,\n    moduleName: string | undefined,\n    modulePath: string,\n    options: InternalModuleOptions | undefined,\n    moduleRegistry: ModuleRegistry,\n  ) {\n    if (path.extname(modulePath) === '.json') {\n      const text = stripBOM(this.readFile(modulePath));\n\n      const transformedFile = this._scriptTransformer.transformJson(\n        modulePath,\n        this._getFullTransformationOptions(options),\n        text,\n      );\n\n      localModule.exports =\n        this._environment.global.JSON.parse(transformedFile);\n    } else if (path.extname(modulePath) === '.node') {\n      localModule.exports = require(modulePath);\n    } else {\n      // Only include the fromPath if a moduleName is given. Else treat as root.\n      const fromPath = moduleName ? from : null;\n      this._execModule(localModule, options, moduleRegistry, fromPath);\n    }\n    localModule.loaded = true;\n  }\n\n  private _getFullTransformationOptions(\n    options: InternalModuleOptions = defaultTransformOptions,\n  ): TransformationOptions {\n    return {\n      ...options,\n      ...this._coverageOptions,\n    };\n  }\n\n  requireModuleOrMock<T = unknown>(from: string, moduleName: string): T {\n    // this module is unmockable\n    if (moduleName === '@jest/globals') {\n      // @ts-expect-error: we don't care that it's not assignable to T\n      return this.getGlobalsForCjs(from);\n    }\n\n    try {\n      if (this._shouldMockCjs(from, moduleName, this._explicitShouldMock)) {\n        return this.requireMock<T>(from, moduleName);\n      } else {\n        return this.requireModule<T>(from, moduleName);\n      }\n    } catch (e) {\n      const moduleNotFound = Resolver.tryCastModuleNotFoundError(e);\n      if (moduleNotFound) {\n        if (\n          moduleNotFound.siblingWithSimilarExtensionFound === null ||\n          moduleNotFound.siblingWithSimilarExtensionFound === undefined\n        ) {\n          moduleNotFound.hint = findSiblingsWithFileExtension(\n            this._config.moduleFileExtensions,\n            from,\n            moduleNotFound.moduleName || moduleName,\n          );\n          moduleNotFound.siblingWithSimilarExtensionFound = Boolean(\n            moduleNotFound.hint,\n          );\n        }\n        moduleNotFound.buildMessage(this._config.rootDir);\n        throw moduleNotFound;\n      }\n      throw e;\n    }\n  }\n\n  isolateModules(fn: () => void): void {\n    if (this._isolatedModuleRegistry || this._isolatedMockRegistry) {\n      throw new Error(\n        'isolateModules cannot be nested inside another isolateModules.',\n      );\n    }\n    this._isolatedModuleRegistry = new Map();\n    this._isolatedMockRegistry = new Map();\n    try {\n      fn();\n    } finally {\n      // might be cleared within the callback\n      this._isolatedModuleRegistry?.clear();\n      this._isolatedMockRegistry?.clear();\n      this._isolatedModuleRegistry = null;\n      this._isolatedMockRegistry = null;\n    }\n  }\n\n  resetModules(): void {\n    this._isolatedModuleRegistry?.clear();\n    this._isolatedMockRegistry?.clear();\n    this._isolatedModuleRegistry = null;\n    this._isolatedMockRegistry = null;\n    this._mockRegistry.clear();\n    this._moduleRegistry.clear();\n    this._esmoduleRegistry.clear();\n    this._fileTransformsMutex.clear();\n    this._cjsNamedExports.clear();\n    this._moduleMockRegistry.clear();\n    this._cacheFS.clear();\n\n    if (\n      this._coverageOptions.collectCoverage &&\n      this._coverageOptions.coverageProvider === 'v8' &&\n      this._v8CoverageSources\n    ) {\n      this._v8CoverageSources = new Map([\n        ...this._v8CoverageSources,\n        ...this._fileTransforms,\n      ]);\n    }\n\n    this._fileTransforms.clear();\n\n    if (this._environment) {\n      if (this._environment.global) {\n        const envGlobal = this._environment.global;\n        (Object.keys(envGlobal) as Array<keyof typeof globalThis>).forEach(\n          key => {\n            const globalMock = envGlobal[key];\n            if (\n              ((typeof globalMock === 'object' && globalMock !== null) ||\n                typeof globalMock === 'function') &&\n              globalMock._isMockFunction === true\n            ) {\n              globalMock.mockClear();\n            }\n          },\n        );\n      }\n\n      if (this._environment.fakeTimers) {\n        this._environment.fakeTimers.clearAllTimers();\n      }\n    }\n  }\n\n  async collectV8Coverage(): Promise<void> {\n    this._v8CoverageInstrumenter = new CoverageInstrumenter();\n    this._v8CoverageSources = new Map();\n\n    await this._v8CoverageInstrumenter.startInstrumenting();\n  }\n\n  async stopCollectingV8Coverage(): Promise<void> {\n    if (!this._v8CoverageInstrumenter || !this._v8CoverageSources) {\n      throw new Error('You need to call `collectV8Coverage` first.');\n    }\n    this._v8CoverageResult =\n      await this._v8CoverageInstrumenter.stopInstrumenting();\n    this._v8CoverageSources = new Map([\n      ...this._v8CoverageSources,\n      ...this._fileTransforms,\n    ]);\n  }\n\n  getAllCoverageInfoCopy(): JestEnvironment['global']['__coverage__'] {\n    return deepCyclicCopy(this._environment.global.__coverage__);\n  }\n\n  getAllV8CoverageInfoCopy(): V8CoverageResult {\n    if (!this._v8CoverageResult || !this._v8CoverageSources) {\n      throw new Error('You need to call `stopCollectingV8Coverage` first.');\n    }\n\n    return this._v8CoverageResult\n      .filter(res => res.url.startsWith('file://'))\n      .map(res => ({...res, url: fileURLToPath(res.url)}))\n      .filter(\n        res =>\n          // TODO: will this work on windows? It might be better if `shouldInstrument` deals with it anyways\n          res.url.startsWith(this._config.rootDir) &&\n          this._v8CoverageSources!.has(res.url) &&\n          shouldInstrument(res.url, this._coverageOptions, this._config),\n      )\n      .map(result => {\n        const transformedFile = this._v8CoverageSources!.get(result.url);\n\n        return {\n          codeTransformResult: transformedFile,\n          result,\n        };\n      });\n  }\n\n  getSourceMaps(): SourceMapRegistry {\n    return this._sourceMapRegistry;\n  }\n\n  setMock(\n    from: string,\n    moduleName: string,\n    mockFactory: () => unknown,\n    options?: {virtual?: boolean},\n  ): void {\n    if (options?.virtual) {\n      const mockPath = this._resolver.getModulePath(from, moduleName);\n\n      this._virtualMocks.set(mockPath, true);\n    }\n    const moduleID = this._resolver.getModuleID(\n      this._virtualMocks,\n      from,\n      moduleName,\n      {conditions: this.cjsConditions},\n    );\n    this._explicitShouldMock.set(moduleID, true);\n    this._mockFactories.set(moduleID, mockFactory);\n  }\n\n  private setModuleMock(\n    from: string,\n    moduleName: string,\n    mockFactory: () => Promise<unknown> | unknown,\n    options?: {virtual?: boolean},\n  ): void {\n    if (options?.virtual) {\n      const mockPath = this._resolver.getModulePath(from, moduleName);\n\n      this._virtualModuleMocks.set(mockPath, true);\n    }\n    const moduleID = this._resolver.getModuleID(\n      this._virtualModuleMocks,\n      from,\n      moduleName,\n      {conditions: this.esmConditions},\n    );\n    this._explicitShouldMockModule.set(moduleID, true);\n    this._moduleMockFactories.set(moduleID, mockFactory);\n  }\n\n  restoreAllMocks(): void {\n    this._moduleMocker.restoreAllMocks();\n  }\n\n  resetAllMocks(): void {\n    this._moduleMocker.resetAllMocks();\n  }\n\n  clearAllMocks(): void {\n    this._moduleMocker.clearAllMocks();\n  }\n\n  teardown(): void {\n    this.restoreAllMocks();\n    this.resetAllMocks();\n    this.resetModules();\n\n    this._internalModuleRegistry.clear();\n    this._mainModule = null;\n    this._mockFactories.clear();\n    this._moduleMockFactories.clear();\n    this._mockMetaDataCache.clear();\n    this._shouldMockModuleCache.clear();\n    this._shouldUnmockTransitiveDependenciesCache.clear();\n    this._explicitShouldMock.clear();\n    this._explicitShouldMockModule.clear();\n    this._transitiveShouldMock.clear();\n    this._virtualMocks.clear();\n    this._virtualModuleMocks.clear();\n    this._cacheFS.clear();\n    this._unmockList = undefined;\n\n    this._sourceMapRegistry.clear();\n\n    this._fileTransforms.clear();\n    this.jestObjectCaches.clear();\n\n    this._v8CoverageSources?.clear();\n    this._v8CoverageResult = [];\n    this._v8CoverageInstrumenter = undefined;\n    this._moduleImplementation = undefined;\n\n    this.isTornDown = true;\n  }\n\n  private _resolveCjsModule(from: string, to: string | undefined) {\n    return to\n      ? this._resolver.resolveModule(from, to, {\n          conditions: this.cjsConditions,\n        })\n      : from;\n  }\n\n  private _resolveModule(from: string, to: string | undefined) {\n    return to\n      ? this._resolver.resolveModuleAsync(from, to, {\n          conditions: this.esmConditions,\n        })\n      : from;\n  }\n\n  private _requireResolve(\n    from: string,\n    moduleName?: string,\n    options: ResolveOptions = {},\n  ) {\n    if (moduleName == null) {\n      throw new Error(\n        'The first argument to require.resolve must be a string. Received null or undefined.',\n      );\n    }\n\n    if (path.isAbsolute(moduleName)) {\n      const module = this._resolver.resolveModuleFromDirIfExists(\n        moduleName,\n        moduleName,\n        {conditions: this.cjsConditions, paths: []},\n      );\n      if (module) {\n        return module;\n      }\n    } else {\n      const {paths} = options;\n      if (paths) {\n        for (const p of paths) {\n          const absolutePath = path.resolve(from, '..', p);\n          const module = this._resolver.resolveModuleFromDirIfExists(\n            absolutePath,\n            moduleName,\n            // required to also resolve files without leading './' directly in the path\n            {conditions: this.cjsConditions, paths: [absolutePath]},\n          );\n          if (module) {\n            return module;\n          }\n        }\n\n        throw new Resolver.ModuleNotFoundError(\n          `Cannot resolve module '${moduleName}' from paths ['${paths.join(\n            \"', '\",\n          )}'] from ${from}`,\n        );\n      }\n    }\n\n    try {\n      return this._resolveCjsModule(from, moduleName);\n    } catch (err) {\n      const module = this._resolver.getMockModule(from, moduleName);\n\n      if (module) {\n        return module;\n      } else {\n        throw err;\n      }\n    }\n  }\n\n  private _requireResolvePaths(from: string, moduleName?: string) {\n    if (moduleName == null) {\n      throw new Error(\n        'The first argument to require.resolve.paths must be a string. Received null or undefined.',\n      );\n    }\n    if (!moduleName.length) {\n      throw new Error(\n        'The first argument to require.resolve.paths must not be the empty string.',\n      );\n    }\n\n    if (moduleName[0] === '.') {\n      return [path.resolve(from, '..')];\n    }\n    if (this._resolver.isCoreModule(moduleName)) {\n      return null;\n    }\n    return this._resolver.getModulePaths(path.resolve(from, '..'));\n  }\n\n  private _execModule(\n    localModule: InitialModule,\n    options: InternalModuleOptions | undefined,\n    moduleRegistry: ModuleRegistry,\n    from: string | null,\n  ) {\n    if (this.isTornDown) {\n      this._logFormattedReferenceError(\n        'You are trying to `import` a file after the Jest environment has been torn down.',\n      );\n      process.exitCode = 1;\n      return;\n    }\n\n    // If the environment was disposed, prevent this module from being executed.\n    if (!this._environment.global) {\n      return;\n    }\n\n    const module = localModule as Module;\n\n    const filename = module.filename;\n    const lastExecutingModulePath = this._currentlyExecutingModulePath;\n    this._currentlyExecutingModulePath = filename;\n    const origCurrExecutingManualMock = this._isCurrentlyExecutingManualMock;\n    this._isCurrentlyExecutingManualMock = filename;\n\n    module.children = [];\n\n    Object.defineProperty(module, 'parent', {\n      enumerable: true,\n      get() {\n        const key = from || '';\n        return moduleRegistry.get(key) || null;\n      },\n    });\n\n    module.paths = this._resolver.getModulePaths(module.path);\n    Object.defineProperty(module, 'require', {\n      value: this._createRequireImplementation(module, options),\n    });\n\n    const transformedCode = this.transformFile(filename, options);\n\n    let compiledFunction: ModuleWrapper | null = null;\n\n    const script = this.createScriptFromCode(transformedCode, filename);\n\n    let runScript: RunScriptEvalResult | null = null;\n\n    const vmContext = this._environment.getVmContext();\n\n    if (vmContext) {\n      runScript = script.runInContext(vmContext, {filename});\n    }\n\n    if (runScript !== null) {\n      compiledFunction = runScript[EVAL_RESULT_VARIABLE];\n    }\n\n    if (compiledFunction === null) {\n      this._logFormattedReferenceError(\n        'You are trying to `import` a file after the Jest environment has been torn down.',\n      );\n      process.exitCode = 1;\n      return;\n    }\n\n    const jestObject = this._createJestObjectFor(filename);\n\n    this.jestObjectCaches.set(filename, jestObject);\n\n    const lastArgs: [Jest | undefined, ...Array<Global.Global>] = [\n      this._config.injectGlobals ? jestObject : undefined, // jest object\n      ...this._config.sandboxInjectedGlobals.map<Global.Global>(\n        globalVariable => {\n          if (this._environment.global[globalVariable]) {\n            return this._environment.global[globalVariable];\n          }\n\n          throw new Error(\n            `You have requested '${globalVariable}' as a global variable, but it was not present. Please check your config or your global environment.`,\n          );\n        },\n      ),\n    ];\n\n    if (!this._mainModule && filename === this._testPath) {\n      this._mainModule = module;\n    }\n\n    Object.defineProperty(module, 'main', {\n      enumerable: true,\n      value: this._mainModule,\n    });\n\n    try {\n      compiledFunction.call(\n        module.exports,\n        module, // module object\n        module.exports, // module exports\n        module.require, // require implementation\n        module.path, // __dirname\n        module.filename, // __filename\n        lastArgs[0],\n        ...lastArgs.slice(1).filter(notEmpty),\n      );\n    } catch (error: any) {\n      this.handleExecutionError(error, module);\n    }\n\n    this._isCurrentlyExecutingManualMock = origCurrExecutingManualMock;\n    this._currentlyExecutingModulePath = lastExecutingModulePath;\n  }\n\n  private transformFile(\n    filename: string,\n    options?: InternalModuleOptions,\n  ): string {\n    const source = this.readFile(filename);\n\n    if (options?.isInternalModule) {\n      return source;\n    }\n\n    let transformedFile: TransformResult | undefined =\n      this._fileTransforms.get(filename);\n\n    if (transformedFile) {\n      return transformedFile.code;\n    }\n\n    transformedFile = this._scriptTransformer.transform(\n      filename,\n      this._getFullTransformationOptions(options),\n      source,\n    );\n\n    this._fileTransforms.set(filename, {\n      ...transformedFile,\n      wrapperLength: this.constructModuleWrapperStart().length,\n    });\n\n    if (transformedFile.sourceMapPath) {\n      this._sourceMapRegistry.set(filename, transformedFile.sourceMapPath);\n    }\n    return transformedFile.code;\n  }\n\n  private async transformFileAsync(\n    filename: string,\n    options?: InternalModuleOptions,\n  ): Promise<string> {\n    const source = this.readFile(filename);\n\n    if (options?.isInternalModule) {\n      return source;\n    }\n\n    let transformedFile: TransformResult | undefined =\n      this._fileTransforms.get(filename);\n\n    if (transformedFile) {\n      return transformedFile.code;\n    }\n\n    transformedFile = await this._scriptTransformer.transformAsync(\n      filename,\n      this._getFullTransformationOptions(options),\n      source,\n    );\n\n    this._fileTransforms.set(filename, {\n      ...transformedFile,\n      wrapperLength: 0,\n    });\n\n    if (transformedFile.sourceMapPath) {\n      this._sourceMapRegistry.set(filename, transformedFile.sourceMapPath);\n    }\n    return transformedFile.code;\n  }\n\n  private createScriptFromCode(scriptSource: string, filename: string) {\n    try {\n      const scriptFilename = this._resolver.isCoreModule(filename)\n        ? `jest-nodejs-core-${filename}`\n        : filename;\n      return new Script(this.wrapCodeInModuleWrapper(scriptSource), {\n        displayErrors: true,\n        filename: scriptFilename,\n        // @ts-expect-error: Experimental ESM API\n        importModuleDynamically: async (specifier: string) => {\n          invariant(\n            runtimeSupportsVmModules,\n            'You need to run with a version of node that supports ES Modules in the VM API. See https://jestjs.io/docs/ecmascript-modules',\n          );\n\n          const context = this._environment.getVmContext?.();\n\n          invariant(context, 'Test environment has been torn down');\n\n          const module = await this.resolveModule(\n            specifier,\n            scriptFilename,\n            context,\n          );\n\n          return this.linkAndEvaluateModule(module);\n        },\n      });\n    } catch (e: any) {\n      throw handlePotentialSyntaxError(e);\n    }\n  }\n\n  private _requireCoreModule(moduleName: string, supportPrefix: boolean) {\n    const moduleWithoutNodePrefix =\n      supportPrefix && moduleName.startsWith('node:')\n        ? moduleName.slice('node:'.length)\n        : moduleName;\n\n    if (moduleWithoutNodePrefix === 'process') {\n      return this._environment.global.process;\n    }\n\n    if (moduleWithoutNodePrefix === 'module') {\n      return this._getMockedNativeModule();\n    }\n\n    return require(moduleWithoutNodePrefix);\n  }\n\n  private _importCoreModule(moduleName: string, context: VMContext) {\n    const required = this._requireCoreModule(moduleName, true);\n\n    const module = new SyntheticModule(\n      ['default', ...Object.keys(required)],\n      function () {\n        // @ts-expect-error: TS doesn't know what `this` is\n        this.setExport('default', required);\n        Object.entries(required).forEach(([key, value]) => {\n          // @ts-expect-error: TS doesn't know what `this` is\n          this.setExport(key, value);\n        });\n      },\n      // should identifier be `node://${moduleName}`?\n      {context, identifier: moduleName},\n    );\n\n    return evaluateSyntheticModule(module);\n  }\n\n  private _getMockedNativeModule(): typeof nativeModule.Module {\n    if (this._moduleImplementation) {\n      return this._moduleImplementation;\n    }\n\n    const createRequire = (modulePath: string | URL) => {\n      const filename =\n        typeof modulePath === 'string'\n          ? modulePath.startsWith('file:///')\n            ? fileURLToPath(new URL(modulePath))\n            : modulePath\n          : fileURLToPath(modulePath);\n\n      if (!path.isAbsolute(filename)) {\n        const error: NodeJS.ErrnoException = new TypeError(\n          `The argument 'filename' must be a file URL object, file URL string, or absolute path string. Received '${filename}'`,\n        );\n        error.code = 'ERR_INVALID_ARG_TYPE';\n        throw error;\n      }\n\n      return this._createRequireImplementation({\n        children: [],\n        exports: {},\n        filename,\n        id: filename,\n        loaded: false,\n        path: path.dirname(filename),\n      });\n    };\n\n    // should we implement the class ourselves?\n    class Module extends nativeModule.Module {}\n\n    Object.entries(nativeModule.Module).forEach(([key, value]) => {\n      // @ts-expect-error: no index signature\n      Module[key] = value;\n    });\n\n    Module.Module = Module;\n\n    if ('createRequire' in nativeModule) {\n      Module.createRequire = createRequire;\n    }\n    if ('createRequireFromPath' in nativeModule) {\n      Module.createRequireFromPath = function createRequireFromPath(\n        filename: string | URL,\n      ) {\n        if (typeof filename !== 'string') {\n          const error: NodeJS.ErrnoException = new TypeError(\n            `The argument 'filename' must be string. Received '${filename}'.${\n              filename instanceof URL\n                ? ' Use createRequire for URL filename.'\n                : ''\n            }`,\n          );\n          error.code = 'ERR_INVALID_ARG_TYPE';\n          throw error;\n        }\n        return createRequire(filename);\n      };\n    }\n    if ('syncBuiltinESMExports' in nativeModule) {\n      // cast since TS seems very confused about whether it exists or not\n      (Module as any).syncBuiltinESMExports =\n        // eslint-disable-next-line @typescript-eslint/no-empty-function\n        function syncBuiltinESMExports() {};\n    }\n\n    this._moduleImplementation = Module;\n\n    return Module;\n  }\n\n  private _generateMock<T>(from: string, moduleName: string) {\n    const modulePath =\n      this._resolver.resolveStubModuleName(from, moduleName) ||\n      this._resolveCjsModule(from, moduleName);\n    if (!this._mockMetaDataCache.has(modulePath)) {\n      // This allows us to handle circular dependencies while generating an\n      // automock\n\n      this._mockMetaDataCache.set(\n        modulePath,\n        this._moduleMocker.getMetadata({}) || {},\n      );\n\n      // In order to avoid it being possible for automocking to potentially\n      // cause side-effects within the module environment, we need to execute\n      // the module in isolation. This could cause issues if the module being\n      // mocked has calls into side-effectful APIs on another module.\n      const origMockRegistry = this._mockRegistry;\n      const origModuleRegistry = this._moduleRegistry;\n      this._mockRegistry = new Map();\n      this._moduleRegistry = new Map();\n\n      const moduleExports = this.requireModule(from, moduleName);\n\n      // Restore the \"real\" module/mock registries\n      this._mockRegistry = origMockRegistry;\n      this._moduleRegistry = origModuleRegistry;\n\n      const mockMetadata = this._moduleMocker.getMetadata(moduleExports);\n      if (mockMetadata == null) {\n        throw new Error(\n          `Failed to get mock metadata: ${modulePath}\\n\\n` +\n            'See: https://jestjs.io/docs/manual-mocks#content',\n        );\n      }\n      this._mockMetaDataCache.set(modulePath, mockMetadata);\n    }\n    return this._moduleMocker.generateFromMetadata<T>(\n      // added above if missing\n      this._mockMetaDataCache.get(modulePath)!,\n    );\n  }\n\n  private _shouldMockCjs(\n    from: string,\n    moduleName: string,\n    explicitShouldMock: Map<string, boolean>,\n  ): boolean {\n    const options: ResolveModuleConfig = {conditions: this.cjsConditions};\n    const moduleID = this._resolver.getModuleID(\n      this._virtualMocks,\n      from,\n      moduleName,\n      options,\n    );\n    const key = from + path.delimiter + moduleID;\n\n    if (explicitShouldMock.has(moduleID)) {\n      // guaranteed by `has` above\n      return explicitShouldMock.get(moduleID)!;\n    }\n\n    if (\n      !this._shouldAutoMock ||\n      this._resolver.isCoreModule(moduleName) ||\n      this._shouldUnmockTransitiveDependenciesCache.get(key)\n    ) {\n      return false;\n    }\n\n    if (this._shouldMockModuleCache.has(moduleID)) {\n      // guaranteed by `has` above\n      return this._shouldMockModuleCache.get(moduleID)!;\n    }\n\n    let modulePath;\n    try {\n      modulePath = this._resolveCjsModule(from, moduleName);\n    } catch (e) {\n      const manualMock = this._resolver.getMockModule(from, moduleName);\n      if (manualMock) {\n        this._shouldMockModuleCache.set(moduleID, true);\n        return true;\n      }\n      throw e;\n    }\n\n    if (this._unmockList && this._unmockList.test(modulePath)) {\n      this._shouldMockModuleCache.set(moduleID, false);\n      return false;\n    }\n\n    // transitive unmocking for package managers that store flat packages (npm3)\n    const currentModuleID = this._resolver.getModuleID(\n      this._virtualMocks,\n      from,\n      undefined,\n      options,\n    );\n    if (\n      this._transitiveShouldMock.get(currentModuleID) === false ||\n      (from.includes(NODE_MODULES) &&\n        modulePath.includes(NODE_MODULES) &&\n        ((this._unmockList && this._unmockList.test(from)) ||\n          explicitShouldMock.get(currentModuleID) === false))\n    ) {\n      this._transitiveShouldMock.set(moduleID, false);\n      this._shouldUnmockTransitiveDependenciesCache.set(key, true);\n      return false;\n    }\n    this._shouldMockModuleCache.set(moduleID, true);\n    return true;\n  }\n\n  private async _shouldMockModule(\n    from: string,\n    moduleName: string,\n    explicitShouldMock: Map<string, boolean>,\n  ): Promise<boolean> {\n    const options: ResolveModuleConfig = {conditions: this.esmConditions};\n    const moduleID = await this._resolver.getModuleIDAsync(\n      this._virtualMocks,\n      from,\n      moduleName,\n      options,\n    );\n    const key = from + path.delimiter + moduleID;\n\n    if (explicitShouldMock.has(moduleID)) {\n      // guaranteed by `has` above\n      return explicitShouldMock.get(moduleID)!;\n    }\n\n    if (\n      !this._shouldAutoMock ||\n      this._resolver.isCoreModule(moduleName) ||\n      this._shouldUnmockTransitiveDependenciesCache.get(key)\n    ) {\n      return false;\n    }\n\n    if (this._shouldMockModuleCache.has(moduleID)) {\n      // guaranteed by `has` above\n      return this._shouldMockModuleCache.get(moduleID)!;\n    }\n\n    let modulePath;\n    try {\n      modulePath = await this._resolveModule(from, moduleName);\n    } catch (e) {\n      const manualMock = await this._resolver.getMockModuleAsync(\n        from,\n        moduleName,\n      );\n      if (manualMock) {\n        this._shouldMockModuleCache.set(moduleID, true);\n        return true;\n      }\n      throw e;\n    }\n\n    if (this._unmockList && this._unmockList.test(modulePath)) {\n      this._shouldMockModuleCache.set(moduleID, false);\n      return false;\n    }\n\n    // transitive unmocking for package managers that store flat packages (npm3)\n    const currentModuleID = await this._resolver.getModuleIDAsync(\n      this._virtualMocks,\n      from,\n      undefined,\n      options,\n    );\n    if (\n      this._transitiveShouldMock.get(currentModuleID) === false ||\n      (from.includes(NODE_MODULES) &&\n        modulePath.includes(NODE_MODULES) &&\n        ((this._unmockList && this._unmockList.test(from)) ||\n          explicitShouldMock.get(currentModuleID) === false))\n    ) {\n      this._transitiveShouldMock.set(moduleID, false);\n      this._shouldUnmockTransitiveDependenciesCache.set(key, true);\n      return false;\n    }\n    this._shouldMockModuleCache.set(moduleID, true);\n    return true;\n  }\n\n  private _createRequireImplementation(\n    from: InitialModule,\n    options?: InternalModuleOptions,\n  ): NodeRequire {\n    const resolve = (moduleName: string, resolveOptions?: ResolveOptions) => {\n      const resolved = this._requireResolve(\n        from.filename,\n        moduleName,\n        resolveOptions,\n      );\n      if (\n        resolveOptions?.[JEST_RESOLVE_OUTSIDE_VM_OPTION] &&\n        options?.isInternalModule\n      ) {\n        return createOutsideJestVmPath(resolved);\n      }\n      return resolved;\n    };\n    resolve.paths = (moduleName: string) =>\n      this._requireResolvePaths(from.filename, moduleName);\n\n    const moduleRequire = (\n      options?.isInternalModule\n        ? (moduleName: string) =>\n            this.requireInternalModule(from.filename, moduleName)\n        : this.requireModuleOrMock.bind(this, from.filename)\n    ) as NodeRequire;\n    moduleRequire.extensions = Object.create(null);\n    moduleRequire.resolve = resolve;\n    moduleRequire.cache = (() => {\n      // TODO: consider warning somehow that this does nothing. We should support deletions, anyways\n      const notPermittedMethod = () => true;\n      return new Proxy<typeof moduleRequire['cache']>(Object.create(null), {\n        defineProperty: notPermittedMethod,\n        deleteProperty: notPermittedMethod,\n        get: (_target, key) =>\n          typeof key === 'string' ? this._moduleRegistry.get(key) : undefined,\n        getOwnPropertyDescriptor() {\n          return {\n            configurable: true,\n            enumerable: true,\n          };\n        },\n        has: (_target, key) =>\n          typeof key === 'string' && this._moduleRegistry.has(key),\n        ownKeys: () => Array.from(this._moduleRegistry.keys()),\n        set: notPermittedMethod,\n      });\n    })();\n\n    Object.defineProperty(moduleRequire, 'main', {\n      enumerable: true,\n      value: this._mainModule,\n    });\n\n    return moduleRequire;\n  }\n\n  private _createJestObjectFor(from: string): Jest {\n    const disableAutomock = () => {\n      this._shouldAutoMock = false;\n      return jestObject;\n    };\n    const enableAutomock = () => {\n      this._shouldAutoMock = true;\n      return jestObject;\n    };\n    const unmock = (moduleName: string) => {\n      const moduleID = this._resolver.getModuleID(\n        this._virtualMocks,\n        from,\n        moduleName,\n        {conditions: this.cjsConditions},\n      );\n      this._explicitShouldMock.set(moduleID, false);\n      return jestObject;\n    };\n    const deepUnmock = (moduleName: string) => {\n      const moduleID = this._resolver.getModuleID(\n        this._virtualMocks,\n        from,\n        moduleName,\n        {conditions: this.cjsConditions},\n      );\n      this._explicitShouldMock.set(moduleID, false);\n      this._transitiveShouldMock.set(moduleID, false);\n      return jestObject;\n    };\n    const mock: Jest['mock'] = (moduleName, mockFactory, options) => {\n      if (mockFactory !== undefined) {\n        return setMockFactory(moduleName, mockFactory, options);\n      }\n\n      const moduleID = this._resolver.getModuleID(\n        this._virtualMocks,\n        from,\n        moduleName,\n        {conditions: this.cjsConditions},\n      );\n      this._explicitShouldMock.set(moduleID, true);\n      return jestObject;\n    };\n    const setMockFactory = (\n      moduleName: string,\n      mockFactory: () => unknown,\n      options?: {virtual?: boolean},\n    ) => {\n      this.setMock(from, moduleName, mockFactory, options);\n      return jestObject;\n    };\n    const mockModule: Jest['unstable_mockModule'] = (\n      moduleName,\n      mockFactory,\n      options,\n    ) => {\n      if (typeof mockFactory !== 'function') {\n        throw new Error('`unstable_mockModule` must be passed a mock factory');\n      }\n\n      this.setModuleMock(from, moduleName, mockFactory, options);\n      return jestObject;\n    };\n    const clearAllMocks = () => {\n      this.clearAllMocks();\n      return jestObject;\n    };\n    const resetAllMocks = () => {\n      this.resetAllMocks();\n      return jestObject;\n    };\n    const restoreAllMocks = () => {\n      this.restoreAllMocks();\n      return jestObject;\n    };\n    const _getFakeTimers = () => {\n      if (\n        this.isTornDown ||\n        !(this._environment.fakeTimers || this._environment.fakeTimersModern)\n      ) {\n        this._logFormattedReferenceError(\n          'You are trying to access a property or method of the Jest environment after it has been torn down.',\n        );\n        process.exitCode = 1;\n      }\n\n      return this._fakeTimersImplementation!;\n    };\n    const useFakeTimers: Jest['useFakeTimers'] = fakeTimersConfig => {\n      fakeTimersConfig = {\n        ...this._config.fakeTimers,\n        ...fakeTimersConfig,\n      } as Config.FakeTimersConfig;\n      if (fakeTimersConfig?.legacyFakeTimers) {\n        this._fakeTimersImplementation = this._environment.fakeTimers;\n      } else {\n        this._fakeTimersImplementation = this._environment.fakeTimersModern;\n      }\n      this._fakeTimersImplementation!.useFakeTimers(fakeTimersConfig);\n      return jestObject;\n    };\n    const useRealTimers = () => {\n      _getFakeTimers().useRealTimers();\n      return jestObject;\n    };\n    const resetModules = () => {\n      this.resetModules();\n      return jestObject;\n    };\n    const isolateModules = (fn: () => void) => {\n      this.isolateModules(fn);\n      return jestObject;\n    };\n    const fn = this._moduleMocker.fn.bind(this._moduleMocker);\n    const spyOn = this._moduleMocker.spyOn.bind(this._moduleMocker);\n    const mocked =\n      this._moduleMocker.mocked?.bind(this._moduleMocker) ??\n      (() => {\n        throw new Error(\n          'Your test environment does not support `mocked`, please update it.',\n        );\n      });\n\n    const setTimeout = (timeout: number) => {\n      this._environment.global[testTimeoutSymbol] = timeout;\n      return jestObject;\n    };\n\n    const retryTimes: Jest['retryTimes'] = (numTestRetries, options) => {\n      this._environment.global[retryTimesSymbol] = numTestRetries;\n      this._environment.global[logErrorsBeforeRetrySymbol] =\n        options?.logErrorsBeforeRetry;\n\n      return jestObject;\n    };\n\n    const jestObject: Jest = {\n      advanceTimersByTime: (msToRun: number) =>\n        _getFakeTimers().advanceTimersByTime(msToRun),\n      advanceTimersToNextTimer: (steps?: number) =>\n        _getFakeTimers().advanceTimersToNextTimer(steps),\n      autoMockOff: disableAutomock,\n      autoMockOn: enableAutomock,\n      clearAllMocks,\n      clearAllTimers: () => _getFakeTimers().clearAllTimers(),\n      createMockFromModule: (moduleName: string) =>\n        this._generateMock(from, moduleName),\n      deepUnmock,\n      disableAutomock,\n      doMock: mock,\n      dontMock: unmock,\n      enableAutomock,\n      fn,\n      genMockFromModule: (moduleName: string) =>\n        this._generateMock(from, moduleName),\n      getRealSystemTime: () => {\n        const fakeTimers = _getFakeTimers();\n\n        if (fakeTimers === this._environment.fakeTimersModern) {\n          return fakeTimers.getRealSystemTime();\n        } else {\n          throw new TypeError(\n            '`jest.getRealSystemTime()` is not available when using legacy fake timers.',\n          );\n        }\n      },\n      getSeed: () => {\n        // TODO: remove this check in Jest 30\n        if (this._globalConfig?.seed === undefined) {\n          throw new Error(\n            'The seed value is not available. Likely you are using older versions of the jest dependencies.',\n          );\n        }\n        return this._globalConfig.seed;\n      },\n      getTimerCount: () => _getFakeTimers().getTimerCount(),\n      isMockFunction: this._moduleMocker.isMockFunction,\n      isolateModules,\n      mock,\n      mocked,\n      now: () => _getFakeTimers().now(),\n      requireActual: moduleName => this.requireActual(from, moduleName),\n      requireMock: moduleName => this.requireMock(from, moduleName),\n      resetAllMocks,\n      resetModules,\n      restoreAllMocks,\n      retryTimes,\n      runAllImmediates: () => {\n        const fakeTimers = _getFakeTimers();\n\n        if (fakeTimers === this._environment.fakeTimers) {\n          fakeTimers.runAllImmediates();\n        } else {\n          throw new TypeError(\n            '`jest.runAllImmediates()` is only available when using legacy fake timers.',\n          );\n        }\n      },\n      runAllTicks: () => _getFakeTimers().runAllTicks(),\n      runAllTimers: () => _getFakeTimers().runAllTimers(),\n      runOnlyPendingTimers: () => _getFakeTimers().runOnlyPendingTimers(),\n      setMock: (moduleName: string, mock: unknown) =>\n        setMockFactory(moduleName, () => mock),\n      setSystemTime: (now?: number | Date) => {\n        const fakeTimers = _getFakeTimers();\n\n        if (fakeTimers === this._environment.fakeTimersModern) {\n          fakeTimers.setSystemTime(now);\n        } else {\n          throw new TypeError(\n            '`jest.setSystemTime()` is not available when using legacy fake timers.',\n          );\n        }\n      },\n      setTimeout,\n      spyOn,\n      unmock,\n      unstable_mockModule: mockModule,\n      useFakeTimers,\n      useRealTimers,\n    };\n    return jestObject;\n  }\n\n  private _logFormattedReferenceError(errorMessage: string) {\n    const testPath = this._testPath\n      ? ` From ${slash(path.relative(this._config.rootDir, this._testPath))}.`\n      : '';\n    const originalStack = new ReferenceError(`${errorMessage}${testPath}`)\n      .stack!.split('\\n')\n      // Remove this file from the stack (jest-message-utils will keep one line)\n      .filter(line => line.indexOf(__filename) === -1)\n      .join('\\n');\n\n    const {message, stack} = separateMessageFromStack(originalStack);\n\n    console.error(\n      `\\n${message}\\n${formatStackTrace(stack, this._config, {\n        noStackTrace: false,\n      })}`,\n    );\n  }\n\n  private wrapCodeInModuleWrapper(content: string) {\n    return `${this.constructModuleWrapperStart() + content}\\n}});`;\n  }\n\n  private constructModuleWrapperStart() {\n    const args = this.constructInjectedModuleParameters();\n\n    return `({\"${EVAL_RESULT_VARIABLE}\":function(${args.join(',')}){`;\n  }\n\n  private constructInjectedModuleParameters(): Array<string> {\n    return [\n      'module',\n      'exports',\n      'require',\n      '__dirname',\n      '__filename',\n      this._config.injectGlobals ? 'jest' : undefined,\n      ...this._config.sandboxInjectedGlobals,\n    ].filter(notEmpty);\n  }\n\n  private handleExecutionError(e: Error, module: Module): never {\n    const moduleNotFoundError = Resolver.tryCastModuleNotFoundError(e);\n    if (moduleNotFoundError) {\n      if (!moduleNotFoundError.requireStack) {\n        moduleNotFoundError.requireStack = [module.filename || module.id];\n\n        for (let cursor = module.parent; cursor; cursor = cursor.parent) {\n          moduleNotFoundError.requireStack.push(cursor.filename || cursor.id);\n        }\n\n        moduleNotFoundError.buildMessage(this._config.rootDir);\n      }\n      throw moduleNotFoundError;\n    }\n\n    throw e;\n  }\n\n  private getGlobalsForCjs(from: string): JestGlobalsWithJest {\n    const jest = this.jestObjectCaches.get(from);\n\n    invariant(jest, 'There should always be a Jest object already');\n\n    return {...this.getGlobalsFromEnvironment(), jest};\n  }\n\n  private getGlobalsForEsm(\n    from: string,\n    context: VMContext,\n  ): Promise<VMModule> {\n    let jest = this.jestObjectCaches.get(from);\n\n    if (!jest) {\n      jest = this._createJestObjectFor(from);\n\n      this.jestObjectCaches.set(from, jest);\n    }\n\n    const globals: JestGlobalsWithJest = {\n      ...this.getGlobalsFromEnvironment(),\n      jest,\n    };\n\n    const module = new SyntheticModule(\n      Object.keys(globals),\n      function () {\n        Object.entries(globals).forEach(([key, value]) => {\n          // @ts-expect-error: TS doesn't know what `this` is\n          this.setExport(key, value);\n        });\n      },\n      {context, identifier: '@jest/globals'},\n    );\n\n    return evaluateSyntheticModule(module);\n  }\n\n  private getGlobalsFromEnvironment(): JestGlobals {\n    if (this.jestGlobals) {\n      return {...this.jestGlobals};\n    }\n\n    return {\n      afterAll: this._environment.global.afterAll,\n      afterEach: this._environment.global.afterEach,\n      beforeAll: this._environment.global.beforeAll,\n      beforeEach: this._environment.global.beforeEach,\n      describe: this._environment.global.describe,\n      expect: this._environment.global.expect as typeof expect,\n      fdescribe: this._environment.global.fdescribe,\n      fit: this._environment.global.fit,\n      it: this._environment.global.it,\n      test: this._environment.global.test,\n      xdescribe: this._environment.global.xdescribe,\n      xit: this._environment.global.xit,\n      xtest: this._environment.global.xtest,\n    };\n  }\n\n  private readFile(filename: string): string {\n    let source = this._cacheFS.get(filename);\n\n    if (!source) {\n      source = fs.readFileSync(filename, 'utf8');\n\n      this._cacheFS.set(filename, source);\n    }\n\n    return source;\n  }\n\n  setGlobalsForRuntime(globals: JestGlobals): void {\n    this.jestGlobals = globals;\n  }\n}\n\nfunction invariant(condition: unknown, message?: string): asserts condition {\n  if (!condition) {\n    throw new Error(message);\n  }\n}\n\nfunction notEmpty<T>(value: T | null | undefined): value is T {\n  return value !== null && value !== undefined;\n}\n\nasync function evaluateSyntheticModule(module: SyntheticModule) {\n  await module.link(() => {\n    throw new Error('This should never happen');\n  });\n\n  await module.evaluate();\n\n  return module;\n}\n",{"ruleId":"190","severity":2,"message":"191","line":26,"column":5,"nodeType":"192","messageId":"193","endLine":26,"endColumn":45},{"ruleId":"194","severity":2,"message":"195","line":112,"column":14,"nodeType":"196","messageId":"197","endLine":112,"endColumn":33},{"ruleId":"198","severity":2,"message":"199","line":262,"column":38,"nodeType":"196","messageId":"200","endLine":262,"endColumn":72,"suggestions":"201"},{"ruleId":"190","severity":2,"message":"191","line":266,"column":5,"nodeType":"192","messageId":"193","endLine":266,"endColumn":53},{"ruleId":"198","severity":2,"message":"199","line":340,"column":22,"nodeType":"196","messageId":"200","endLine":340,"endColumn":35,"suggestions":"202"},{"ruleId":"198","severity":2,"message":"203","line":361,"column":19,"nodeType":"204","messageId":"205","endLine":361,"endColumn":38,"suggestions":"206"},{"ruleId":"207","severity":2,"message":"208","line":361,"column":39,"nodeType":"209","messageId":"210","endLine":361,"endColumn":41,"suggestions":"211"},{"ruleId":"207","severity":2,"message":"208","line":363,"column":41,"nodeType":"209","messageId":"210","endLine":363,"endColumn":43,"suggestions":"212"},{"ruleId":"198","severity":2,"message":"199","line":365,"column":23,"nodeType":"196","messageId":"200","endLine":365,"endColumn":50,"suggestions":"213"},{"ruleId":"207","severity":2,"message":"208","line":365,"column":51,"nodeType":"209","messageId":"210","endLine":365,"endColumn":53,"suggestions":"214"},{"ruleId":"215","severity":2,"message":"216","line":391,"column":3,"nodeType":"217","messageId":"218","endLine":391,"endColumn":22},{"ruleId":"198","severity":2,"message":"219","line":440,"column":9,"nodeType":"220","messageId":"221","endLine":440,"endColumn":26},{"ruleId":"190","severity":2,"message":"191","line":462,"column":15,"nodeType":"222","messageId":"193","endLine":494,"endColumn":11},{"ruleId":"223","severity":2,"message":"224","line":462,"column":24,"nodeType":"225","messageId":"226","endLine":494,"endColumn":11},{"ruleId":"227","severity":2,"message":"228","line":475,"column":15,"nodeType":"196","messageId":"229","endLine":475,"endColumn":43},{"ruleId":"194","severity":2,"message":"230","line":475,"column":15,"nodeType":"196","messageId":"197","endLine":475,"endColumn":43},{"ruleId":"227","severity":2,"message":"231","line":476,"column":15,"nodeType":"196","messageId":"229","endLine":476,"endColumn":40},{"ruleId":"194","severity":2,"message":"232","line":476,"column":15,"nodeType":"196","messageId":"197","endLine":476,"endColumn":40},{"ruleId":"190","severity":2,"message":"191","line":510,"column":11,"nodeType":"222","messageId":"193","endLine":510,"endColumn":56},{"ruleId":"233","severity":2,"message":"234","line":517,"column":5,"nodeType":"235","messageId":"236","endLine":517,"endColumn":19},{"ruleId":"190","severity":2,"message":"191","line":535,"column":13,"nodeType":"222","messageId":"193","endLine":535,"endColumn":68},{"ruleId":"198","severity":2,"message":"237","line":537,"column":11,"nodeType":"238","messageId":"239","endLine":537,"endColumn":20,"suggestions":"240"},{"ruleId":"233","severity":2,"message":"234","line":538,"column":9,"nodeType":"235","messageId":"236","endLine":538,"endColumn":26},{"ruleId":"233","severity":2,"message":"241","line":543,"column":7,"nodeType":"235","messageId":"242","endLine":543,"endColumn":22},{"ruleId":"190","severity":2,"message":"191","line":557,"column":13,"nodeType":"222","messageId":"193","endLine":557,"endColumn":62},{"ruleId":"198","severity":2,"message":"237","line":559,"column":11,"nodeType":"238","messageId":"239","endLine":559,"endColumn":20,"suggestions":"243"},{"ruleId":"233","severity":2,"message":"234","line":560,"column":9,"nodeType":"235","messageId":"236","endLine":560,"endColumn":26},{"ruleId":"190","severity":2,"message":"191","line":586,"column":9,"nodeType":"192","messageId":"193","endLine":594,"endColumn":10},{"ruleId":"223","severity":2,"message":"224","line":586,"column":18,"nodeType":"225","messageId":"226","endLine":594,"endColumn":10},{"ruleId":"190","severity":2,"message":"191","line":589,"column":19,"nodeType":"222","messageId":"193","endLine":589,"endColumn":41},{"ruleId":"194","severity":2,"message":"244","line":591,"column":13,"nodeType":"196","messageId":"197","endLine":591,"endColumn":27},{"ruleId":"223","severity":2,"message":"245","line":591,"column":13,"nodeType":"196","messageId":"246","endLine":591,"endColumn":27},{"ruleId":"190","severity":2,"message":"191","line":596,"column":9,"nodeType":"192","messageId":"193","endLine":619,"endColumn":11},{"ruleId":"223","severity":2,"message":"224","line":596,"column":18,"nodeType":"225","messageId":"226","endLine":619,"endColumn":11},{"ruleId":"227","severity":2,"message":"228","line":609,"column":15,"nodeType":"196","messageId":"229","endLine":609,"endColumn":43},{"ruleId":"194","severity":2,"message":"230","line":609,"column":15,"nodeType":"196","messageId":"197","endLine":609,"endColumn":43},{"ruleId":"227","severity":2,"message":"231","line":610,"column":15,"nodeType":"196","messageId":"229","endLine":610,"endColumn":40},{"ruleId":"194","severity":2,"message":"232","line":610,"column":15,"nodeType":"196","messageId":"197","endLine":610,"endColumn":40},{"ruleId":"233","severity":2,"message":"234","line":623,"column":7,"nodeType":"235","messageId":"236","endLine":623,"endColumn":21},{"ruleId":"233","severity":2,"message":"241","line":648,"column":7,"nodeType":"235","messageId":"242","endLine":648,"endColumn":50},{"ruleId":"233","severity":2,"message":"247","line":651,"column":5,"nodeType":"235","messageId":"242","endLine":651,"endColumn":72},{"ruleId":"194","severity":2,"message":"248","line":665,"column":9,"nodeType":"196","messageId":"197","endLine":665,"endColumn":22},{"ruleId":"227","severity":2,"message":"249","line":670,"column":9,"nodeType":"250","messageId":"229","endLine":676,"endColumn":10},{"ruleId":"194","severity":2,"message":"251","line":670,"column":9,"nodeType":"196","messageId":"197","endLine":670,"endColumn":20},{"ruleId":"223","severity":2,"message":"245","line":670,"column":9,"nodeType":"196","messageId":"246","endLine":670,"endColumn":20},{"ruleId":"227","severity":2,"message":"228","line":673,"column":13,"nodeType":"196","messageId":"229","endLine":673,"endColumn":41},{"ruleId":"194","severity":2,"message":"230","line":673,"column":13,"nodeType":"196","messageId":"197","endLine":673,"endColumn":41},{"ruleId":"227","severity":2,"message":"231","line":674,"column":13,"nodeType":"196","messageId":"229","endLine":674,"endColumn":38},{"ruleId":"194","severity":2,"message":"232","line":674,"column":13,"nodeType":"196","messageId":"197","endLine":674,"endColumn":38},{"ruleId":"194","severity":2,"message":"248","line":682,"column":9,"nodeType":"196","messageId":"197","endLine":682,"endColumn":22},{"ruleId":"194","severity":2,"message":"252","line":683,"column":13,"nodeType":"196","messageId":"197","endLine":683,"endColumn":28},{"ruleId":"223","severity":2,"message":"245","line":683,"column":13,"nodeType":"196","messageId":"246","endLine":683,"endColumn":28},{"ruleId":"233","severity":2,"message":"234","line":686,"column":5,"nodeType":"235","messageId":"236","endLine":686,"endColumn":19},{"ruleId":"190","severity":2,"message":"191","line":702,"column":11,"nodeType":"222","messageId":"193","endLine":702,"endColumn":63},{"ruleId":"233","severity":2,"message":"253","line":704,"column":5,"nodeType":"235","messageId":"242","endLine":704,"endColumn":47},{"ruleId":"190","severity":2,"message":"191","line":721,"column":11,"nodeType":"222","messageId":"193","endLine":732,"endColumn":6},{"ruleId":"223","severity":2,"message":"224","line":721,"column":20,"nodeType":"225","messageId":"226","endLine":732,"endColumn":6},{"ruleId":"194","severity":2,"message":"244","line":726,"column":11,"nodeType":"196","messageId":"197","endLine":726,"endColumn":25},{"ruleId":"223","severity":2,"message":"245","line":726,"column":11,"nodeType":"196","messageId":"246","endLine":726,"endColumn":25},{"ruleId":"194","severity":2,"message":"244","line":729,"column":9,"nodeType":"196","messageId":"197","endLine":729,"endColumn":23},{"ruleId":"223","severity":2,"message":"245","line":729,"column":9,"nodeType":"196","messageId":"246","endLine":729,"endColumn":23},{"ruleId":"233","severity":2,"message":"234","line":750,"column":7,"nodeType":"235","messageId":"236","endLine":750,"endColumn":53},{"ruleId":"190","severity":2,"message":"191","line":759,"column":13,"nodeType":"222","messageId":"193","endLine":768,"endColumn":8},{"ruleId":"223","severity":2,"message":"224","line":759,"column":22,"nodeType":"225","messageId":"226","endLine":768,"endColumn":8},{"ruleId":"227","severity":2,"message":"254","line":760,"column":21,"nodeType":"238","messageId":"229","endLine":760,"endColumn":35},{"ruleId":"227","severity":2,"message":"255","line":762,"column":26,"nodeType":"238","messageId":"229","endLine":762,"endColumn":40},{"ruleId":"194","severity":2,"message":"244","line":764,"column":13,"nodeType":"196","messageId":"197","endLine":764,"endColumn":27},{"ruleId":"223","severity":2,"message":"245","line":764,"column":13,"nodeType":"196","messageId":"246","endLine":764,"endColumn":27},{"ruleId":"233","severity":2,"message":"247","line":772,"column":7,"nodeType":"235","messageId":"242","endLine":772,"endColumn":46},{"ruleId":"256","severity":2,"message":"257","line":797,"column":23,"nodeType":"196","messageId":"258","endLine":797,"endColumn":39},{"ruleId":"198","severity":2,"message":"259","line":822,"column":28,"nodeType":"238","messageId":"260","endLine":822,"endColumn":38,"suggestions":"261"},{"ruleId":"198","severity":2,"message":"259","line":824,"column":7,"nodeType":"238","messageId":"260","endLine":824,"endColumn":17,"suggestions":"262"},{"ruleId":"198","severity":2,"message":"199","line":826,"column":8,"nodeType":"204","messageId":"200","endLine":826,"endColumn":33,"suggestions":"263"},{"ruleId":"198","severity":2,"message":"259","line":828,"column":8,"nodeType":"238","messageId":"260","endLine":828,"endColumn":22,"suggestions":"264"},{"ruleId":"198","severity":2,"message":"259","line":829,"column":7,"nodeType":"238","messageId":"260","endLine":829,"endColumn":17,"suggestions":"265"},{"ruleId":"198","severity":2,"message":"259","line":836,"column":9,"nodeType":"238","messageId":"260","endLine":836,"endColumn":19,"suggestions":"266"},{"ruleId":"233","severity":2,"message":"234","line":837,"column":7,"nodeType":"235","messageId":"236","endLine":840,"endColumn":9},{"ruleId":"198","severity":2,"message":"259","line":843,"column":10,"nodeType":"238","messageId":"260","endLine":843,"endColumn":20,"suggestions":"267"},{"ruleId":"233","severity":2,"message":"234","line":870,"column":7,"nodeType":"235","messageId":"236","endLine":870,"endColumn":29},{"ruleId":"233","severity":2,"message":"234","line":900,"column":5,"nodeType":"235","messageId":"236","endLine":900,"endColumn":32},{"ruleId":"198","severity":2,"message":"259","line":904,"column":9,"nodeType":"238","messageId":"260","endLine":904,"endColumn":11,"suggestions":"268"},{"ruleId":"233","severity":2,"message":"234","line":909,"column":9,"nodeType":"235","messageId":"236","endLine":909,"endColumn":28},{"ruleId":"198","severity":2,"message":"259","line":912,"column":11,"nodeType":"238","messageId":"260","endLine":912,"endColumn":28,"suggestions":"269"},{"ruleId":"233","severity":2,"message":"234","line":913,"column":9,"nodeType":"235","messageId":"236","endLine":913,"endColumn":43},{"ruleId":"198","severity":2,"message":"199","line":938,"column":9,"nodeType":"204","messageId":"200","endLine":938,"endColumn":50,"suggestions":"270"},{"ruleId":"233","severity":2,"message":"234","line":939,"column":7,"nodeType":"235","messageId":"236","endLine":939,"endColumn":55},{"ruleId":"233","severity":2,"message":"234","line":941,"column":7,"nodeType":"235","messageId":"236","endLine":941,"endColumn":47},{"ruleId":"207","severity":2,"message":"208","line":944,"column":53,"nodeType":"209","messageId":"210","endLine":944,"endColumn":55,"suggestions":"271"},{"ruleId":"198","severity":2,"message":"259","line":956,"column":7,"nodeType":"250","messageId":"260","endLine":956,"endColumn":53,"suggestions":"272"},{"ruleId":"207","severity":2,"message":"208","line":956,"column":54,"nodeType":"209","messageId":"210","endLine":956,"endColumn":56,"suggestions":"273"},{"ruleId":"198","severity":2,"message":"259","line":960,"column":7,"nodeType":"238","messageId":"260","endLine":960,"endColumn":23,"suggestions":"274"},{"ruleId":"198","severity":2,"message":"259","line":961,"column":8,"nodeType":"250","messageId":"260","endLine":961,"endColumn":62,"suggestions":"275"},{"ruleId":"198","severity":2,"message":"276","line":962,"column":10,"nodeType":"238","messageId":"277","endLine":962,"endColumn":22},{"ruleId":"198","severity":2,"message":"276","line":987,"column":9,"nodeType":"238","messageId":"277","endLine":987,"endColumn":21},{"ruleId":"227","severity":2,"message":"278","line":1003,"column":9,"nodeType":"238","messageId":"229","endLine":1003,"endColumn":21},{"ruleId":"233","severity":2,"message":"234","line":1012,"column":5,"nodeType":"235","messageId":"236","endLine":1012,"endColumn":39},{"ruleId":"190","severity":2,"message":"191","line":1032,"column":7,"nodeType":"192","messageId":"193","endLine":1033,"endColumn":61},{"ruleId":"190","severity":2,"message":"191","line":1035,"column":7,"nodeType":"192","messageId":"193","endLine":1035,"endColumn":48},{"ruleId":"198","severity":2,"message":"259","line":1038,"column":24,"nodeType":"238","messageId":"260","endLine":1038,"endColumn":34,"suggestions":"279"},{"ruleId":"198","severity":2,"message":"259","line":1076,"column":13,"nodeType":"196","messageId":"260","endLine":1076,"endColumn":38,"suggestions":"280"},{"ruleId":"207","severity":2,"message":"208","line":1076,"column":39,"nodeType":"209","messageId":"210","endLine":1076,"endColumn":41,"suggestions":"281"},{"ruleId":"198","severity":2,"message":"219","line":1134,"column":9,"nodeType":"196","messageId":"221","endLine":1134,"endColumn":26},{"ruleId":"198","severity":2,"message":"219","line":1135,"column":11,"nodeType":"196","messageId":"221","endLine":1135,"endColumn":35},{"ruleId":"190","severity":2,"message":"191","line":1139,"column":19,"nodeType":"222","messageId":"193","endLine":1139,"endColumn":46},{"ruleId":"194","severity":2,"message":"282","line":1143,"column":15,"nodeType":"196","messageId":"197","endLine":1143,"endColumn":41},{"ruleId":"194","severity":2,"message":"283","line":1145,"column":15,"nodeType":"196","messageId":"197","endLine":1145,"endColumn":35},{"ruleId":"223","severity":2,"message":"245","line":1145,"column":15,"nodeType":"196","messageId":"246","endLine":1145,"endColumn":35},{"ruleId":"198","severity":2,"message":"199","line":1215,"column":9,"nodeType":"204","messageId":"200","endLine":1215,"endColumn":25,"suggestions":"284"},{"ruleId":"198","severity":2,"message":"199","line":1236,"column":9,"nodeType":"204","messageId":"200","endLine":1236,"endColumn":25,"suggestions":"285"},{"ruleId":"198","severity":2,"message":"259","line":1297,"column":12,"nodeType":"238","messageId":"260","endLine":1297,"endColumn":14,"suggestions":"286"},{"ruleId":"198","severity":2,"message":"259","line":1305,"column":12,"nodeType":"238","messageId":"260","endLine":1305,"endColumn":14,"suggestions":"287"},{"ruleId":"198","severity":2,"message":"259","line":1329,"column":11,"nodeType":"238","messageId":"260","endLine":1329,"endColumn":17,"suggestions":"288"},{"ruleId":"198","severity":2,"message":"259","line":1343,"column":15,"nodeType":"238","messageId":"260","endLine":1343,"endColumn":21,"suggestions":"289"},{"ruleId":"198","severity":2,"message":"259","line":1361,"column":11,"nodeType":"238","messageId":"260","endLine":1361,"endColumn":17,"suggestions":"290"},{"ruleId":"198","severity":2,"message":"219","line":1405,"column":10,"nodeType":"196","messageId":"221","endLine":1405,"endColumn":34},{"ruleId":"198","severity":2,"message":"259","line":1422,"column":21,"nodeType":"238","messageId":"260","endLine":1422,"endColumn":25,"suggestions":"291"},{"ruleId":"207","severity":2,"message":"208","line":1422,"column":26,"nodeType":"209","messageId":"210","endLine":1422,"endColumn":28,"suggestions":"292"},{"ruleId":"207","severity":2,"message":"208","line":1423,"column":40,"nodeType":"209","messageId":"210","endLine":1423,"endColumn":42,"suggestions":"293"},{"ruleId":"190","severity":2,"message":"191","line":1443,"column":7,"nodeType":"192","messageId":"193","endLine":1443,"endColumn":61},{"ruleId":"198","severity":2,"message":"237","line":1466,"column":15,"nodeType":"196","messageId":"239","endLine":1466,"endColumn":55,"suggestions":"294"},{"ruleId":"233","severity":2,"message":"234","line":1467,"column":13,"nodeType":"235","messageId":"236","endLine":1467,"endColumn":61},{"ruleId":"227","severity":2,"message":"295","line":1498,"column":33,"nodeType":"238","messageId":"229","endLine":1498,"endColumn":38},{"ruleId":"198","severity":2,"message":"199","line":1511,"column":9,"nodeType":"204","messageId":"200","endLine":1511,"endColumn":34,"suggestions":"296"},{"ruleId":"198","severity":2,"message":"259","line":1533,"column":9,"nodeType":"196","messageId":"260","endLine":1533,"endColumn":38,"suggestions":"297"},{"ruleId":"198","severity":2,"message":"199","line":1545,"column":9,"nodeType":"204","messageId":"200","endLine":1545,"endColumn":34,"suggestions":"298"},{"ruleId":"198","severity":2,"message":"259","line":1567,"column":9,"nodeType":"196","messageId":"260","endLine":1567,"endColumn":38,"suggestions":"299"},{"ruleId":"227","severity":2,"message":"300","line":1602,"column":40,"nodeType":"238","messageId":"229","endLine":1602,"endColumn":41},{"ruleId":"233","severity":2,"message":"234","line":1620,"column":5,"nodeType":"235","messageId":"236","endLine":1620,"endColumn":45},{"ruleId":"190","severity":2,"message":"191","line":1624,"column":11,"nodeType":"222","messageId":"193","endLine":1624,"endColumn":63},{"ruleId":"190","severity":2,"message":"191","line":1626,"column":11,"nodeType":"222","messageId":"193","endLine":1638,"endColumn":6},{"ruleId":"223","severity":2,"message":"224","line":1626,"column":20,"nodeType":"225","messageId":"226","endLine":1638,"endColumn":6},{"ruleId":"227","severity":2,"message":"254","line":1627,"column":34,"nodeType":"238","messageId":"229","endLine":1627,"endColumn":42},{"ruleId":"194","severity":2,"message":"244","line":1630,"column":9,"nodeType":"196","messageId":"197","endLine":1630,"endColumn":23},{"ruleId":"223","severity":2,"message":"245","line":1630,"column":9,"nodeType":"196","messageId":"246","endLine":1630,"endColumn":23},{"ruleId":"227","severity":2,"message":"255","line":1631,"column":24,"nodeType":"238","messageId":"229","endLine":1631,"endColumn":32},{"ruleId":"194","severity":2,"message":"244","line":1633,"column":11,"nodeType":"196","messageId":"197","endLine":1633,"endColumn":25},{"ruleId":"223","severity":2,"message":"245","line":1633,"column":11,"nodeType":"196","messageId":"246","endLine":1633,"endColumn":25},{"ruleId":"190","severity":2,"message":"191","line":1679,"column":7,"nodeType":"192","messageId":"193","endLine":1679,"endColumn":26},{"ruleId":"301","severity":2,"message":"302","line":1693,"column":66,"nodeType":"238","messageId":"303","endLine":1693,"endColumn":74},{"ruleId":"194","severity":2,"message":"304","line":1707,"column":7,"nodeType":"196","messageId":"197","endLine":1707,"endColumn":44},{"ruleId":"198","severity":2,"message":"259","line":1719,"column":7,"nodeType":"250","messageId":"260","endLine":1719,"endColumn":61,"suggestions":"305"},{"ruleId":"207","severity":2,"message":"208","line":1719,"column":62,"nodeType":"209","messageId":"210","endLine":1719,"endColumn":64,"suggestions":"306"},{"ruleId":"207","severity":2,"message":"208","line":1727,"column":44,"nodeType":"209","messageId":"210","endLine":1727,"endColumn":46,"suggestions":"307"},{"ruleId":"198","severity":2,"message":"199","line":1782,"column":7,"nodeType":"250","messageId":"200","endLine":1782,"endColumn":61,"suggestions":"308"},{"ruleId":"198","severity":2,"message":"259","line":1797,"column":11,"nodeType":"238","messageId":"260","endLine":1797,"endColumn":21,"suggestions":"309"},{"ruleId":"198","severity":2,"message":"199","line":1853,"column":7,"nodeType":"250","messageId":"200","endLine":1853,"endColumn":61,"suggestions":"310"},{"ruleId":"198","severity":2,"message":"259","line":1871,"column":11,"nodeType":"238","messageId":"260","endLine":1871,"endColumn":21,"suggestions":"311"},{"ruleId":"198","severity":2,"message":"199","line":1917,"column":9,"nodeType":"204","messageId":"200","endLine":1917,"endColumn":34,"suggestions":"312"},{"ruleId":"198","severity":2,"message":"199","line":1927,"column":7,"nodeType":"204","messageId":"200","endLine":1927,"endColumn":32,"suggestions":"313"},{"ruleId":"233","severity":2,"message":"234","line":1929,"column":13,"nodeType":"250","messageId":"236","endLine":1929,"endColumn":66},{"ruleId":"190","severity":2,"message":"191","line":1932,"column":5,"nodeType":"192","messageId":"193","endLine":1932,"endColumn":51},{"ruleId":"227","severity":2,"message":"314","line":1937,"column":55,"nodeType":"250","messageId":"229","endLine":1937,"endColumn":74},{"ruleId":"198","severity":2,"message":"199","line":2057,"column":11,"nodeType":"204","messageId":"200","endLine":2057,"endColumn":45,"suggestions":"315"},{"ruleId":"256","severity":2,"message":"257","line":2140,"column":23,"nodeType":"196","messageId":"258","endLine":2140,"endColumn":56},{"ruleId":"190","severity":2,"message":"191","line":2272,"column":11,"nodeType":"222","messageId":"193","endLine":2281,"endColumn":6},{"ruleId":"223","severity":2,"message":"224","line":2272,"column":20,"nodeType":"225","messageId":"226","endLine":2281,"endColumn":6},{"ruleId":"194","severity":2,"message":"244","line":2277,"column":11,"nodeType":"196","messageId":"197","endLine":2277,"endColumn":25},{"ruleId":"223","severity":2,"message":"245","line":2277,"column":11,"nodeType":"196","messageId":"246","endLine":2277,"endColumn":25},{"ruleId":"198","severity":2,"message":"259","line":2311,"column":10,"nodeType":"238","messageId":"260","endLine":2311,"endColumn":16,"suggestions":"316"},{"ruleId":"198","severity":2,"message":"237","line":2326,"column":8,"nodeType":"238","messageId":"239","endLine":2326,"endColumn":17,"suggestions":"317"},{"ruleId":"194","severity":2,"message":"251","line":2336,"column":9,"nodeType":"196","messageId":"197","endLine":2336,"endColumn":20},{"ruleId":"223","severity":2,"message":"245","line":2336,"column":9,"nodeType":"196","messageId":"246","endLine":2336,"endColumn":20},{"ruleId":"194","severity":2,"message":"252","line":2340,"column":9,"nodeType":"196","messageId":"197","endLine":2340,"endColumn":24},{"ruleId":"223","severity":2,"message":"245","line":2340,"column":9,"nodeType":"196","messageId":"246","endLine":2340,"endColumn":24},{"ruleId":"233","severity":2,"message":"234","line":2342,"column":3,"nodeType":"235","messageId":"236","endLine":2342,"endColumn":17},{"ruleId":"318","severity":2,"message":"319","line":1709,"column":42,"nodeType":"217","messageId":"320","endLine":1709,"endColumn":44,"suppressions":"321"},"@typescript-eslint/no-unsafe-assignment","Unsafe assignment of an `any` value.","AssignmentExpression","anyAssignment","@typescript-eslint/no-unsafe-member-access","Unsafe member access .foo on an `any` value.","MemberExpression","unsafeMemberExpression","@typescript-eslint/strict-boolean-expressions","Unexpected nullable boolean value in conditional. Please handle the nullish case explicitly.","conditionErrorNullableBoolean",["322","323"],["324","325"],"Unexpected nullable number value in conditional. Please handle the nullish/zero/NaN cases explicitly.","ChainExpression","conditionErrorNullableNumber",["326","327","328"],"@typescript-eslint/prefer-nullish-coalescing","Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.","Punctuator","preferNullishOverOr",["329"],["330"],["331","332"],["333"],"@typescript-eslint/require-await","Static async method 'runCLI' has no 'await' expression.","FunctionExpression","missingAwait","Unexpected object value in conditional. The condition is always true.","TSNonNullExpression","conditionErrorObject","VariableDeclarator","@typescript-eslint/no-unsafe-call","Unsafe construction of an any type value.","NewExpression","unsafeNew","@typescript-eslint/no-unsafe-argument","Unsafe argument of type `any` assigned to a parameter of type `string`.","unsafeArgument","Unsafe member access .identifier on an `any` value.","Unsafe argument of type `any` assigned to a parameter of type `Context`.","Unsafe member access .context on an `any` value.","@typescript-eslint/no-unsafe-return","Unsafe return of an `any` typed value.","ReturnStatement","unsafeReturn","Unexpected any value in conditional. An explicit comparison or type cast is required.","Identifier","conditionErrorAny",["334"],"Unsafe return of type `Promise<VMModule>` from function with return type `Promise<T>`.","unsafeReturnAssignment",["335"],"Unsafe member access .setExport on an `any` value.","Unsafe call of an `any` typed value.","unsafeCall","Unsafe return of type `Promise<SyntheticModule>` from function with return type `Promise<T>`.","Unsafe member access .status on an `any` value.","Unsafe argument of type `any` assigned to a parameter of type `Promise<unknown>`.","CallExpression","Unsafe member access .link on an `any` value.","Unsafe member access .evaluate on an `any` value.","Unsafe return of type `Promise<any>` from function with return type `Promise<void>`.","Unsafe argument of type `any` assigned to a parameter of type `{}`.","Unsafe argument of type `any` assigned to a parameter of type `{ [s: string]: unknown; } | ArrayLike<unknown>`.","@typescript-eslint/unbound-method","Avoid referencing unbound methods which may cause unintentional scoping of `this`.\nIf your function does not access `this`, you can annotate it with `this: void`, or consider using an arrow function instead.","unboundWithoutThisAnnotation","Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.","conditionErrorNullableString",["336","337","338"],["339","340","341"],["342","343"],["344","345","346"],["347","348","349"],["350","351","352"],["353","354","355"],["356","357","358"],["359","360","361"],["362","363"],["364"],["365","366","367"],["368"],["369","370","371"],["372","373","374"],"Unexpected value in conditional. A boolean expression is required.","conditionErrorOther","Unsafe argument of type `Map<string, any>` assigned to a parameter of type `ModuleRegistry`.",["375","376","377"],["378","379","380"],["381"],"Unsafe member access ._isMockFunction on an `any` value.","Unsafe member access .mockClear on an `any` value.",["382","383"],["384","385"],["386","387","388"],["389","390","391"],["392","393","394"],["395","396","397"],["398","399","400"],["401","402","403"],["404"],["405"],["406"],"Unsafe argument of type `any` assigned to a parameter of type `Error`.",["407","408"],["409","410","411"],["412","413"],["414","415","416"],"Unsafe argument of type `any` assigned to a parameter of type `ErrorWithCodeFrame`.","@typescript-eslint/restrict-template-expressions","Invalid type \"URL\" of template literal expression.","invalidType","Unsafe member access .syncBuiltinESMExports on an `any` value.",["417","418","419"],["420"],["421"],["422","423"],["424","425","426"],["427","428"],["429","430","431"],["432","433"],["434","435"],"Unsafe argument of type `any` assigned to a parameter of type `Dict<NodeModule>`.",["436","437"],["438","439","440"],["441"],"@typescript-eslint/no-empty-function","Unexpected empty function 'syncBuiltinESMExports'.","unexpected",["442"],{"messageId":"443","fix":"444","desc":"445"},{"messageId":"446","fix":"447","desc":"448"},{"messageId":"443","fix":"449","desc":"445"},{"messageId":"446","fix":"450","desc":"448"},{"messageId":"451","fix":"452","desc":"453"},{"messageId":"454","fix":"455","desc":"456"},{"messageId":"457","fix":"458","desc":"459"},{"messageId":"460","fix":"461","desc":"462"},{"messageId":"460","fix":"463","desc":"462"},{"messageId":"443","fix":"464","desc":"445"},{"messageId":"446","fix":"465","desc":"448"},{"messageId":"460","fix":"466","desc":"462"},{"messageId":"457","fix":"467","desc":"459"},{"messageId":"457","fix":"468","desc":"459"},{"messageId":"451","fix":"469","desc":"453"},{"messageId":"470","fix":"471","desc":"472"},{"messageId":"457","fix":"473","desc":"459"},{"messageId":"451","fix":"474","desc":"453"},{"messageId":"470","fix":"475","desc":"472"},{"messageId":"457","fix":"476","desc":"459"},{"messageId":"443","fix":"477","desc":"445"},{"messageId":"478","fix":"479","desc":"480"},{"messageId":"451","fix":"481","desc":"453"},{"messageId":"470","fix":"482","desc":"472"},{"messageId":"457","fix":"483","desc":"459"},{"messageId":"451","fix":"484","desc":"453"},{"messageId":"470","fix":"485","desc":"472"},{"messageId":"457","fix":"486","desc":"459"},{"messageId":"451","fix":"487","desc":"453"},{"messageId":"470","fix":"488","desc":"472"},{"messageId":"457","fix":"489","desc":"459"},{"messageId":"451","fix":"490","desc":"453"},{"messageId":"470","fix":"491","desc":"472"},{"messageId":"457","fix":"492","desc":"459"},{"messageId":"451","fix":"493","desc":"453"},{"messageId":"470","fix":"494","desc":"472"},{"messageId":"457","fix":"495","desc":"459"},{"messageId":"451","fix":"496","desc":"453"},{"messageId":"470","fix":"497","desc":"472"},{"messageId":"457","fix":"498","desc":"459"},{"messageId":"443","fix":"499","desc":"445"},{"messageId":"446","fix":"500","desc":"448"},{"messageId":"460","fix":"501","desc":"462"},{"messageId":"451","fix":"502","desc":"453"},{"messageId":"470","fix":"503","desc":"472"},{"messageId":"457","fix":"504","desc":"459"},{"messageId":"460","fix":"505","desc":"462"},{"messageId":"451","fix":"506","desc":"453"},{"messageId":"470","fix":"507","desc":"472"},{"messageId":"457","fix":"508","desc":"459"},{"messageId":"451","fix":"509","desc":"453"},{"messageId":"470","fix":"510","desc":"472"},{"messageId":"457","fix":"511","desc":"459"},{"messageId":"451","fix":"512","desc":"453"},{"messageId":"470","fix":"513","desc":"472"},{"messageId":"457","fix":"514","desc":"459"},{"messageId":"451","fix":"515","desc":"453"},{"messageId":"470","fix":"516","desc":"472"},{"messageId":"457","fix":"517","desc":"459"},{"messageId":"460","fix":"518","desc":"462"},{"messageId":"443","fix":"519","desc":"445"},{"messageId":"446","fix":"520","desc":"448"},{"messageId":"443","fix":"521","desc":"445"},{"messageId":"446","fix":"522","desc":"448"},{"messageId":"451","fix":"523","desc":"453"},{"messageId":"470","fix":"524","desc":"472"},{"messageId":"457","fix":"525","desc":"459"},{"messageId":"451","fix":"526","desc":"453"},{"messageId":"470","fix":"527","desc":"472"},{"messageId":"457","fix":"528","desc":"459"},{"messageId":"451","fix":"529","desc":"453"},{"messageId":"470","fix":"530","desc":"472"},{"messageId":"457","fix":"531","desc":"459"},{"messageId":"451","fix":"532","desc":"453"},{"messageId":"470","fix":"533","desc":"472"},{"messageId":"457","fix":"534","desc":"459"},{"messageId":"451","fix":"535","desc":"453"},{"messageId":"470","fix":"536","desc":"472"},{"messageId":"457","fix":"537","desc":"459"},{"messageId":"451","fix":"538","desc":"453"},{"messageId":"470","fix":"539","desc":"472"},{"messageId":"457","fix":"540","desc":"459"},{"messageId":"460","fix":"541","desc":"462"},{"messageId":"460","fix":"542","desc":"462"},{"messageId":"457","fix":"543","desc":"459"},{"messageId":"443","fix":"544","desc":"445"},{"messageId":"446","fix":"545","desc":"448"},{"messageId":"451","fix":"546","desc":"453"},{"messageId":"470","fix":"547","desc":"472"},{"messageId":"457","fix":"548","desc":"459"},{"messageId":"443","fix":"549","desc":"445"},{"messageId":"446","fix":"550","desc":"448"},{"messageId":"451","fix":"551","desc":"453"},{"messageId":"470","fix":"552","desc":"472"},{"messageId":"457","fix":"553","desc":"459"},{"messageId":"451","fix":"554","desc":"453"},{"messageId":"470","fix":"555","desc":"472"},{"messageId":"457","fix":"556","desc":"459"},{"messageId":"460","fix":"557","desc":"462"},{"messageId":"460","fix":"558","desc":"462"},{"messageId":"443","fix":"559","desc":"445"},{"messageId":"446","fix":"560","desc":"448"},{"messageId":"451","fix":"561","desc":"453"},{"messageId":"470","fix":"562","desc":"472"},{"messageId":"457","fix":"563","desc":"459"},{"messageId":"443","fix":"564","desc":"445"},{"messageId":"446","fix":"565","desc":"448"},{"messageId":"451","fix":"566","desc":"453"},{"messageId":"470","fix":"567","desc":"472"},{"messageId":"457","fix":"568","desc":"459"},{"messageId":"443","fix":"569","desc":"445"},{"messageId":"446","fix":"570","desc":"448"},{"messageId":"443","fix":"571","desc":"445"},{"messageId":"446","fix":"572","desc":"448"},{"messageId":"443","fix":"573","desc":"445"},{"messageId":"446","fix":"574","desc":"448"},{"messageId":"451","fix":"575","desc":"453"},{"messageId":"470","fix":"576","desc":"472"},{"messageId":"457","fix":"577","desc":"459"},{"messageId":"457","fix":"578","desc":"459"},{"kind":"579","justification":"580"},"conditionFixDefaultFalse",{"range":"581","text":"582"},"Explicitly treat nullish value the same as false (`value ?? false`)","conditionFixCompareTrue",{"range":"581","text":"583"},"Change condition to check if true (`value === true`)",{"range":"584","text":"585"},{"range":"584","text":"586"},"conditionFixCompareNullish",{"range":"587","text":"588"},"Change condition to check for null/undefined (`value != null`)","conditionFixDefaultZero",{"range":"587","text":"589"},"Explicitly treat nullish value the same as 0 (`value ?? 0`)","conditionFixCastBoolean",{"range":"587","text":"590"},"Explicitly cast value to a boolean (`Boolean(value)`)","suggestNullish",{"range":"591","text":"592"},"Fix to nullish coalescing operator (`??`).",{"range":"593","text":"592"},{"range":"594","text":"595"},{"range":"594","text":"596"},{"range":"597","text":"592"},{"range":"598","text":"599"},{"range":"600","text":"599"},{"range":"601","text":"602"},"conditionFixDefaultEmptyString",{"range":"601","text":"603"},"Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)",{"range":"601","text":"604"},{"range":"605","text":"602"},{"range":"605","text":"603"},{"range":"605","text":"604"},{"range":"606","text":"607"},"conditionFixCompareFalse",{"range":"608","text":"609"},"Change condition to check if false (`value === false`)",{"range":"610","text":"611"},{"range":"612","text":"613"},{"range":"610","text":"614"},{"range":"615","text":"616"},{"range":"615","text":"617"},{"range":"615","text":"618"},{"range":"619","text":"602"},{"range":"619","text":"603"},{"range":"619","text":"604"},{"range":"620","text":"621"},{"range":"622","text":"623"},{"range":"620","text":"624"},{"range":"625","text":"626"},{"range":"625","text":"627"},{"range":"625","text":"628"},{"range":"629","text":"630"},{"range":"629","text":"631"},{"range":"629","text":"632"},{"range":"633","text":"634"},{"range":"633","text":"635"},{"range":"636","text":"592"},{"range":"637","text":"638"},{"range":"637","text":"639"},{"range":"637","text":"640"},{"range":"641","text":"592"},{"range":"642","text":"643"},{"range":"642","text":"644"},{"range":"642","text":"645"},{"range":"646","text":"647"},{"range":"648","text":"649"},{"range":"646","text":"650"},{"range":"651","text":"602"},{"range":"651","text":"603"},{"range":"651","text":"604"},{"range":"652","text":"653"},{"range":"652","text":"654"},{"range":"652","text":"655"},{"range":"656","text":"592"},{"range":"657","text":"658"},{"range":"657","text":"659"},{"range":"660","text":"658"},{"range":"660","text":"659"},{"range":"661","text":"662"},{"range":"661","text":"663"},{"range":"661","text":"664"},{"range":"665","text":"662"},{"range":"665","text":"663"},{"range":"665","text":"664"},{"range":"666","text":"667"},{"range":"666","text":"668"},{"range":"666","text":"669"},{"range":"670","text":"667"},{"range":"670","text":"668"},{"range":"670","text":"669"},{"range":"671","text":"667"},{"range":"671","text":"668"},{"range":"671","text":"669"},{"range":"672","text":"673"},{"range":"672","text":"674"},{"range":"672","text":"675"},{"range":"676","text":"592"},{"range":"677","text":"592"},{"range":"678","text":"679"},{"range":"680","text":"681"},{"range":"680","text":"682"},{"range":"683","text":"684"},{"range":"683","text":"685"},{"range":"683","text":"686"},{"range":"687","text":"681"},{"range":"687","text":"682"},{"range":"688","text":"684"},{"range":"688","text":"685"},{"range":"688","text":"686"},{"range":"689","text":"690"},{"range":"689","text":"649"},{"range":"689","text":"691"},{"range":"692","text":"592"},{"range":"693","text":"592"},{"range":"694","text":"695"},{"range":"694","text":"696"},{"range":"697","text":"698"},{"range":"697","text":"699"},{"range":"697","text":"700"},{"range":"701","text":"695"},{"range":"701","text":"696"},{"range":"702","text":"698"},{"range":"702","text":"699"},{"range":"702","text":"700"},{"range":"703","text":"607"},{"range":"703","text":"704"},{"range":"705","text":"607"},{"range":"705","text":"704"},{"range":"706","text":"707"},{"range":"706","text":"708"},{"range":"709","text":"710"},{"range":"711","text":"712"},{"range":"709","text":"713"},{"range":"714","text":"715"},"directive","",[9743,9777],"(config.fakeTimers.legacyFakeTimers ?? false)","(config.fakeTimers.legacyFakeTimers === true)",[12054,12067],"(options.watch ?? false)","(options.watch === true)",[12946,12965],"((options?.maxWorkers) != null)","((options?.maxWorkers) ?? 0)","(Boolean((options?.maxWorkers)))",[12966,12968],"??",[13087,13089],[13171,13198],"(config.haste.retainAllFiles ?? false)","(config.haste.retainAllFiles === true)",[13199,13201],[18303,18312],"Boolean(fromCache)",[18881,18890],[26524,26534],"(moduleName != null)","(moduleName ?? \"\")","(Boolean(moduleName))",[26605,26615],[26683,26708],"((options?.isInternalModule) ?? false)",[26682,26708],"((options?.isInternalModule) === false)",[26744,26759],"(moduleResource == null)",[26745,26759],"(moduleResource ?? \"\")","(!Boolean(moduleResource))",[26769,26779],"(manualMock != null)","(manualMock ?? \"\")","(Boolean(manualMock))",[26953,26963],[27140,27151],"modulePath == null",[27141,27151],"(modulePath ?? \"\")","!Boolean(modulePath)",[28662,28664],"to != null","to ?? \"\"","Boolean(to)",[28966,28983],"outsideJestVmPath != null","outsideJestVmPath ?? \"\"","Boolean(outsideJestVmPath)",[29657,29698],"(this._isolatedMockRegistry?.has(moduleID)) ?? false","(this._isolatedMockRegistry?.has(moduleID)) === true",[29914,29916],[30261,30307],"(this._resolver.getMockModule(from, moduleName) != null)","(this._resolver.getMockModule(from, moduleName) ?? \"\")","(Boolean(this._resolver.getMockModule(from, moduleName)))",[30308,30310],[30389,30405],"(manualMockOrStub != null)","(manualMockOrStub ?? \"\")","(Boolean(manualMockOrStub))",[30415,30470],"(this._resolver.resolveStubModuleName(from, moduleName) == null)",[30416,30470],"(this._resolver.resolveStubModuleName(from, moduleName) ?? \"\")","(!Boolean(this._resolver.resolveStubModuleName(from, moduleName)))",[32811,32821],[34069,34094],"(moduleNotFound.moduleName != null)","(moduleNotFound.moduleName ?? \"\")","(Boolean(moduleNotFound.moduleName))",[34095,34097],[38227,38243],"(options?.virtual) ?? false","(options?.virtual) === true",[38803,38819],[40464,40466],"(to != null)","(to ?? \"\")","(Boolean(to))",[40664,40666],[41284,41290],"module != null","module ?? \"\"","Boolean(module)",[41785,41791],[42210,42216],[43909,43913],"(from != null)","(from ?? \"\")","(Boolean(from))",[43914,43916],[43960,43962],[45257,45297],"Boolean(this._environment.global[globalVariable])",[46518,46543],"(options?.isInternalModule) ?? false","(options?.isInternalModule) === true",[47036,47065],"transformedFile.sourceMapPath != null","transformedFile.sourceMapPath ?? \"\"","Boolean(transformedFile.sourceMapPath)",[47360,47385],[47849,47878],[52663,52717],"(this._resolver.resolveStubModuleName(from, moduleName) != null)","(Boolean(this._resolver.resolveStubModuleName(from, moduleName)))",[52718,52720],[53014,53016],[54833,54887],"(this._shouldUnmockTransitiveDependenciesCache.get(key) ?? false)","(this._shouldUnmockTransitiveDependenciesCache.get(key) === true)",[55267,55277],"manualMock != null","manualMock ?? \"\"","Boolean(manualMock)",[56906,56960],[57379,57389],[58789,58814],"((options?.isInternalModule) === true)",[59052,59077],[63142,63176],"(fakeTimersConfig?.legacyFakeTimers) ?? false","(fakeTimersConfig?.legacyFakeTimers) === true",[71250,71257],"source == null",[71251,71257],"(source ?? \"\")","!Boolean(source)",[71563,71572],"(Boolean(condition))"]