[{"/Users/simen/repos/jest/packages/jest-resolve/src/ModuleNotFoundError.ts":"1","/Users/simen/repos/jest/packages/jest-resolve/src/__mocks__/userResolver.d.ts":"2","/Users/simen/repos/jest/packages/jest-resolve/src/__mocks__/userResolverAsync.d.ts":"3","/Users/simen/repos/jest/packages/jest-resolve/src/__tests__/isBuiltinModule.test.ts":"4","/Users/simen/repos/jest/packages/jest-resolve/src/__tests__/resolve.test.ts":"5","/Users/simen/repos/jest/packages/jest-resolve/src/defaultResolver.ts":"6","/Users/simen/repos/jest/packages/jest-resolve/src/fileWalkers.ts":"7","/Users/simen/repos/jest/packages/jest-resolve/src/index.ts":"8","/Users/simen/repos/jest/packages/jest-resolve/src/isBuiltinModule.ts":"9","/Users/simen/repos/jest/packages/jest-resolve/src/nodeModulesPaths.ts":"10","/Users/simen/repos/jest/packages/jest-resolve/src/resolver.ts":"11","/Users/simen/repos/jest/packages/jest-resolve/src/shouldLoadAsEsm.ts":"12","/Users/simen/repos/jest/packages/jest-resolve/src/types.ts":"13","/Users/simen/repos/jest/packages/jest-resolve/src/utils.ts":"14"},{"size":1366,"mtime":1663311355500,"results":"15","hashOfConfig":"16"},{"size":338,"mtime":1665737657504,"results":"17","hashOfConfig":"16"},{"size":404,"mtime":1665737657504,"results":"18","hashOfConfig":"16"},{"size":789,"mtime":1662708144220,"results":"19","hashOfConfig":"16"},{"size":22944,"mtime":1665737657505,"results":"20","hashOfConfig":"16"},{"size":5981,"mtime":1665737657505,"results":"21","hashOfConfig":"16"},{"size":3157,"mtime":1664535326139,"results":"22","hashOfConfig":"16"},{"size":581,"mtime":1664535326140,"results":"23","hashOfConfig":"16"},{"size":411,"mtime":1663311355504,"results":"24","hashOfConfig":"16"},{"size":1976,"mtime":1663311355504,"results":"25","hashOfConfig":"16"},{"size":26462,"mtime":1665737657505,"results":"26","hashOfConfig":"16"},{"size":2296,"mtime":1663311355504,"results":"27","hashOfConfig":"16"},{"size":876,"mtime":1664535326140,"results":"28","hashOfConfig":"16"},{"size":5037,"mtime":1664535326140,"results":"29","hashOfConfig":"16"},{"filePath":"30","messages":"31","suppressedMessages":"32","errorCount":4,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"33"},"oor130",{"filePath":"34","messages":"35","suppressedMessages":"36","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"37","messages":"38","suppressedMessages":"39","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"40","messages":"41","suppressedMessages":"42","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"43","messages":"44","suppressedMessages":"45","errorCount":26,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"46"},{"filePath":"47","messages":"48","suppressedMessages":"49","errorCount":7,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"50"},{"filePath":"51","messages":"52","suppressedMessages":"53","errorCount":3,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"54"},{"filePath":"55","messages":"56","suppressedMessages":"57","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"58","messages":"59","suppressedMessages":"60","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"61","messages":"62","suppressedMessages":"63","errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"64"},{"filePath":"65","messages":"66","suppressedMessages":"67","errorCount":69,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"68"},{"filePath":"69","messages":"70","suppressedMessages":"71","errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"72"},{"filePath":"73","messages":"74","suppressedMessages":"75","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"76","messages":"77","suppressedMessages":"78","errorCount":7,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"79"},"/Users/simen/repos/jest/packages/jest-resolve/src/ModuleNotFoundError.ts",["80","81","82","83"],[],"/**\n * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport * as path from 'path';\nimport slash = require('slash');\n\nexport default class ModuleNotFoundError extends Error {\n  public code = 'MODULE_NOT_FOUND';\n  public hint?: string;\n  public requireStack?: Array<string>;\n  public siblingWithSimilarExtensionFound?: boolean;\n  public moduleName?: string;\n\n  private _originalMessage?: string;\n\n  constructor(message: string, moduleName?: string) {\n    super(message);\n    this._originalMessage = message;\n    this.moduleName = moduleName;\n  }\n\n  public buildMessage(rootDir: string): void {\n    if (!this._originalMessage) {\n      this._originalMessage = this.message || '';\n    }\n\n    let message = this._originalMessage;\n\n    if (this.requireStack?.length && this.requireStack.length > 1) {\n      message += `\n\nRequire stack:\n  ${this.requireStack\n    .map(p => p.replace(`${rootDir}${path.sep}`, ''))\n    .map(slash)\n    .join('\\n  ')}\n`;\n    }\n\n    if (this.hint) {\n      message += this.hint;\n    }\n\n    this.message = message;\n  }\n\n  public static duckType(error: ModuleNotFoundError): ModuleNotFoundError {\n    error.buildMessage = ModuleNotFoundError.prototype.buildMessage;\n    return error;\n  }\n}\n","/Users/simen/repos/jest/packages/jest-resolve/src/__mocks__/userResolver.d.ts",[],[],"/Users/simen/repos/jest/packages/jest-resolve/src/__mocks__/userResolverAsync.d.ts",[],[],"/Users/simen/repos/jest/packages/jest-resolve/src/__tests__/isBuiltinModule.test.ts",[],[],"/Users/simen/repos/jest/packages/jest-resolve/src/__tests__/resolve.test.ts",["84","85","86","87","88","89","90","91","92","93","94","95","96","97","98","99","100","101","102","103","104","105","106","107","108","109"],[],"/**\n * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nimport * as path from 'path';\nimport * as fs from 'graceful-fs';\nimport {sync as resolveSync} from 'resolve';\nimport {IModuleMap, ModuleMap} from 'jest-haste-map';\nimport userResolver from '../__mocks__/userResolver';\nimport userResolverAsync from '../__mocks__/userResolverAsync';\nimport defaultResolver, {PackageFilter} from '../defaultResolver';\nimport nodeModulesPaths from '../nodeModulesPaths';\nimport Resolver from '../resolver';\nimport type {ResolverConfig} from '../types';\n\njest.mock('../__mocks__/userResolver').mock('../__mocks__/userResolverAsync');\n\n// Do not fully mock `resolve` because it is used by Jest. Doing it will crash\n// in very strange ways. Instead, just spy on it and its `sync` method.\njest.mock('resolve', () => {\n  const originalModule =\n    jest.requireActual<typeof import('resolve')>('resolve');\n\n  const m = jest.fn<typeof import('resolve')>((...args) =>\n    originalModule(...args),\n  );\n  Object.assign(m, originalModule);\n  m.sync = jest.spyOn(originalModule, 'sync');\n\n  return m;\n});\n\nconst mockUserResolver = jest.mocked(userResolver);\nconst mockUserResolverAsync = jest.mocked(userResolverAsync);\nconst mockResolveSync = jest.mocked(resolveSync);\n\nbeforeEach(() => {\n  mockUserResolver.mockClear();\n  mockUserResolverAsync.async.mockClear();\n  mockResolveSync.mockClear();\n\n  Resolver.clearDefaultResolverCache();\n});\n\ndescribe('isCoreModule', () => {\n  it('returns false if `hasCoreModules` is false.', () => {\n    const moduleMap = ModuleMap.create('/');\n    const resolver = new Resolver(moduleMap, {\n      hasCoreModules: false,\n    } as ResolverConfig);\n    const isCore = resolver.isCoreModule('assert');\n    expect(isCore).toBe(false);\n  });\n\n  it('returns true if `hasCoreModules` is true and `moduleName` is a core module.', () => {\n    const moduleMap = ModuleMap.create('/');\n    const resolver = new Resolver(moduleMap, {} as ResolverConfig);\n    const isCore = resolver.isCoreModule('assert');\n    expect(isCore).toBe(true);\n  });\n\n  it('returns false if `hasCoreModules` is true and `moduleName` is not a core module.', () => {\n    const moduleMap = ModuleMap.create('/');\n    const resolver = new Resolver(moduleMap, {} as ResolverConfig);\n    const isCore = resolver.isCoreModule('not-a-core-module');\n    expect(isCore).toBe(false);\n  });\n\n  it('returns false if `hasCoreModules` is true and `moduleNameMapper` alias a module same name with core module', () => {\n    const moduleMap = ModuleMap.create('/');\n    const resolver = new Resolver(moduleMap, {\n      moduleNameMapper: [\n        {\n          moduleName: '$1',\n          regex: /^constants$/,\n        },\n      ],\n    } as ResolverConfig);\n    const isCore = resolver.isCoreModule('constants');\n    expect(isCore).toBe(false);\n  });\n\n  it('returns true if using `node:` URLs and `moduleName` is a core module.', () => {\n    const moduleMap = ModuleMap.create('/');\n    const resolver = new Resolver(moduleMap, {} as ResolverConfig);\n    const isCore = resolver.isCoreModule('node:assert');\n    expect(isCore).toBe(true);\n  });\n\n  it('returns false if using `node:` URLs and `moduleName` is not a core module.', () => {\n    const moduleMap = ModuleMap.create('/');\n    const resolver = new Resolver(moduleMap, {} as ResolverConfig);\n    const isCore = resolver.isCoreModule('node:not-a-core-module');\n    expect(isCore).toBe(false);\n  });\n});\n\ndescribe('findNodeModule', () => {\n  it('is possible to override the default resolver', () => {\n    const cwd = process.cwd();\n    const resolvedCwd = fs.realpathSync(cwd) || cwd;\n    const nodePaths = process.env.NODE_PATH\n      ? process.env.NODE_PATH.split(path.delimiter)\n          .filter(Boolean)\n          .map(p => path.resolve(resolvedCwd, p))\n      : null;\n\n    mockUserResolver.mockImplementation(() => 'module');\n\n    const newPath = Resolver.findNodeModule('test', {\n      basedir: '/',\n      conditions: ['conditions, woooo'],\n      extensions: ['js'],\n      moduleDirectory: ['node_modules'],\n      paths: ['/something'],\n      resolver: require.resolve('../__mocks__/userResolver'),\n    });\n\n    expect(newPath).toBe('module');\n    expect(mockUserResolver.mock.calls[0][0]).toBe('test');\n    expect(mockUserResolver.mock.calls[0][1]).toStrictEqual({\n      basedir: '/',\n      conditions: ['conditions, woooo'],\n      defaultResolver,\n      extensions: ['js'],\n      moduleDirectory: ['node_modules'],\n      paths: (nodePaths || []).concat(['/something']),\n      rootDir: undefined,\n    });\n  });\n\n  it('wraps passed packageFilter to the resolve module when using the default resolver', () => {\n    const packageFilter = jest.fn<PackageFilter>();\n\n    // A resolver that delegates to defaultResolver with a packageFilter implementation\n    mockUserResolver.mockImplementation((request, opts) =>\n      opts.defaultResolver(request, {...opts, packageFilter}),\n    );\n\n    Resolver.findNodeModule('./test', {\n      basedir: path.resolve(__dirname, '../__mocks__/'),\n      resolver: require.resolve('../__mocks__/userResolver'),\n    });\n\n    expect(packageFilter).toHaveBeenCalledWith(\n      expect.objectContaining({name: '__mocks__'}),\n      expect.any(String),\n    );\n  });\n\n  describe('conditions', () => {\n    const conditionsRoot = path.resolve(__dirname, '../__mocks__/conditions');\n\n    test('resolves without exports, just main', () => {\n      const result = Resolver.findNodeModule('main', {\n        basedir: conditionsRoot,\n        conditions: ['require'],\n      });\n\n      expect(result).toEqual(\n        path.resolve(conditionsRoot, './node_modules/main/file.js'),\n      );\n    });\n\n    test('resolves with import', () => {\n      const result = Resolver.findNodeModule('exports', {\n        basedir: conditionsRoot,\n        conditions: ['import'],\n      });\n\n      expect(result).toEqual(\n        path.resolve(conditionsRoot, './node_modules/exports/import.js'),\n      );\n    });\n\n    test('resolves with require', () => {\n      const result = Resolver.findNodeModule('exports', {\n        basedir: conditionsRoot,\n        conditions: ['require'],\n      });\n\n      expect(result).toEqual(\n        path.resolve(conditionsRoot, './node_modules/exports/require.js'),\n      );\n    });\n\n    test('gets default when nothing is passed', () => {\n      const result = Resolver.findNodeModule('exports', {\n        basedir: conditionsRoot,\n        conditions: [],\n      });\n\n      expect(result).toEqual(\n        path.resolve(conditionsRoot, './node_modules/exports/default.js'),\n      );\n    });\n\n    test('respects order in package.json, not conditions', () => {\n      const resultImport = Resolver.findNodeModule('exports', {\n        basedir: conditionsRoot,\n        conditions: ['import', 'require'],\n      });\n      const resultRequire = Resolver.findNodeModule('exports', {\n        basedir: conditionsRoot,\n        conditions: ['require', 'import'],\n      });\n\n      expect(resultImport).toEqual(resultRequire);\n    });\n\n    test('supports nested paths', () => {\n      const result = Resolver.findNodeModule('exports/nested', {\n        basedir: conditionsRoot,\n        conditions: [],\n      });\n\n      expect(result).toEqual(\n        path.resolve(conditionsRoot, './node_modules/exports/nestedDefault.js'),\n      );\n    });\n\n    test('supports nested paths with wildcard and no extension', () => {\n      const result = Resolver.findNodeModule('exports/directory/file', {\n        basedir: conditionsRoot,\n        conditions: [],\n      });\n\n      expect(result).toEqual(\n        path.resolve(\n          conditionsRoot,\n          './node_modules/exports/some-other-directory/file.js',\n        ),\n      );\n    });\n\n    test('supports nested conditions', () => {\n      const resultRequire = Resolver.findNodeModule('exports/deeplyNested', {\n        basedir: conditionsRoot,\n        conditions: ['require'],\n      });\n      const resultDefault = Resolver.findNodeModule('exports/deeplyNested', {\n        basedir: conditionsRoot,\n        conditions: [],\n      });\n\n      expect(resultRequire).toEqual(\n        path.resolve(conditionsRoot, './node_modules/exports/nestedRequire.js'),\n      );\n\n      expect(resultDefault).toEqual(\n        path.resolve(conditionsRoot, './node_modules/exports/nestedDefault.js'),\n      );\n    });\n\n    test('supports separate directory path', () => {\n      const result = Resolver.findNodeModule('exports/directory/file.js', {\n        basedir: conditionsRoot,\n        conditions: [],\n      });\n\n      expect(result).toEqual(\n        path.resolve(\n          conditionsRoot,\n          './node_modules/exports/some-other-directory/file.js',\n        ),\n      );\n    });\n  });\n\n  describe('self-reference', () => {\n    const selfRefRoot = path.resolve(__dirname, '../__mocks__/self-ref');\n\n    test('supports self-reference', () => {\n      const result = Resolver.findNodeModule('foo', {\n        basedir: path.resolve(selfRefRoot, './foo/index.js'),\n        conditions: [],\n      });\n\n      expect(result).toEqual(path.resolve(selfRefRoot, './foo/file.js'));\n    });\n\n    test('supports nested self-reference', () => {\n      const result = Resolver.findNodeModule('foo', {\n        basedir: path.resolve(selfRefRoot, './foo/nested/index.js'),\n        conditions: [],\n      });\n\n      expect(result).toEqual(path.resolve(selfRefRoot, './foo/file.js'));\n    });\n\n    test('fails if own pkg.json with different name', () => {\n      const result = Resolver.findNodeModule('foo', {\n        basedir: path.resolve(\n          selfRefRoot,\n          './foo/nested-with-own-pkg/index.js',\n        ),\n        conditions: [],\n      });\n\n      expect(result).toBeNull();\n    });\n\n    test('fails if own pkg.json with no exports', () => {\n      const result = Resolver.findNodeModule('foo-no-exports', {\n        basedir: path.resolve(\n          selfRefRoot,\n          './foo/nested-with-no-exports/index.js',\n        ),\n        conditions: [],\n      });\n\n      expect(result).toBeNull();\n    });\n  });\n});\n\ndescribe('findNodeModuleAsync', () => {\n  it('is possible to override the default resolver', async () => {\n    const cwd = process.cwd();\n    const resolvedCwd = fs.realpathSync(cwd) || cwd;\n    const nodePaths = process.env.NODE_PATH\n      ? process.env.NODE_PATH.split(path.delimiter)\n          .filter(Boolean)\n          .map(p => path.resolve(resolvedCwd, p))\n      : null;\n\n    mockUserResolverAsync.async.mockResolvedValue('module');\n\n    const newPath = await Resolver.findNodeModuleAsync('test', {\n      basedir: '/',\n      conditions: ['conditions, woooo'],\n      extensions: ['js'],\n      moduleDirectory: ['node_modules'],\n      paths: ['/something'],\n      resolver: require.resolve('../__mocks__/userResolverAsync'),\n    });\n\n    expect(newPath).toBe('module');\n    expect(mockUserResolverAsync.async.mock.calls[0][0]).toBe('test');\n    expect(mockUserResolverAsync.async.mock.calls[0][1]).toStrictEqual({\n      basedir: '/',\n      conditions: ['conditions, woooo'],\n      defaultResolver,\n      extensions: ['js'],\n      moduleDirectory: ['node_modules'],\n      paths: (nodePaths || []).concat(['/something']),\n      rootDir: undefined,\n    });\n  });\n\n  it('passes packageFilter to the resolve module when using the default resolver', async () => {\n    const packageFilter = jest.fn<PackageFilter>();\n\n    // A resolver that delegates to defaultResolver with a packageFilter implementation\n    mockUserResolverAsync.async.mockImplementation((request, opts) =>\n      Promise.resolve(opts.defaultResolver(request, {...opts, packageFilter})),\n    );\n\n    await Resolver.findNodeModuleAsync('test', {\n      basedir: '/',\n      resolver: require.resolve('../__mocks__/userResolverAsync'),\n    });\n\n    expect(mockResolveSync).toHaveBeenCalledWith(\n      'test',\n      expect.objectContaining({\n        packageFilter,\n      }),\n    );\n  });\n});\n\ndescribe('resolveModule', () => {\n  let moduleMap: IModuleMap;\n  beforeEach(() => {\n    moduleMap = ModuleMap.create('/');\n  });\n\n  it('is possible to resolve node modules', () => {\n    const resolver = new Resolver(moduleMap, {\n      extensions: ['.js'],\n    } as ResolverConfig);\n    const src = require.resolve('../');\n    const resolved = resolver.resolveModule(\n      src,\n      './__mocks__/mockJsDependency',\n    );\n    expect(resolved).toBe(require.resolve('../__mocks__/mockJsDependency.js'));\n  });\n\n  it('is possible to resolve node modules with custom extensions', () => {\n    const resolver = new Resolver(moduleMap, {\n      extensions: ['.js', '.jsx'],\n    } as ResolverConfig);\n    const src = require.resolve('../');\n    const resolvedJsx = resolver.resolveModule(\n      src,\n      './__mocks__/mockJsxDependency',\n    );\n    expect(resolvedJsx).toBe(\n      require.resolve('../__mocks__/mockJsxDependency.jsx'),\n    );\n  });\n\n  it('is possible to resolve node modules with custom extensions and platforms', () => {\n    const resolver = new Resolver(moduleMap, {\n      extensions: ['.js', '.jsx'],\n      platforms: ['native'],\n    } as ResolverConfig);\n    const src = require.resolve('../');\n    const resolvedJsx = resolver.resolveModule(\n      src,\n      './__mocks__/mockJsxDependency',\n    );\n    expect(resolvedJsx).toBe(\n      require.resolve('../__mocks__/mockJsxDependency.native.jsx'),\n    );\n  });\n\n  it('is possible to resolve node modules by resolving their realpath', () => {\n    const resolver = new Resolver(moduleMap, {\n      extensions: ['.js'],\n    } as ResolverConfig);\n    const src = path.join(\n      path.resolve(__dirname, '../../src/__mocks__/bar/node_modules/'),\n      'foo/index.js',\n    );\n    const resolved = resolver.resolveModule(src, 'dep');\n    expect(resolved).toBe(\n      require.resolve('../../src/__mocks__/foo/node_modules/dep/index.js'),\n    );\n  });\n\n  it('is possible to specify custom resolve paths', () => {\n    const resolver = new Resolver(moduleMap, {\n      extensions: ['.js'],\n    } as ResolverConfig);\n    const src = require.resolve('../');\n    const resolved = resolver.resolveModule(src, 'mockJsDependency', {\n      paths: [\n        path.resolve(__dirname, '../../src/__mocks__'),\n        path.resolve(__dirname, '../../src/__tests__'),\n      ],\n    });\n    expect(resolved).toBe(require.resolve('../__mocks__/mockJsDependency.js'));\n  });\n\n  it('does not confuse directories with files', () => {\n    const resolver = new Resolver(moduleMap, {\n      extensions: ['.js'],\n    } as ResolverConfig);\n    const mocksDirectory = path.resolve(__dirname, '../__mocks__');\n    const fooSlashFoo = path.join(mocksDirectory, 'foo/foo.js');\n    const fooSlashIndex = path.join(mocksDirectory, 'foo/index.js');\n\n    const resolvedWithSlash = resolver.resolveModule(fooSlashFoo, './');\n    const resolvedWithDot = resolver.resolveModule(fooSlashFoo, '.');\n    expect(resolvedWithSlash).toBe(fooSlashIndex);\n    expect(resolvedWithSlash).toBe(resolvedWithDot);\n  });\n\n  it('custom resolver can resolve node modules', () => {\n    mockUserResolver.mockImplementation(() => 'module');\n\n    const moduleMap = ModuleMap.create('/');\n    const resolver = new Resolver(moduleMap, {\n      extensions: ['.js'],\n      resolver: require.resolve('../__mocks__/userResolver'),\n    } as ResolverConfig);\n    const src = require.resolve('../');\n    resolver.resolveModule(src, 'fs');\n\n    expect(mockUserResolver).toHaveBeenCalled();\n    expect(mockUserResolver.mock.calls[0][0]).toBe('fs');\n  });\n});\n\ndescribe('resolveModuleAsync', () => {\n  let moduleMap: IModuleMap;\n  beforeEach(() => {\n    moduleMap = ModuleMap.create('/');\n  });\n\n  it('is possible to resolve node modules', async () => {\n    const resolver = new Resolver(moduleMap, {\n      extensions: ['.js'],\n    } as ResolverConfig);\n    const src = require.resolve('../');\n    const resolved = await resolver.resolveModuleAsync(\n      src,\n      './__mocks__/mockJsDependency',\n    );\n    expect(resolved).toBe(require.resolve('../__mocks__/mockJsDependency.js'));\n  });\n\n  it('is possible to resolve node modules with custom extensions', async () => {\n    const resolver = new Resolver(moduleMap, {\n      extensions: ['.js', '.jsx'],\n    } as ResolverConfig);\n    const src = require.resolve('../');\n    const resolvedJsx = await resolver.resolveModuleAsync(\n      src,\n      './__mocks__/mockJsxDependency',\n    );\n    expect(resolvedJsx).toBe(\n      require.resolve('../__mocks__/mockJsxDependency.jsx'),\n    );\n  });\n\n  it('is possible to resolve node modules with custom extensions and platforms', async () => {\n    const resolver = new Resolver(moduleMap, {\n      extensions: ['.js', '.jsx'],\n      platforms: ['native'],\n    } as ResolverConfig);\n    const src = require.resolve('../');\n    const resolvedJsx = await resolver.resolveModuleAsync(\n      src,\n      './__mocks__/mockJsxDependency',\n    );\n    expect(resolvedJsx).toBe(\n      require.resolve('../__mocks__/mockJsxDependency.native.jsx'),\n    );\n  });\n\n  it('is possible to resolve node modules by resolving their realpath', async () => {\n    const resolver = new Resolver(moduleMap, {\n      extensions: ['.js'],\n    } as ResolverConfig);\n    const src = path.join(\n      path.resolve(__dirname, '../../src/__mocks__/bar/node_modules/'),\n      'foo/index.js',\n    );\n    const resolved = await resolver.resolveModuleAsync(src, 'dep');\n    expect(resolved).toBe(\n      require.resolve('../../src/__mocks__/foo/node_modules/dep/index.js'),\n    );\n  });\n\n  it('is possible to specify custom resolve paths', async () => {\n    const resolver = new Resolver(moduleMap, {\n      extensions: ['.js'],\n    } as ResolverConfig);\n    const src = require.resolve('../');\n    const resolved = await resolver.resolveModuleAsync(\n      src,\n      'mockJsDependency',\n      {\n        paths: [\n          path.resolve(__dirname, '../../src/__tests__'),\n          path.resolve(__dirname, '../../src/__mocks__'),\n        ],\n      },\n    );\n    expect(resolved).toBe(require.resolve('../__mocks__/mockJsDependency.js'));\n  });\n\n  it('does not confuse directories with files', async () => {\n    const resolver = new Resolver(moduleMap, {\n      extensions: ['.js'],\n    } as ResolverConfig);\n    const mocksDirectory = path.resolve(__dirname, '../__mocks__');\n    const fooSlashFoo = path.join(mocksDirectory, 'foo/foo.js');\n    const fooSlashIndex = path.join(mocksDirectory, 'foo/index.js');\n\n    const resolvedWithSlash = await resolver.resolveModuleAsync(\n      fooSlashFoo,\n      './',\n    );\n    const resolvedWithDot = await resolver.resolveModuleAsync(fooSlashFoo, '.');\n    expect(resolvedWithSlash).toBe(fooSlashIndex);\n    expect(resolvedWithSlash).toBe(resolvedWithDot);\n  });\n});\n\ndescribe('getMockModule', () => {\n  it('is possible to use custom resolver to resolve deps inside mock modules with moduleNameMapper', () => {\n    mockUserResolver.mockImplementation(() => 'module');\n\n    const moduleMap = ModuleMap.create('/');\n    const resolver = new Resolver(moduleMap, {\n      extensions: ['.js'],\n      moduleNameMapper: [\n        {\n          moduleName: '$1',\n          regex: /(.*)/,\n        },\n      ],\n      resolver: require.resolve('../__mocks__/userResolver'),\n    } as ResolverConfig);\n    const src = require.resolve('../');\n    resolver.getMockModule(src, 'dependentModule');\n\n    expect(mockUserResolver).toHaveBeenCalled();\n    expect(mockUserResolver.mock.calls[0][0]).toBe('dependentModule');\n    expect(mockUserResolver.mock.calls[0][1]).toHaveProperty(\n      'basedir',\n      path.dirname(src),\n    );\n  });\n});\n\ndescribe('getMockModuleAsync', () => {\n  it('is possible to use custom resolver to resolve deps inside mock modules with moduleNameMapper', async () => {\n    mockUserResolverAsync.async.mockResolvedValue('module');\n\n    const moduleMap = ModuleMap.create('/');\n    const resolver = new Resolver(moduleMap, {\n      extensions: ['.js'],\n      moduleNameMapper: [\n        {\n          moduleName: '$1',\n          regex: /(.*)/,\n        },\n      ],\n      resolver: require.resolve('../__mocks__/userResolverAsync'),\n    } as ResolverConfig);\n    const src = require.resolve('../');\n\n    await resolver.resolveModuleAsync(src, 'dependentModule');\n\n    expect(mockUserResolverAsync.async).toHaveBeenCalled();\n    expect(mockUserResolverAsync.async.mock.calls[0][0]).toBe(\n      'dependentModule',\n    );\n    expect(mockUserResolverAsync.async.mock.calls[0][1]).toHaveProperty(\n      'basedir',\n      path.dirname(src),\n    );\n  });\n});\n\ndescribe('nodeModulesPaths', () => {\n  it('provides custom module paths after node_modules', () => {\n    const src = require.resolve('../');\n    const result = nodeModulesPaths(src, {paths: ['./customFolder']});\n    expect(result[result.length - 1]).toBe('./customFolder');\n  });\n});\n\ndescribe('Resolver.getModulePaths() -> nodeModulesPaths()', () => {\n  const _path = path;\n  let moduleMap: IModuleMap;\n\n  beforeEach(() => {\n    jest.resetModules();\n\n    moduleMap = ModuleMap.create('/');\n\n    // Mocking realpath to function the old way, where it just looks at\n    // pathstrings instead of actually trying to access the physical directory.\n    // This test suite won't work otherwise, since we cannot make assumptions\n    // about the test environment when it comes to absolute paths.\n    jest.doMock('graceful-fs', () => ({\n      ...jest.requireActual<typeof import('graceful-fs')>('graceful-fs'),\n      realPathSync: {\n        native: (dirInput: string) => dirInput,\n      },\n    }));\n  });\n\n  afterAll(() => {\n    jest.resetModules();\n    jest.dontMock('path');\n  });\n\n  it('can resolve node modules relative to absolute paths in \"moduleDirectories\" on Windows platforms', () => {\n    jest.doMock('path', () => _path.win32);\n    const path = require('path');\n    const Resolver = require('../').default;\n\n    const cwd = 'D:\\\\temp\\\\project';\n    const src = 'C:\\\\path\\\\to\\\\node_modules';\n    const resolver = new Resolver(moduleMap, {\n      moduleDirectories: [src, 'node_modules'],\n    });\n    const dirs_expected = [\n      src,\n      `${cwd}\\\\node_modules`,\n      `${path.dirname(cwd)}\\\\node_modules`,\n      'D:\\\\node_modules',\n    ];\n    const dirs_actual = resolver.getModulePaths(cwd);\n    expect(dirs_actual).toEqual(expect.arrayContaining(dirs_expected));\n  });\n\n  it('can resolve node modules relative to absolute paths in \"moduleDirectories\" on Posix platforms', () => {\n    jest.doMock('path', () => _path.posix);\n    const path = require('path');\n    const Resolver = require('../').default;\n\n    const cwd = '/temp/project';\n    const src = '/path/to/node_modules';\n    const resolver = new Resolver(moduleMap, {\n      moduleDirectories: [src, 'node_modules'],\n    });\n    const dirs_expected = [\n      src,\n      `${cwd}/node_modules`,\n      `${path.dirname(cwd)}/node_modules`,\n      '/node_modules',\n    ];\n    const dirs_actual = resolver.getModulePaths(cwd);\n    expect(dirs_actual).toEqual(expect.arrayContaining(dirs_expected));\n  });\n});\n","/Users/simen/repos/jest/packages/jest-resolve/src/defaultResolver.ts",["110","111","112","113","114","115","116"],[],"/**\n * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport {dirname, isAbsolute, resolve as pathResolve} from 'path';\nimport pnpResolver from 'jest-pnp-resolver';\nimport {SyncOpts as UpstreamResolveOptions, sync as resolveSync} from 'resolve';\nimport {\n  Options as ResolveExportsOptions,\n  resolve as resolveExports,\n} from 'resolve.exports';\nimport {\n  findClosestPackageJson,\n  isDirectory,\n  isFile,\n  readPackageCached,\n  realpathSync,\n} from './fileWalkers';\nimport type {PackageJSON} from './types';\n\n/**\n * Allows transforming parsed `package.json` contents.\n *\n * @param pkg - Parsed `package.json` contents.\n * @param file - Path to `package.json` file.\n * @param dir - Directory that contains the `package.json`.\n *\n * @returns Transformed `package.json` contents.\n */\nexport type PackageFilter = (\n  pkg: PackageJSON,\n  file: string,\n  dir: string,\n) => PackageJSON;\n\n/**\n * Allows transforming a path within a package.\n *\n * @param pkg - Parsed `package.json` contents.\n * @param path - Path being resolved.\n * @param relativePath - Path relative from the `package.json` location.\n *\n * @returns Relative path that will be joined from the `package.json` location.\n */\nexport type PathFilter = (\n  pkg: PackageJSON,\n  path: string,\n  relativePath: string,\n) => string;\n\nexport type ResolverOptions = {\n  /** Directory to begin resolving from. */\n  basedir: string;\n  /** List of export conditions. */\n  conditions?: Array<string>;\n  /** Instance of default resolver. */\n  defaultResolver: typeof defaultResolver;\n  /** List of file extensions to search in order. */\n  extensions?: Array<string>;\n  /**\n   * List of directory names to be looked up for modules recursively.\n   *\n   * @defaultValue\n   * The default is `['node_modules']`.\n   */\n  moduleDirectory?: Array<string>;\n  /**\n   * List of `require.paths` to use if nothing is found in `node_modules`.\n   *\n   * @defaultValue\n   * The default is `undefined`.\n   */\n  paths?: Array<string>;\n  /** Allows transforming parsed `package.json` contents. */\n  packageFilter?: PackageFilter;\n  /** Allows transforms a path within a package. */\n  pathFilter?: PathFilter;\n  /** Current root directory. */\n  rootDir?: string;\n};\n\ntype UpstreamResolveOptionsWithConditions = UpstreamResolveOptions &\n  Pick<ResolverOptions, 'basedir' | 'conditions'>;\n\nexport type SyncResolver = (path: string, options: ResolverOptions) => string;\nexport type AsyncResolver = (\n  path: string,\n  options: ResolverOptions,\n) => Promise<string>;\n\nexport type Resolver = SyncResolver | AsyncResolver;\n\nconst defaultResolver: SyncResolver = (path, options) => {\n  // Yarn 2 adds support to `resolve` automatically so the pnpResolver is only\n  // needed for Yarn 1 which implements version 1 of the pnp spec\n  if (process.versions.pnp === '1') {\n    return pnpResolver(path, options);\n  }\n\n  const resolveOptions: UpstreamResolveOptionsWithConditions = {\n    ...options,\n    isDirectory,\n    isFile,\n    preserveSymlinks: false,\n    readPackageSync,\n    realpathSync,\n  };\n\n  const pathToResolve = getPathInModule(path, resolveOptions);\n\n  const result = resolveSync(pathToResolve, resolveOptions);\n\n  // Dereference symlinks to ensure we don't create a separate\n  // module instance depending on how it was referenced.\n  return realpathSync(result);\n};\n\nexport default defaultResolver;\n\n/*\n * helper functions\n */\n\nfunction readPackageSync(_: unknown, file: string): PackageJSON {\n  return readPackageCached(file);\n}\n\nfunction getPathInModule(\n  path: string,\n  options: UpstreamResolveOptionsWithConditions,\n): string {\n  if (shouldIgnoreRequestForExports(path)) {\n    return path;\n  }\n\n  const segments = path.split('/');\n\n  let moduleName = segments.shift();\n\n  if (moduleName) {\n    // TODO: handle `#` here: https://github.com/facebook/jest/issues/12270\n    if (moduleName.startsWith('@')) {\n      moduleName = `${moduleName}/${segments.shift()}`;\n    }\n\n    // self-reference\n    const closestPackageJson = findClosestPackageJson(options.basedir);\n    if (closestPackageJson) {\n      const pkg = readPackageCached(closestPackageJson);\n\n      if (pkg.name === moduleName && pkg.exports) {\n        const subpath = segments.join('/') || '.';\n\n        const resolved = resolveExports(\n          pkg,\n          subpath,\n          createResolveOptions(options.conditions),\n        );\n\n        if (!resolved) {\n          throw new Error(\n            '`exports` exists, but no results - this is a bug in Jest. Please report an issue',\n          );\n        }\n\n        return pathResolve(dirname(closestPackageJson), resolved);\n      }\n    }\n\n    let packageJsonPath = '';\n\n    try {\n      packageJsonPath = resolveSync(`${moduleName}/package.json`, options);\n    } catch {\n      // ignore if package.json cannot be found\n    }\n\n    if (packageJsonPath && isFile(packageJsonPath)) {\n      const pkg = readPackageCached(packageJsonPath);\n\n      if (pkg.exports) {\n        const subpath = segments.join('/') || '.';\n\n        const resolved = resolveExports(\n          pkg,\n          subpath,\n          createResolveOptions(options.conditions),\n        );\n\n        if (!resolved) {\n          throw new Error(\n            '`exports` exists, but no results - this is a bug in Jest. Please report an issue',\n          );\n        }\n\n        return pathResolve(dirname(packageJsonPath), resolved);\n      }\n    }\n  }\n\n  return path;\n}\n\nfunction createResolveOptions(\n  conditions: Array<string> | undefined,\n): ResolveExportsOptions {\n  return conditions\n    ? {conditions, unsafe: true}\n    : // no conditions were passed - let's assume this is Jest internal and it should be `require`\n      {browser: false, require: true};\n}\n\n// if it's a relative import or an absolute path, exports are ignored\nconst shouldIgnoreRequestForExports = (path: string) =>\n  path.startsWith('.') || isAbsolute(path);\n","/Users/simen/repos/jest/packages/jest-resolve/src/fileWalkers.ts",["117","118","119"],[],"/**\n * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport {dirname, resolve} from 'path';\nimport * as fs from 'graceful-fs';\nimport {tryRealpath} from 'jest-util';\nimport type {PackageJSON} from './types';\n\nexport function clearFsCache(): void {\n  checkedPaths.clear();\n  checkedRealpathPaths.clear();\n  packageContents.clear();\n}\n\nenum IPathType {\n  FILE = 1,\n  DIRECTORY = 2,\n  OTHER = 3,\n}\nconst checkedPaths = new Map<string, IPathType>();\nfunction statSyncCached(path: string): IPathType {\n  const result = checkedPaths.get(path);\n  if (result != null) {\n    return result;\n  }\n\n  let stat;\n  try {\n    // @ts-expect-error TS2554 - throwIfNoEntry is only available in recent version of node, but inclusion of the option is a backward compatible no-op.\n    stat = fs.statSync(path, {throwIfNoEntry: false});\n  } catch (e: any) {\n    if (!(e && (e.code === 'ENOENT' || e.code === 'ENOTDIR'))) {\n      throw e;\n    }\n  }\n\n  if (stat) {\n    if (stat.isFile() || stat.isFIFO()) {\n      checkedPaths.set(path, IPathType.FILE);\n      return IPathType.FILE;\n    } else if (stat.isDirectory()) {\n      checkedPaths.set(path, IPathType.DIRECTORY);\n      return IPathType.DIRECTORY;\n    }\n  }\n\n  checkedPaths.set(path, IPathType.OTHER);\n  return IPathType.OTHER;\n}\n\nconst checkedRealpathPaths = new Map<string, string>();\nfunction realpathCached(path: string): string {\n  let result = checkedRealpathPaths.get(path);\n\n  if (result != null) {\n    return result;\n  }\n\n  result = tryRealpath(path);\n\n  checkedRealpathPaths.set(path, result);\n\n  if (path !== result) {\n    // also cache the result in case it's ever referenced directly - no reason to `realpath` that as well\n    checkedRealpathPaths.set(result, result);\n  }\n\n  return result;\n}\n\nconst packageContents = new Map<string, PackageJSON>();\nexport function readPackageCached(path: string): PackageJSON {\n  let result = packageContents.get(path);\n\n  if (result != null) {\n    return result;\n  }\n\n  result = JSON.parse(fs.readFileSync(path, 'utf8')) as PackageJSON;\n\n  packageContents.set(path, result);\n\n  return result;\n}\n\n// adapted from\n// https://github.com/lukeed/escalade/blob/2477005062cdbd8407afc90d3f48f4930354252b/src/sync.js\n// to use cached `fs` calls\nexport function findClosestPackageJson(start: string): string | undefined {\n  let dir = resolve('.', start);\n  if (!isDirectory(dir)) {\n    dir = dirname(dir);\n  }\n\n  while (true) {\n    const pkgJsonFile = resolve(dir, './package.json');\n    const hasPackageJson = isFile(pkgJsonFile);\n\n    if (hasPackageJson) {\n      return pkgJsonFile;\n    }\n\n    const prevDir = dir;\n    dir = dirname(dir);\n\n    if (prevDir === dir) {\n      return undefined;\n    }\n  }\n}\n\n/*\n * helper functions\n */\nexport function isFile(file: string): boolean {\n  return statSyncCached(file) === IPathType.FILE;\n}\n\nexport function isDirectory(dir: string): boolean {\n  return statSyncCached(dir) === IPathType.DIRECTORY;\n}\n\nexport function realpathSync(file: string): string {\n  return realpathCached(file);\n}\n","/Users/simen/repos/jest/packages/jest-resolve/src/index.ts",[],[],"/Users/simen/repos/jest/packages/jest-resolve/src/isBuiltinModule.ts",[],[],"/Users/simen/repos/jest/packages/jest-resolve/src/nodeModulesPaths.ts",["120"],[],"/**\n * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * Adapted from: https://github.com/substack/node-resolve\n */\n\nimport * as path from 'path';\nimport {tryRealpath} from 'jest-util';\n\ntype NodeModulesPathsOptions = {\n  moduleDirectory?: Array<string>;\n  paths?: Array<string>;\n};\n\nexport default function nodeModulesPaths(\n  basedir: string,\n  options: NodeModulesPathsOptions,\n): Array<string> {\n  const modules =\n    options && options.moduleDirectory\n      ? Array.from(options.moduleDirectory)\n      : ['node_modules'];\n\n  // ensure that `basedir` is an absolute path at this point,\n  // resolving against the process' current working directory\n  const basedirAbs = path.resolve(basedir);\n\n  let prefix = '/';\n  if (/^([A-Za-z]:)/.test(basedirAbs)) {\n    prefix = '';\n  } else if (/^\\\\\\\\/.test(basedirAbs)) {\n    prefix = '\\\\\\\\';\n  }\n\n  // The node resolution algorithm (as implemented by NodeJS and TypeScript)\n  // traverses parents of the physical path, not the symlinked path\n  let physicalBasedir;\n  try {\n    physicalBasedir = tryRealpath(basedirAbs);\n  } catch {\n    // realpath can throw, e.g. on mapped drives\n    physicalBasedir = basedirAbs;\n  }\n\n  const paths: Array<string> = [physicalBasedir];\n  let parsed = path.parse(physicalBasedir);\n  while (parsed.dir !== paths[paths.length - 1]) {\n    paths.push(parsed.dir);\n    parsed = path.parse(parsed.dir);\n  }\n\n  const dirs = paths\n    .reduce<Array<string>>(\n      (dirs, aPath) =>\n        dirs.concat(\n          modules.map(moduleDir =>\n            path.isAbsolute(moduleDir)\n              ? aPath === basedirAbs\n                ? moduleDir\n                : ''\n              : path.join(prefix, aPath, moduleDir),\n          ),\n        ),\n      [],\n    )\n    .filter(dir => dir !== '');\n\n  return options.paths ? dirs.concat(options.paths) : dirs;\n}\n","/Users/simen/repos/jest/packages/jest-resolve/src/resolver.ts",["121","122","123","124","125","126","127","128","129","130","131","132","133","134","135","136","137","138","139","140","141","142","143","144","145","146","147","148","149","150","151","152","153","154","155","156","157","158","159","160","161","162","163","164","165","166","167","168","169","170","171","172","173","174","175","176","177","178","179","180","181","182","183","184","185","186","187","188","189"],["190"],"/**\n * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n/* eslint-disable local/prefer-spread-eventually */\n\nimport * as path from 'path';\nimport chalk = require('chalk');\nimport slash = require('slash');\nimport type {IModuleMap} from 'jest-haste-map';\nimport {tryRealpath} from 'jest-util';\nimport ModuleNotFoundError from './ModuleNotFoundError';\nimport defaultResolver, {\n  AsyncResolver,\n  Resolver as ResolverInterface,\n  SyncResolver,\n} from './defaultResolver';\nimport {clearFsCache} from './fileWalkers';\nimport isBuiltinModule from './isBuiltinModule';\nimport nodeModulesPaths from './nodeModulesPaths';\nimport shouldLoadAsEsm, {clearCachedLookups} from './shouldLoadAsEsm';\nimport type {ResolverConfig} from './types';\n\nexport type FindNodeModuleConfig = {\n  basedir: string;\n  conditions?: Array<string>;\n  extensions?: Array<string>;\n  moduleDirectory?: Array<string>;\n  paths?: Array<string>;\n  resolver?: string | null;\n  rootDir?: string;\n  throwIfNotFound?: boolean;\n};\n\nexport type ResolveModuleConfig = {\n  conditions?: Array<string>;\n  skipNodeResolution?: boolean;\n  paths?: Array<string>;\n};\n\nconst NATIVE_PLATFORM = 'native';\n\n// We might be inside a symlink.\nconst resolvedCwd = tryRealpath(process.cwd());\nconst {NODE_PATH} = process.env;\nconst nodePaths = NODE_PATH\n  ? NODE_PATH.split(path.delimiter)\n      .filter(Boolean)\n      // The resolver expects absolute paths.\n      .map(p => path.resolve(resolvedCwd, p))\n  : undefined;\n\nexport default class Resolver {\n  private readonly _options: ResolverConfig;\n  private readonly _moduleMap: IModuleMap;\n  private readonly _moduleIDCache: Map<string, string>;\n  private readonly _moduleNameCache: Map<string, string>;\n  private readonly _modulePathCache: Map<string, Array<string>>;\n  private readonly _supportsNativePlatform: boolean;\n\n  constructor(moduleMap: IModuleMap, options: ResolverConfig) {\n    this._options = {\n      defaultPlatform: options.defaultPlatform,\n      extensions: options.extensions,\n      hasCoreModules:\n        options.hasCoreModules === undefined ? true : options.hasCoreModules,\n      moduleDirectories: options.moduleDirectories || ['node_modules'],\n      moduleNameMapper: options.moduleNameMapper,\n      modulePaths: options.modulePaths,\n      platforms: options.platforms,\n      resolver: options.resolver,\n      rootDir: options.rootDir,\n    };\n    this._supportsNativePlatform = options.platforms\n      ? options.platforms.includes(NATIVE_PLATFORM)\n      : false;\n    this._moduleMap = moduleMap;\n    this._moduleIDCache = new Map();\n    this._moduleNameCache = new Map();\n    this._modulePathCache = new Map();\n  }\n\n  static ModuleNotFoundError = ModuleNotFoundError;\n\n  static tryCastModuleNotFoundError(\n    error: unknown,\n  ): ModuleNotFoundError | null {\n    if (error instanceof ModuleNotFoundError) {\n      return error;\n    }\n\n    const casted = error as ModuleNotFoundError;\n    if (casted.code === 'MODULE_NOT_FOUND') {\n      return ModuleNotFoundError.duckType(casted);\n    }\n\n    return null;\n  }\n\n  static clearDefaultResolverCache(): void {\n    clearFsCache();\n    clearCachedLookups();\n  }\n\n  static findNodeModule(\n    path: string,\n    options: FindNodeModuleConfig,\n  ): string | null {\n    const resolverModule = loadResolver(options.resolver);\n    let resolver: SyncResolver = defaultResolver;\n\n    if (typeof resolverModule === 'function') {\n      resolver = resolverModule;\n    } else if (typeof resolverModule.sync === 'function') {\n      resolver = resolverModule.sync;\n    }\n\n    const paths = options.paths;\n\n    try {\n      return resolver(path, {\n        basedir: options.basedir,\n        conditions: options.conditions,\n        defaultResolver,\n        extensions: options.extensions,\n        moduleDirectory: options.moduleDirectory,\n        paths: paths ? (nodePaths || []).concat(paths) : nodePaths,\n        rootDir: options.rootDir,\n      });\n    } catch (e) {\n      if (options.throwIfNotFound) {\n        throw e;\n      }\n    }\n    return null;\n  }\n\n  static async findNodeModuleAsync(\n    path: string,\n    options: FindNodeModuleConfig,\n  ): Promise<string | null> {\n    const resolverModule = loadResolver(options.resolver);\n    let resolver: ResolverInterface = defaultResolver;\n\n    if (typeof resolverModule === 'function') {\n      resolver = resolverModule;\n    } else if (\n      typeof resolverModule.async === 'function' ||\n      typeof resolverModule.sync === 'function'\n    ) {\n      const asyncOrSync = resolverModule.async || resolverModule.sync;\n\n      if (asyncOrSync == null) {\n        throw new Error(`Unable to load resolver at ${options.resolver}`);\n      }\n\n      resolver = asyncOrSync;\n    }\n\n    const paths = options.paths;\n\n    try {\n      const result = await resolver(path, {\n        basedir: options.basedir,\n        conditions: options.conditions,\n        defaultResolver,\n        extensions: options.extensions,\n        moduleDirectory: options.moduleDirectory,\n        paths: paths ? (nodePaths || []).concat(paths) : nodePaths,\n        rootDir: options.rootDir,\n      });\n      return result;\n    } catch (e: unknown) {\n      if (options.throwIfNotFound) {\n        throw e;\n      }\n    }\n    return null;\n  }\n\n  // unstable as it should be replaced by https://github.com/nodejs/modules/issues/393, and we don't want people to use it\n  static unstable_shouldLoadAsEsm = shouldLoadAsEsm;\n\n  resolveModuleFromDirIfExists(\n    dirname: string,\n    moduleName: string,\n    options?: ResolveModuleConfig,\n  ): string | null {\n    const {extensions, key, moduleDirectory, paths, skipResolution} =\n      this._prepareForResolution(dirname, moduleName, options);\n\n    let module;\n\n    // 1. If we have already resolved this module for this directory name,\n    // return a value from the cache.\n    const cacheResult = this._moduleNameCache.get(key);\n    if (cacheResult) {\n      return cacheResult;\n    }\n\n    // 2. Check if the module is a haste module.\n    module = this.getModule(moduleName);\n    if (module) {\n      this._moduleNameCache.set(key, module);\n      return module;\n    }\n\n    // 3. Check if the module is a node module and resolve it based on\n    // the node module resolution algorithm. If skipNodeResolution is given we\n    // ignore all modules that look like node modules (ie. are not relative\n    // requires). This enables us to speed up resolution when we build a\n    // dependency graph because we don't have to look at modules that may not\n    // exist and aren't mocked.\n    const resolveNodeModule = (name: string, throwIfNotFound = false) => {\n      // Only skip default resolver\n      if (this.isCoreModule(name) && !this._options.resolver) {\n        return name;\n      }\n\n      return Resolver.findNodeModule(name, {\n        basedir: dirname,\n        conditions: options?.conditions,\n        extensions,\n        moduleDirectory,\n        paths,\n        resolver: this._options.resolver,\n        rootDir: this._options.rootDir,\n        throwIfNotFound,\n      });\n    };\n\n    if (!skipResolution) {\n      module = resolveNodeModule(moduleName, Boolean(process.versions.pnp));\n\n      if (module) {\n        this._moduleNameCache.set(key, module);\n        return module;\n      }\n    }\n\n    // 4. Resolve \"haste packages\" which are `package.json` files outside of\n    // `node_modules` folders anywhere in the file system.\n    try {\n      const hasteModulePath = this._getHasteModulePath(moduleName);\n      if (hasteModulePath) {\n        // try resolving with custom resolver first to support extensions,\n        // then fallback to require.resolve\n        const resolvedModule =\n          resolveNodeModule(hasteModulePath) ||\n          require.resolve(hasteModulePath);\n        this._moduleNameCache.set(key, resolvedModule);\n        return resolvedModule;\n      }\n    } catch {}\n\n    return null;\n  }\n\n  async resolveModuleFromDirIfExistsAsync(\n    dirname: string,\n    moduleName: string,\n    options?: ResolveModuleConfig,\n  ): Promise<string | null> {\n    const {extensions, key, moduleDirectory, paths, skipResolution} =\n      this._prepareForResolution(dirname, moduleName, options);\n\n    let module;\n\n    // 1. If we have already resolved this module for this directory name,\n    // return a value from the cache.\n    const cacheResult = this._moduleNameCache.get(key);\n    if (cacheResult) {\n      return cacheResult;\n    }\n\n    // 2. Check if the module is a haste module.\n    module = this.getModule(moduleName);\n    if (module) {\n      this._moduleNameCache.set(key, module);\n      return module;\n    }\n\n    // 3. Check if the module is a node module and resolve it based on\n    // the node module resolution algorithm. If skipNodeResolution is given we\n    // ignore all modules that look like node modules (ie. are not relative\n    // requires). This enables us to speed up resolution when we build a\n    // dependency graph because we don't have to look at modules that may not\n    // exist and aren't mocked.\n    const resolveNodeModule = async (name: string, throwIfNotFound = false) => {\n      // Only skip default resolver\n      if (this.isCoreModule(name) && !this._options.resolver) {\n        return name;\n      }\n\n      return Resolver.findNodeModuleAsync(name, {\n        basedir: dirname,\n        conditions: options?.conditions,\n        extensions,\n        moduleDirectory,\n        paths,\n        resolver: this._options.resolver,\n        rootDir: this._options.rootDir,\n        throwIfNotFound,\n      });\n    };\n\n    if (!skipResolution) {\n      module = await resolveNodeModule(\n        moduleName,\n        Boolean(process.versions.pnp),\n      );\n\n      if (module) {\n        this._moduleNameCache.set(key, module);\n        return module;\n      }\n    }\n\n    // 4. Resolve \"haste packages\" which are `package.json` files outside of\n    // `node_modules` folders anywhere in the file system.\n    try {\n      const hasteModulePath = this._getHasteModulePath(moduleName);\n      if (hasteModulePath) {\n        // try resolving with custom resolver first to support extensions,\n        // then fallback to require.resolve\n        const resolvedModule =\n          (await resolveNodeModule(hasteModulePath)) ||\n          // QUESTION: should this be async?\n          require.resolve(hasteModulePath);\n        this._moduleNameCache.set(key, resolvedModule);\n        return resolvedModule;\n      }\n    } catch {}\n\n    return null;\n  }\n\n  resolveModule(\n    from: string,\n    moduleName: string,\n    options?: ResolveModuleConfig,\n  ): string {\n    const dirname = path.dirname(from);\n    const module =\n      this.resolveStubModuleName(from, moduleName) ||\n      this.resolveModuleFromDirIfExists(dirname, moduleName, options);\n    if (module) return module;\n\n    // 5. Throw an error if the module could not be found. `resolve.sync` only\n    // produces an error based on the dirname but we have the actual current\n    // module name available.\n    this._throwModNotFoundError(from, moduleName);\n  }\n\n  async resolveModuleAsync(\n    from: string,\n    moduleName: string,\n    options?: ResolveModuleConfig,\n  ): Promise<string> {\n    const dirname = path.dirname(from);\n    const module =\n      (await this.resolveStubModuleNameAsync(from, moduleName)) ||\n      (await this.resolveModuleFromDirIfExistsAsync(\n        dirname,\n        moduleName,\n        options,\n      ));\n\n    if (module) return module;\n\n    // 5. Throw an error if the module could not be found. `resolve` only\n    // produces an error based on the dirname but we have the actual current\n    // module name available.\n    this._throwModNotFoundError(from, moduleName);\n  }\n\n  /**\n   * _prepareForResolution is shared between the sync and async module resolution\n   * methods, to try to keep them as DRY as possible.\n   */\n  private _prepareForResolution(\n    dirname: string,\n    moduleName: string,\n    options?: ResolveModuleConfig,\n  ) {\n    const paths = options?.paths || this._options.modulePaths;\n    const moduleDirectory = this._options.moduleDirectories;\n    const stringifiedOptions = options ? JSON.stringify(options) : '';\n    const key = dirname + path.delimiter + moduleName + stringifiedOptions;\n    const defaultPlatform = this._options.defaultPlatform;\n    const extensions = this._options.extensions.slice();\n\n    if (this._supportsNativePlatform) {\n      extensions.unshift(\n        ...this._options.extensions.map(ext => `.${NATIVE_PLATFORM}${ext}`),\n      );\n    }\n    if (defaultPlatform) {\n      extensions.unshift(\n        ...this._options.extensions.map(ext => `.${defaultPlatform}${ext}`),\n      );\n    }\n\n    const skipResolution =\n      options && options.skipNodeResolution && !moduleName.includes(path.sep);\n\n    return {extensions, key, moduleDirectory, paths, skipResolution};\n  }\n\n  /**\n   * _getHasteModulePath attempts to return the path to a haste module.\n   */\n  private _getHasteModulePath(moduleName: string) {\n    const parts = moduleName.split('/');\n    const hastePackage = this.getPackage(parts.shift()!);\n    if (hastePackage) {\n      return path.join.apply(path, [path.dirname(hastePackage)].concat(parts));\n    }\n    return null;\n  }\n\n  private _throwModNotFoundError(from: string, moduleName: string): never {\n    const relativePath =\n      slash(path.relative(this._options.rootDir, from)) || '.';\n\n    throw new ModuleNotFoundError(\n      `Cannot find module '${moduleName}' from '${relativePath}'`,\n      moduleName,\n    );\n  }\n\n  private _getMapModuleName(matches: RegExpMatchArray | null) {\n    return matches\n      ? (moduleName: string) =>\n          moduleName.replace(\n            /\\$([0-9]+)/g,\n            (_, index) => matches[parseInt(index, 10)],\n          )\n      : (moduleName: string) => moduleName;\n  }\n\n  private _isAliasModule(moduleName: string): boolean {\n    const moduleNameMapper = this._options.moduleNameMapper;\n    if (!moduleNameMapper) {\n      return false;\n    }\n\n    return moduleNameMapper.some(({regex}) => regex.test(moduleName));\n  }\n\n  isCoreModule(moduleName: string): boolean {\n    return (\n      this._options.hasCoreModules &&\n      (isBuiltinModule(moduleName) ||\n        (moduleName.startsWith('node:') &&\n          isBuiltinModule(moduleName.slice('node:'.length)))) &&\n      !this._isAliasModule(moduleName)\n    );\n  }\n\n  getModule(name: string): string | null {\n    return this._moduleMap.getModule(\n      name,\n      this._options.defaultPlatform,\n      this._supportsNativePlatform,\n    );\n  }\n\n  getModulePath(from: string, moduleName: string): string {\n    if (moduleName[0] !== '.' || path.isAbsolute(moduleName)) {\n      return moduleName;\n    }\n    return path.normalize(`${path.dirname(from)}/${moduleName}`);\n  }\n\n  getPackage(name: string): string | null {\n    return this._moduleMap.getPackage(\n      name,\n      this._options.defaultPlatform,\n      this._supportsNativePlatform,\n    );\n  }\n\n  getMockModule(from: string, name: string): string | null {\n    const mock = this._moduleMap.getMockModule(name);\n    if (mock) {\n      return mock;\n    } else {\n      const moduleName = this.resolveStubModuleName(from, name);\n      if (moduleName) {\n        return this.getModule(moduleName) || moduleName;\n      }\n    }\n    return null;\n  }\n\n  async getMockModuleAsync(from: string, name: string): Promise<string | null> {\n    const mock = this._moduleMap.getMockModule(name);\n    if (mock) {\n      return mock;\n    } else {\n      const moduleName = await this.resolveStubModuleNameAsync(from, name);\n      if (moduleName) {\n        return this.getModule(moduleName) || moduleName;\n      }\n    }\n    return null;\n  }\n\n  getModulePaths(from: string): Array<string> {\n    const cachedModule = this._modulePathCache.get(from);\n    if (cachedModule) {\n      return cachedModule;\n    }\n\n    const moduleDirectory = this._options.moduleDirectories;\n    const paths = nodeModulesPaths(from, {moduleDirectory});\n    if (paths[paths.length - 1] === undefined) {\n      // circumvent node-resolve bug that adds `undefined` as last item.\n      paths.pop();\n    }\n    this._modulePathCache.set(from, paths);\n    return paths;\n  }\n\n  getModuleID(\n    virtualMocks: Map<string, boolean>,\n    from: string,\n    moduleName = '',\n    options?: ResolveModuleConfig,\n  ): string {\n    const stringifiedOptions = options ? JSON.stringify(options) : '';\n    const key = from + path.delimiter + moduleName + stringifiedOptions;\n    const cachedModuleID = this._moduleIDCache.get(key);\n    if (cachedModuleID) {\n      return cachedModuleID;\n    }\n\n    const moduleType = this._getModuleType(moduleName);\n    const absolutePath = this._getAbsolutePath(\n      virtualMocks,\n      from,\n      moduleName,\n      options,\n    );\n    const mockPath = this._getMockPath(from, moduleName);\n\n    const sep = path.delimiter;\n    const id =\n      moduleType +\n      sep +\n      (absolutePath ? absolutePath + sep : '') +\n      (mockPath ? mockPath + sep : '') +\n      (stringifiedOptions ? stringifiedOptions + sep : '');\n\n    this._moduleIDCache.set(key, id);\n    return id;\n  }\n\n  async getModuleIDAsync(\n    virtualMocks: Map<string, boolean>,\n    from: string,\n    moduleName = '',\n    options?: ResolveModuleConfig,\n  ): Promise<string> {\n    const stringifiedOptions = options ? JSON.stringify(options) : '';\n    const key = from + path.delimiter + moduleName + stringifiedOptions;\n    const cachedModuleID = this._moduleIDCache.get(key);\n    if (cachedModuleID) {\n      return cachedModuleID;\n    }\n    if (moduleName.startsWith('data:')) {\n      return moduleName;\n    }\n\n    const moduleType = this._getModuleType(moduleName);\n    const absolutePath = await this._getAbsolutePathAsync(\n      virtualMocks,\n      from,\n      moduleName,\n      options,\n    );\n    const mockPath = await this._getMockPathAsync(from, moduleName);\n\n    const sep = path.delimiter;\n    const id =\n      moduleType +\n      sep +\n      (absolutePath ? absolutePath + sep : '') +\n      (mockPath ? mockPath + sep : '') +\n      (stringifiedOptions ? stringifiedOptions + sep : '');\n\n    this._moduleIDCache.set(key, id);\n    return id;\n  }\n\n  private _getModuleType(moduleName: string): 'node' | 'user' {\n    return this.isCoreModule(moduleName) ? 'node' : 'user';\n  }\n\n  private _getAbsolutePath(\n    virtualMocks: Map<string, boolean>,\n    from: string,\n    moduleName: string,\n    options?: ResolveModuleConfig,\n  ): string | null {\n    if (this.isCoreModule(moduleName)) {\n      return moduleName;\n    }\n    if (moduleName.startsWith('data:')) {\n      return moduleName;\n    }\n    return this._isModuleResolved(from, moduleName)\n      ? this.getModule(moduleName)\n      : this._getVirtualMockPath(virtualMocks, from, moduleName, options);\n  }\n\n  private async _getAbsolutePathAsync(\n    virtualMocks: Map<string, boolean>,\n    from: string,\n    moduleName: string,\n    options?: ResolveModuleConfig,\n  ): Promise<string | null> {\n    if (this.isCoreModule(moduleName)) {\n      return moduleName;\n    }\n    if (moduleName.startsWith('data:')) {\n      return moduleName;\n    }\n    const isModuleResolved = await this._isModuleResolvedAsync(\n      from,\n      moduleName,\n    );\n    return isModuleResolved\n      ? this.getModule(moduleName)\n      : this._getVirtualMockPathAsync(virtualMocks, from, moduleName, options);\n  }\n\n  private _getMockPath(from: string, moduleName: string): string | null {\n    return !this.isCoreModule(moduleName)\n      ? this.getMockModule(from, moduleName)\n      : null;\n  }\n\n  private async _getMockPathAsync(\n    from: string,\n    moduleName: string,\n  ): Promise<string | null> {\n    return !this.isCoreModule(moduleName)\n      ? this.getMockModuleAsync(from, moduleName)\n      : null;\n  }\n\n  private _getVirtualMockPath(\n    virtualMocks: Map<string, boolean>,\n    from: string,\n    moduleName: string,\n    options?: ResolveModuleConfig,\n  ): string {\n    const virtualMockPath = this.getModulePath(from, moduleName);\n    return virtualMocks.get(virtualMockPath)\n      ? virtualMockPath\n      : moduleName\n      ? this.resolveModule(from, moduleName, options)\n      : from;\n  }\n\n  private async _getVirtualMockPathAsync(\n    virtualMocks: Map<string, boolean>,\n    from: string,\n    moduleName: string,\n    options?: ResolveModuleConfig,\n  ): Promise<string> {\n    const virtualMockPath = this.getModulePath(from, moduleName);\n    return virtualMocks.get(virtualMockPath)\n      ? virtualMockPath\n      : moduleName\n      ? this.resolveModuleAsync(from, moduleName, options)\n      : from;\n  }\n\n  private _isModuleResolved(from: string, moduleName: string): boolean {\n    return !!(\n      this.getModule(moduleName) || this.getMockModule(from, moduleName)\n    );\n  }\n\n  private async _isModuleResolvedAsync(\n    from: string,\n    moduleName: string,\n  ): Promise<boolean> {\n    return !!(\n      this.getModule(moduleName) ||\n      (await this.getMockModuleAsync(from, moduleName))\n    );\n  }\n\n  resolveStubModuleName(from: string, moduleName: string): string | null {\n    const dirname = path.dirname(from);\n\n    const {extensions, moduleDirectory, paths} = this._prepareForResolution(\n      dirname,\n      moduleName,\n    );\n    const moduleNameMapper = this._options.moduleNameMapper;\n    const resolver = this._options.resolver;\n\n    if (moduleNameMapper) {\n      for (const {moduleName: mappedModuleName, regex} of moduleNameMapper) {\n        if (regex.test(moduleName)) {\n          // Note: once a moduleNameMapper matches the name, it must result\n          // in a module, or else an error is thrown.\n          const matches = moduleName.match(regex);\n          const mapModuleName = this._getMapModuleName(matches);\n          const possibleModuleNames = Array.isArray(mappedModuleName)\n            ? mappedModuleName\n            : [mappedModuleName];\n          let module: string | null = null;\n          for (const possibleModuleName of possibleModuleNames) {\n            const updatedName = mapModuleName(possibleModuleName);\n\n            module =\n              this.getModule(updatedName) ||\n              Resolver.findNodeModule(updatedName, {\n                basedir: dirname,\n                extensions,\n                moduleDirectory,\n                paths,\n                resolver,\n                rootDir: this._options.rootDir,\n              });\n\n            if (module) {\n              break;\n            }\n          }\n\n          if (!module) {\n            throw createNoMappedModuleFoundError(\n              moduleName,\n              mapModuleName,\n              mappedModuleName,\n              regex,\n              resolver,\n            );\n          }\n          return module;\n        }\n      }\n    }\n    return null;\n  }\n\n  async resolveStubModuleNameAsync(\n    from: string,\n    moduleName: string,\n  ): Promise<string | null> {\n    const dirname = path.dirname(from);\n\n    const {extensions, moduleDirectory, paths} = this._prepareForResolution(\n      dirname,\n      moduleName,\n    );\n    const moduleNameMapper = this._options.moduleNameMapper;\n    const resolver = this._options.resolver;\n\n    if (moduleNameMapper) {\n      for (const {moduleName: mappedModuleName, regex} of moduleNameMapper) {\n        if (regex.test(moduleName)) {\n          // Note: once a moduleNameMapper matches the name, it must result\n          // in a module, or else an error is thrown.\n          const matches = moduleName.match(regex);\n          const mapModuleName = this._getMapModuleName(matches);\n          const possibleModuleNames = Array.isArray(mappedModuleName)\n            ? mappedModuleName\n            : [mappedModuleName];\n          let module: string | null = null;\n          for (const possibleModuleName of possibleModuleNames) {\n            const updatedName = mapModuleName(possibleModuleName);\n\n            module =\n              this.getModule(updatedName) ||\n              (await Resolver.findNodeModuleAsync(updatedName, {\n                basedir: dirname,\n                extensions,\n                moduleDirectory,\n                paths,\n                resolver,\n                rootDir: this._options.rootDir,\n              }));\n\n            if (module) {\n              break;\n            }\n          }\n\n          if (!module) {\n            throw createNoMappedModuleFoundError(\n              moduleName,\n              mapModuleName,\n              mappedModuleName,\n              regex,\n              resolver,\n            );\n          }\n          return module;\n        }\n      }\n    }\n    return null;\n  }\n}\n\nconst createNoMappedModuleFoundError = (\n  moduleName: string,\n  mapModuleName: (moduleName: string) => string,\n  mappedModuleName: string | Array<string>,\n  regex: RegExp,\n  resolver?: ((...args: Array<unknown>) => unknown) | string | null,\n) => {\n  const mappedAs = Array.isArray(mappedModuleName)\n    ? JSON.stringify(mappedModuleName.map(mapModuleName), null, 2)\n    : mappedModuleName;\n  const original = Array.isArray(mappedModuleName)\n    ? `${\n        JSON.stringify(mappedModuleName, null, 6) // using 6 because of misalignment when nested below\n          .slice(0, -1) + ' '.repeat(4)\n      }]` /// align last bracket correctly as well\n    : mappedModuleName;\n\n  const error = new Error(\n    chalk.red(`${chalk.bold('Configuration error')}:\n\nCould not locate module ${chalk.bold(moduleName)} mapped as:\n${chalk.bold(mappedAs)}.\n\nPlease check your configuration for these entries:\n{\n  \"moduleNameMapper\": {\n    \"${regex.toString()}\": \"${chalk.bold(original)}\"\n  },\n  \"resolver\": ${chalk.bold(String(resolver))}\n}`),\n  );\n\n  error.name = '';\n\n  return error;\n};\n\ntype ResolverSyncObject = {sync: SyncResolver; async?: AsyncResolver};\ntype ResolverAsyncObject = {sync?: SyncResolver; async: AsyncResolver};\nexport type ResolverObject = ResolverSyncObject | ResolverAsyncObject;\n\nfunction loadResolver(\n  resolver: string | undefined | null,\n): SyncResolver | ResolverObject {\n  if (resolver == null) {\n    return defaultResolver;\n  }\n\n  const loadedResolver = require(resolver);\n\n  if (loadedResolver == null) {\n    throw new Error(`Resolver located at ${resolver} does not export anything`);\n  }\n\n  if (typeof loadedResolver === 'function') {\n    return loadedResolver as SyncResolver;\n  }\n\n  if (\n    typeof loadedResolver === 'object' &&\n    (loadedResolver.sync != null || loadedResolver.async != null)\n  ) {\n    return loadedResolver as ResolverObject;\n  }\n\n  throw new Error(\n    `Resolver located at ${resolver} does not export a function or an object with \"sync\" and \"async\" props`,\n  );\n}\n","/Users/simen/repos/jest/packages/jest-resolve/src/shouldLoadAsEsm.ts",["191"],[],"/**\n * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport {dirname, extname} from 'path';\n// @ts-expect-error: experimental, not added to the types\nimport {SyntheticModule} from 'vm';\nimport {findClosestPackageJson, readPackageCached} from './fileWalkers';\n\nconst runtimeSupportsVmModules = typeof SyntheticModule === 'function';\n\nconst cachedFileLookups = new Map<string, boolean>();\nconst cachedDirLookups = new Map<string, boolean>();\nconst cachedChecks = new Map<string, boolean>();\n\nexport function clearCachedLookups(): void {\n  cachedFileLookups.clear();\n  cachedDirLookups.clear();\n  cachedChecks.clear();\n}\n\nexport default function cachedShouldLoadAsEsm(\n  path: string,\n  extensionsToTreatAsEsm: Array<string>,\n): boolean {\n  if (!runtimeSupportsVmModules) {\n    return false;\n  }\n\n  let cachedLookup = cachedFileLookups.get(path);\n\n  if (cachedLookup === undefined) {\n    cachedLookup = shouldLoadAsEsm(path, extensionsToTreatAsEsm);\n    cachedFileLookups.set(path, cachedLookup);\n  }\n\n  return cachedLookup;\n}\n\n// this is a bad version of what https://github.com/nodejs/modules/issues/393 would provide\nfunction shouldLoadAsEsm(\n  path: string,\n  extensionsToTreatAsEsm: Array<string>,\n): boolean {\n  const extension = extname(path);\n\n  if (extension === '.mjs') {\n    return true;\n  }\n\n  if (extension === '.cjs') {\n    return false;\n  }\n\n  if (extension !== '.js') {\n    return extensionsToTreatAsEsm.includes(extension);\n  }\n\n  const cwd = dirname(path);\n\n  let cachedLookup = cachedDirLookups.get(cwd);\n\n  if (cachedLookup === undefined) {\n    cachedLookup = cachedPkgCheck(cwd);\n    cachedFileLookups.set(cwd, cachedLookup);\n  }\n\n  return cachedLookup;\n}\n\nfunction cachedPkgCheck(cwd: string): boolean {\n  const pkgPath = findClosestPackageJson(cwd);\n  if (!pkgPath) {\n    return false;\n  }\n\n  let hasModuleField = cachedChecks.get(pkgPath);\n  if (hasModuleField != null) {\n    return hasModuleField;\n  }\n\n  try {\n    const pkg = readPackageCached(pkgPath);\n    hasModuleField = pkg.type === 'module';\n  } catch {\n    hasModuleField = false;\n  }\n\n  cachedChecks.set(pkgPath, hasModuleField);\n  return hasModuleField;\n}\n","/Users/simen/repos/jest/packages/jest-resolve/src/types.ts",[],[],"/Users/simen/repos/jest/packages/jest-resolve/src/utils.ts",["192","193","194","195","196","197","198"],[],"/**\n * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport * as path from 'path';\nimport chalk = require('chalk');\nimport {ValidationError} from 'jest-validate';\nimport Resolver from './resolver';\n\nconst BULLET: string = chalk.bold('\\u25cf ');\nconst DOCUMENTATION_NOTE = `  ${chalk.bold('Configuration Documentation:')}\n  https://jestjs.io/docs/configuration\n`;\n\nconst createValidationError = (message: string) =>\n  new ValidationError(`${BULLET}Validation Error`, message, DOCUMENTATION_NOTE);\n\nconst replaceRootDirInPath = (rootDir: string, filePath: string): string => {\n  if (!/^<rootDir>/.test(filePath)) {\n    return filePath;\n  }\n\n  return path.resolve(\n    rootDir,\n    path.normalize(`./${filePath.substr('<rootDir>'.length)}`),\n  );\n};\n\nconst resolveWithPrefix = (\n  resolver: string | undefined | null,\n  {\n    filePath,\n    humanOptionName,\n    optionName,\n    prefix,\n    requireResolveFunction,\n    rootDir,\n  }: {\n    filePath: string;\n    humanOptionName: string;\n    optionName: string;\n    prefix: string;\n    requireResolveFunction: (moduleName: string) => string;\n    rootDir: string;\n  },\n): string => {\n  const fileName = replaceRootDirInPath(rootDir, filePath);\n  let module = Resolver.findNodeModule(`${prefix}${fileName}`, {\n    basedir: rootDir,\n    resolver: resolver || undefined,\n  });\n  if (module) {\n    return module;\n  }\n\n  try {\n    return requireResolveFunction(`${prefix}${fileName}`);\n  } catch {}\n\n  module = Resolver.findNodeModule(fileName, {\n    basedir: rootDir,\n    resolver: resolver || undefined,\n  });\n  if (module) {\n    return module;\n  }\n\n  try {\n    return requireResolveFunction(fileName);\n  } catch {}\n\n  throw createValidationError(\n    `  ${humanOptionName} ${chalk.bold(\n      fileName,\n    )} cannot be found. Make sure the ${chalk.bold(\n      optionName,\n    )} configuration option points to an existing node module.`,\n  );\n};\n\n/**\n * Finds the test environment to use:\n *\n * 1. looks for jest-environment-<name> relative to project.\n * 1. looks for jest-environment-<name> relative to Jest.\n * 1. looks for <name> relative to project.\n * 1. looks for <name> relative to Jest.\n */\nexport const resolveTestEnvironment = ({\n  rootDir,\n  testEnvironment: filePath,\n  requireResolveFunction,\n}: {\n  rootDir: string;\n  testEnvironment: string;\n  requireResolveFunction: (moduleName: string) => string;\n}): string => {\n  // we don't want to resolve the actual `jsdom` module if `jest-environment-jsdom` is not installed, but `jsdom` package is\n  if (filePath === 'jsdom') {\n    filePath = 'jest-environment-jsdom';\n  }\n\n  try {\n    return resolveWithPrefix(undefined, {\n      filePath,\n      humanOptionName: 'Test environment',\n      optionName: 'testEnvironment',\n      prefix: 'jest-environment-',\n      requireResolveFunction,\n      rootDir,\n    });\n  } catch (error: any) {\n    if (filePath === 'jest-environment-jsdom') {\n      error.message +=\n        '\\n\\nAs of Jest 28 \"jest-environment-jsdom\" is no longer shipped by default, make sure to install it separately.';\n    }\n\n    throw error;\n  }\n};\n\n/**\n * Finds the watch plugins to use:\n *\n * 1. looks for jest-watch-<name> relative to project.\n * 1. looks for jest-watch-<name> relative to Jest.\n * 1. looks for <name> relative to project.\n * 1. looks for <name> relative to Jest.\n */\nexport const resolveWatchPlugin = (\n  resolver: string | undefined | null,\n  {\n    filePath,\n    rootDir,\n    requireResolveFunction,\n  }: {\n    filePath: string;\n    rootDir: string;\n    requireResolveFunction: (moduleName: string) => string;\n  },\n): string =>\n  resolveWithPrefix(resolver, {\n    filePath,\n    humanOptionName: 'Watch plugin',\n    optionName: 'watchPlugins',\n    prefix: 'jest-watch-',\n    requireResolveFunction,\n    rootDir,\n  });\n\n/**\n * Finds the runner to use:\n *\n * 1. looks for jest-runner-<name> relative to project.\n * 1. looks for jest-runner-<name> relative to Jest.\n * 1. looks for <name> relative to project.\n * 1. looks for <name> relative to Jest.\n */\nexport const resolveRunner = (\n  resolver: string | undefined | null,\n  {\n    filePath,\n    rootDir,\n    requireResolveFunction,\n  }: {\n    filePath: string;\n    rootDir: string;\n    requireResolveFunction: (moduleName: string) => string;\n  },\n): string =>\n  resolveWithPrefix(resolver, {\n    filePath,\n    humanOptionName: 'Jest Runner',\n    optionName: 'runner',\n    prefix: 'jest-runner-',\n    requireResolveFunction,\n    rootDir,\n  });\n\nexport const resolveSequencer = (\n  resolver: string | undefined | null,\n  {\n    filePath,\n    rootDir,\n    requireResolveFunction,\n  }: {\n    filePath: string;\n    rootDir: string;\n    requireResolveFunction: (moduleName: string) => string;\n  },\n): string =>\n  resolveWithPrefix(resolver, {\n    filePath,\n    humanOptionName: 'Jest Sequencer',\n    optionName: 'testSequencer',\n    prefix: 'jest-sequencer-',\n    requireResolveFunction,\n    rootDir,\n  });\n",{"ruleId":"199","severity":2,"message":"200","line":27,"column":10,"nodeType":"201","messageId":"202","endLine":27,"endColumn":31,"suggestions":"203"},{"ruleId":"199","severity":2,"message":"204","line":33,"column":9,"nodeType":"205","messageId":"206","endLine":33,"endColumn":34,"suggestions":"207"},{"ruleId":"199","severity":2,"message":"200","line":44,"column":9,"nodeType":"201","messageId":"202","endLine":44,"endColumn":18,"suggestions":"208"},{"ruleId":"209","severity":2,"message":"210","line":52,"column":26,"nodeType":"201","messageId":"211","endLine":52,"endColumn":68},{"ruleId":"199","severity":2,"message":"200","line":106,"column":23,"nodeType":"201","messageId":"202","endLine":106,"endColumn":44,"suggestions":"212"},{"ruleId":"213","severity":2,"message":"214","line":131,"column":25,"nodeType":"215","messageId":"216","endLine":131,"endColumn":27,"suggestions":"217"},{"ruleId":"199","severity":2,"message":"200","line":325,"column":23,"nodeType":"201","messageId":"202","endLine":325,"endColumn":44,"suggestions":"218"},{"ruleId":"213","severity":2,"message":"214","line":350,"column":25,"nodeType":"215","messageId":"216","endLine":350,"endColumn":27,"suggestions":"219"},{"ruleId":"220","severity":2,"message":"221","line":672,"column":11,"nodeType":"222","messageId":"223","endLine":672,"endColumn":33},{"ruleId":"220","severity":2,"message":"221","line":673,"column":11,"nodeType":"222","messageId":"223","endLine":673,"endColumn":44},{"ruleId":"224","severity":2,"message":"225","line":673,"column":22,"nodeType":"201","messageId":"226","endLine":673,"endColumn":44},{"ruleId":"220","severity":2,"message":"221","line":677,"column":11,"nodeType":"222","messageId":"223","endLine":679,"endColumn":7},{"ruleId":"227","severity":2,"message":"228","line":677,"column":22,"nodeType":"229","messageId":"230","endLine":679,"endColumn":7},{"ruleId":"231","severity":2,"message":"232","line":683,"column":10,"nodeType":"233","messageId":"234","endLine":683,"endColumn":27},{"ruleId":"224","severity":2,"message":"235","line":683,"column":10,"nodeType":"201","messageId":"226","endLine":683,"endColumn":22},{"ruleId":"227","severity":2,"message":"236","line":683,"column":10,"nodeType":"201","messageId":"237","endLine":683,"endColumn":22},{"ruleId":"220","severity":2,"message":"221","line":686,"column":11,"nodeType":"222","messageId":"223","endLine":686,"endColumn":53},{"ruleId":"224","severity":2,"message":"238","line":686,"column":25,"nodeType":"201","messageId":"226","endLine":686,"endColumn":48},{"ruleId":"227","severity":2,"message":"236","line":686,"column":25,"nodeType":"201","messageId":"237","endLine":686,"endColumn":48},{"ruleId":"220","severity":2,"message":"221","line":692,"column":11,"nodeType":"222","messageId":"223","endLine":692,"endColumn":33},{"ruleId":"220","severity":2,"message":"221","line":693,"column":11,"nodeType":"222","messageId":"223","endLine":693,"endColumn":44},{"ruleId":"224","severity":2,"message":"225","line":693,"column":22,"nodeType":"201","messageId":"226","endLine":693,"endColumn":44},{"ruleId":"220","severity":2,"message":"221","line":697,"column":11,"nodeType":"222","messageId":"223","endLine":699,"endColumn":7},{"ruleId":"227","severity":2,"message":"228","line":697,"column":22,"nodeType":"229","messageId":"230","endLine":699,"endColumn":7},{"ruleId":"231","severity":2,"message":"232","line":703,"column":10,"nodeType":"233","messageId":"234","endLine":703,"endColumn":27},{"ruleId":"224","severity":2,"message":"235","line":703,"column":10,"nodeType":"201","messageId":"226","endLine":703,"endColumn":22},{"ruleId":"227","severity":2,"message":"236","line":703,"column":10,"nodeType":"201","messageId":"237","endLine":703,"endColumn":22},{"ruleId":"220","severity":2,"message":"221","line":706,"column":11,"nodeType":"222","messageId":"223","endLine":706,"endColumn":53},{"ruleId":"224","severity":2,"message":"238","line":706,"column":25,"nodeType":"201","messageId":"226","endLine":706,"endColumn":48},{"ruleId":"227","severity":2,"message":"236","line":706,"column":25,"nodeType":"201","messageId":"237","endLine":706,"endColumn":48},{"ruleId":"199","severity":2,"message":"200","line":143,"column":7,"nodeType":"239","messageId":"202","endLine":143,"endColumn":17,"suggestions":"240"},{"ruleId":"231","severity":2,"message":"241","line":146,"column":37,"nodeType":"233","messageId":"234","endLine":146,"endColumn":53},{"ruleId":"199","severity":2,"message":"200","line":151,"column":9,"nodeType":"239","messageId":"202","endLine":151,"endColumn":27,"suggestions":"242"},{"ruleId":"199","severity":2,"message":"243","line":154,"column":38,"nodeType":"201","messageId":"244","endLine":154,"endColumn":49},{"ruleId":"199","severity":2,"message":"200","line":163,"column":14,"nodeType":"239","messageId":"202","endLine":163,"endColumn":22,"suggestions":"245"},{"ruleId":"199","severity":2,"message":"243","line":184,"column":11,"nodeType":"201","messageId":"244","endLine":184,"endColumn":22},{"ruleId":"199","severity":2,"message":"200","line":193,"column":14,"nodeType":"239","messageId":"202","endLine":193,"endColumn":22,"suggestions":"246"},{"ruleId":"199","severity":2,"message":"247","line":36,"column":11,"nodeType":"239","messageId":"248","endLine":36,"endColumn":12,"suggestions":"249"},{"ruleId":"224","severity":2,"message":"250","line":36,"column":17,"nodeType":"201","messageId":"226","endLine":36,"endColumn":23},{"ruleId":"224","severity":2,"message":"250","line":36,"column":40,"nodeType":"201","messageId":"226","endLine":36,"endColumn":46},{"ruleId":"199","severity":2,"message":"251","line":23,"column":5,"nodeType":"239","messageId":"252","endLine":23,"endColumn":12},{"ruleId":"199","severity":2,"message":"200","line":49,"column":19,"nodeType":"239","messageId":"202","endLine":49,"endColumn":28,"suggestions":"253"},{"ruleId":"199","severity":2,"message":"251","line":70,"column":26,"nodeType":"201","messageId":"252","endLine":70,"endColumn":51},{"ruleId":"213","severity":2,"message":"214","line":130,"column":35,"nodeType":"215","messageId":"216","endLine":130,"endColumn":37,"suggestions":"254"},{"ruleId":"199","severity":2,"message":"255","line":134,"column":11,"nodeType":"201","messageId":"256","endLine":134,"endColumn":34,"suggestions":"257"},{"ruleId":"213","severity":2,"message":"214","line":154,"column":48,"nodeType":"215","messageId":"216","endLine":154,"endColumn":50,"suggestions":"258"},{"ruleId":"231","severity":2,"message":"259","line":157,"column":55,"nodeType":"201","messageId":"234","endLine":157,"endColumn":71},{"ruleId":"213","severity":2,"message":"214","line":172,"column":35,"nodeType":"215","messageId":"216","endLine":172,"endColumn":37,"suggestions":"260"},{"ruleId":"199","severity":2,"message":"255","line":177,"column":11,"nodeType":"201","messageId":"256","endLine":177,"endColumn":34,"suggestions":"261"},{"ruleId":"199","severity":2,"message":"200","line":200,"column":9,"nodeType":"239","messageId":"202","endLine":200,"endColumn":20,"suggestions":"262"},{"ruleId":"199","severity":2,"message":"200","line":206,"column":9,"nodeType":"239","messageId":"202","endLine":206,"endColumn":15,"suggestions":"263"},{"ruleId":"199","severity":2,"message":"200","line":219,"column":39,"nodeType":"201","messageId":"202","endLine":219,"endColumn":61,"suggestions":"264"},{"ruleId":"199","severity":2,"message":"255","line":235,"column":10,"nodeType":"239","messageId":"256","endLine":235,"endColumn":24,"suggestions":"265"},{"ruleId":"199","severity":2,"message":"200","line":238,"column":11,"nodeType":"239","messageId":"202","endLine":238,"endColumn":17,"suggestions":"266"},{"ruleId":"199","severity":2,"message":"200","line":248,"column":11,"nodeType":"239","messageId":"202","endLine":248,"endColumn":26,"suggestions":"267"},{"ruleId":"199","severity":2,"message":"200","line":252,"column":11,"nodeType":"233","messageId":"202","endLine":252,"endColumn":45,"suggestions":"268"},{"ruleId":"213","severity":2,"message":"214","line":252,"column":46,"nodeType":"215","messageId":"216","endLine":252,"endColumn":48,"suggestions":"269"},{"ruleId":"199","severity":2,"message":"200","line":275,"column":9,"nodeType":"239","messageId":"202","endLine":275,"endColumn":20,"suggestions":"270"},{"ruleId":"199","severity":2,"message":"200","line":281,"column":9,"nodeType":"239","messageId":"202","endLine":281,"endColumn":15,"suggestions":"271"},{"ruleId":"199","severity":2,"message":"200","line":294,"column":39,"nodeType":"201","messageId":"202","endLine":294,"endColumn":61,"suggestions":"272"},{"ruleId":"199","severity":2,"message":"255","line":310,"column":10,"nodeType":"239","messageId":"256","endLine":310,"endColumn":24,"suggestions":"273"},{"ruleId":"199","severity":2,"message":"200","line":316,"column":11,"nodeType":"239","messageId":"202","endLine":316,"endColumn":17,"suggestions":"274"},{"ruleId":"199","severity":2,"message":"200","line":326,"column":11,"nodeType":"239","messageId":"202","endLine":326,"endColumn":26,"suggestions":"275"},{"ruleId":"199","severity":2,"message":"200","line":330,"column":12,"nodeType":"276","messageId":"202","endLine":330,"endColumn":52,"suggestions":"277"},{"ruleId":"213","severity":2,"message":"214","line":330,"column":54,"nodeType":"215","messageId":"216","endLine":330,"endColumn":56,"suggestions":"278"},{"ruleId":"199","severity":2,"message":"200","line":348,"column":7,"nodeType":"233","messageId":"202","endLine":348,"endColumn":51,"suggestions":"279"},{"ruleId":"213","severity":2,"message":"214","line":348,"column":52,"nodeType":"215","messageId":"216","endLine":348,"endColumn":54,"suggestions":"280"},{"ruleId":"199","severity":2,"message":"200","line":350,"column":9,"nodeType":"239","messageId":"202","endLine":350,"endColumn":15,"suggestions":"281"},{"ruleId":"199","severity":2,"message":"200","line":365,"column":8,"nodeType":"276","messageId":"202","endLine":365,"endColumn":63,"suggestions":"282"},{"ruleId":"213","severity":2,"message":"214","line":365,"column":65,"nodeType":"215","messageId":"216","endLine":365,"endColumn":67,"suggestions":"283"},{"ruleId":"199","severity":2,"message":"200","line":372,"column":9,"nodeType":"239","messageId":"202","endLine":372,"endColumn":15,"suggestions":"284"},{"ruleId":"213","severity":2,"message":"214","line":389,"column":34,"nodeType":"215","messageId":"216","endLine":389,"endColumn":36,"suggestions":"285"},{"ruleId":"199","severity":2,"message":"200","line":401,"column":9,"nodeType":"239","messageId":"202","endLine":401,"endColumn":24,"suggestions":"286"},{"ruleId":"199","severity":2,"message":"255","line":408,"column":18,"nodeType":"201","messageId":"256","endLine":408,"endColumn":44,"suggestions":"287"},{"ruleId":"199","severity":2,"message":"200","line":419,"column":9,"nodeType":"239","messageId":"202","endLine":419,"endColumn":21,"suggestions":"288"},{"ruleId":"289","severity":2,"message":"290","line":420,"column":14,"nodeType":"233","messageId":"291","endLine":420,"endColumn":79},{"ruleId":"292","severity":2,"message":"293","line":440,"column":44,"nodeType":"239","messageId":"294","endLine":440,"endColumn":49},{"ruleId":"199","severity":2,"message":"200","line":489,"column":9,"nodeType":"239","messageId":"202","endLine":489,"endColumn":13,"suggestions":"295"},{"ruleId":"199","severity":2,"message":"200","line":493,"column":11,"nodeType":"239","messageId":"202","endLine":493,"endColumn":21,"suggestions":"296"},{"ruleId":"199","severity":2,"message":"200","line":494,"column":16,"nodeType":"233","messageId":"202","endLine":494,"endColumn":42,"suggestions":"297"},{"ruleId":"213","severity":2,"message":"214","line":494,"column":43,"nodeType":"215","messageId":"216","endLine":494,"endColumn":45,"suggestions":"298"},{"ruleId":"199","severity":2,"message":"200","line":502,"column":9,"nodeType":"239","messageId":"202","endLine":502,"endColumn":13,"suggestions":"299"},{"ruleId":"199","severity":2,"message":"200","line":506,"column":11,"nodeType":"239","messageId":"202","endLine":506,"endColumn":21,"suggestions":"300"},{"ruleId":"199","severity":2,"message":"200","line":507,"column":16,"nodeType":"233","messageId":"202","endLine":507,"endColumn":42,"suggestions":"301"},{"ruleId":"213","severity":2,"message":"214","line":507,"column":43,"nodeType":"215","messageId":"216","endLine":507,"endColumn":45,"suggestions":"302"},{"ruleId":"199","severity":2,"message":"200","line":538,"column":9,"nodeType":"239","messageId":"202","endLine":538,"endColumn":23,"suggestions":"303"},{"ruleId":"199","severity":2,"message":"200","line":555,"column":8,"nodeType":"239","messageId":"202","endLine":555,"endColumn":20,"suggestions":"304"},{"ruleId":"199","severity":2,"message":"200","line":556,"column":8,"nodeType":"239","messageId":"202","endLine":556,"endColumn":16,"suggestions":"305"},{"ruleId":"199","severity":2,"message":"200","line":572,"column":9,"nodeType":"239","messageId":"202","endLine":572,"endColumn":23,"suggestions":"306"},{"ruleId":"199","severity":2,"message":"200","line":592,"column":8,"nodeType":"239","messageId":"202","endLine":592,"endColumn":20,"suggestions":"307"},{"ruleId":"199","severity":2,"message":"200","line":593,"column":8,"nodeType":"239","messageId":"202","endLine":593,"endColumn":16,"suggestions":"308"},{"ruleId":"199","severity":2,"message":"255","line":664,"column":12,"nodeType":"233","messageId":"256","endLine":664,"endColumn":45,"suggestions":"309"},{"ruleId":"199","severity":2,"message":"255","line":678,"column":12,"nodeType":"233","messageId":"256","endLine":678,"endColumn":45,"suggestions":"310"},{"ruleId":"199","severity":2,"message":"200","line":687,"column":7,"nodeType":"233","messageId":"202","endLine":687,"endColumn":33,"suggestions":"311"},{"ruleId":"213","severity":2,"message":"214","line":687,"column":34,"nodeType":"215","messageId":"216","endLine":687,"endColumn":36,"suggestions":"312"},{"ruleId":"199","severity":2,"message":"200","line":687,"column":37,"nodeType":"233","messageId":"202","endLine":687,"endColumn":73,"suggestions":"313"},{"ruleId":"199","severity":2,"message":"200","line":696,"column":7,"nodeType":"233","messageId":"202","endLine":696,"endColumn":33,"suggestions":"314"},{"ruleId":"213","severity":2,"message":"214","line":696,"column":34,"nodeType":"215","messageId":"216","endLine":696,"endColumn":36,"suggestions":"315"},{"ruleId":"199","severity":2,"message":"200","line":697,"column":8,"nodeType":"276","messageId":"202","endLine":697,"endColumn":55,"suggestions":"316"},{"ruleId":"199","severity":2,"message":"200","line":726,"column":15,"nodeType":"233","messageId":"202","endLine":726,"endColumn":42,"suggestions":"317"},{"ruleId":"213","severity":2,"message":"214","line":726,"column":43,"nodeType":"215","messageId":"216","endLine":726,"endColumn":45,"suggestions":"318"},{"ruleId":"199","severity":2,"message":"200","line":736,"column":17,"nodeType":"239","messageId":"202","endLine":736,"endColumn":23,"suggestions":"319"},{"ruleId":"199","severity":2,"message":"200","line":741,"column":16,"nodeType":"239","messageId":"202","endLine":741,"endColumn":22,"suggestions":"320"},{"ruleId":"199","severity":2,"message":"200","line":785,"column":15,"nodeType":"233","messageId":"202","endLine":785,"endColumn":42,"suggestions":"321"},{"ruleId":"213","severity":2,"message":"214","line":785,"column":43,"nodeType":"215","messageId":"216","endLine":785,"endColumn":45,"suggestions":"322"},{"ruleId":"199","severity":2,"message":"200","line":795,"column":17,"nodeType":"239","messageId":"202","endLine":795,"endColumn":23,"suggestions":"323"},{"ruleId":"199","severity":2,"message":"200","line":800,"column":16,"nodeType":"239","messageId":"202","endLine":800,"endColumn":22,"suggestions":"324"},{"ruleId":"220","severity":2,"message":"221","line":865,"column":9,"nodeType":"222","messageId":"223","endLine":865,"endColumn":43},{"ruleId":"224","severity":2,"message":"325","line":877,"column":6,"nodeType":"201","messageId":"226","endLine":877,"endColumn":25},{"ruleId":"224","severity":2,"message":"326","line":877,"column":37,"nodeType":"201","messageId":"226","endLine":877,"endColumn":57},{"ruleId":"327","severity":1,"message":"290","line":420,"column":14,"nodeType":"233","messageId":"291","endLine":420,"endColumn":79,"suppressions":"328"},{"ruleId":"199","severity":2,"message":"200","line":76,"column":8,"nodeType":"239","messageId":"202","endLine":76,"endColumn":15,"suggestions":"329"},{"ruleId":"199","severity":2,"message":"200","line":53,"column":15,"nodeType":"239","messageId":"202","endLine":53,"endColumn":23,"suggestions":"330"},{"ruleId":"213","severity":2,"message":"214","line":53,"column":24,"nodeType":"215","messageId":"216","endLine":53,"endColumn":26,"suggestions":"331"},{"ruleId":"199","severity":2,"message":"200","line":55,"column":7,"nodeType":"239","messageId":"202","endLine":55,"endColumn":13,"suggestions":"332"},{"ruleId":"199","severity":2,"message":"200","line":65,"column":15,"nodeType":"239","messageId":"202","endLine":65,"endColumn":23,"suggestions":"333"},{"ruleId":"213","severity":2,"message":"214","line":65,"column":24,"nodeType":"215","messageId":"216","endLine":65,"endColumn":26,"suggestions":"334"},{"ruleId":"199","severity":2,"message":"200","line":67,"column":7,"nodeType":"239","messageId":"202","endLine":67,"endColumn":13,"suggestions":"335"},{"ruleId":"224","severity":2,"message":"336","line":117,"column":7,"nodeType":"201","messageId":"226","endLine":117,"endColumn":20},"@typescript-eslint/strict-boolean-expressions","Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.","MemberExpression","conditionErrorNullableString",["337","338","339"],"Unexpected nullable number value in conditional. Please handle the nullish/zero/NaN cases explicitly.","ChainExpression","conditionErrorNullableNumber",["340","341","342"],["343","344","345"],"@typescript-eslint/unbound-method","Avoid referencing unbound methods which may cause unintentional scoping of `this`.\nIf your function does not access `this`, you can annotate it with `this: void`, or consider using an arrow function instead.","unboundWithoutThisAnnotation",["346","347","348"],"@typescript-eslint/prefer-nullish-coalescing","Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.","Punctuator","preferNullishOverOr",["349"],["350","351","352"],["353"],"@typescript-eslint/no-unsafe-assignment","Unsafe assignment of an `any` value.","VariableDeclarator","anyAssignment","@typescript-eslint/no-unsafe-member-access","Unsafe member access .default on an `any` value.","unsafeMemberExpression","@typescript-eslint/no-unsafe-call","Unsafe construction of an any type value.","NewExpression","unsafeNew","@typescript-eslint/restrict-template-expressions","Invalid type \"any\" of template literal expression.","CallExpression","invalidType","Unsafe member access .dirname on an `any` value.","Unsafe call of an `any` typed value.","unsafeCall","Unsafe member access .getModulePaths on an `any` value.","Identifier",["354","355","356"],"Invalid type \"string | undefined\" of template literal expression.",["357","358","359"],"Unexpected value in conditional. A boolean expression is required.","conditionErrorOther",["360","361","362"],["363","364","365"],"Unexpected any value in conditional. An explicit comparison or type cast is required.","conditionErrorAny",["366"],"Unsafe member access .code on an `any` value.","Unexpected object value in conditional. The condition is always true.","conditionErrorObject",["367","368","369"],["370"],"Unexpected nullable boolean value in conditional. Please handle the nullish case explicitly.","conditionErrorNullableBoolean",["371","372"],["373"],"Invalid type \"string | null | undefined\" of template literal expression.",["374"],["375","376"],["377","378","379"],["380","381","382"],["383","384","385"],["386","387"],["388","389","390"],["391","392","393"],["394","395","396"],["397"],["398","399","400"],["401","402","403"],["404","405","406"],["407","408"],["409","410","411"],["412","413","414"],"AwaitExpression",["415","416","417"],["418"],["419","420","421"],["422"],["423","424","425"],["426","427","428"],["429"],["430","431","432"],["433"],["434","435","436"],["437","438"],["439","440","441"],"prefer-spread","Use the spread operator instead of '.apply()'.","preferSpread","@typescript-eslint/no-unsafe-argument","Unsafe argument of type `any` assigned to a parameter of type `string`.","unsafeArgument",["442","443","444"],["445","446","447"],["448","449","450"],["451"],["452","453","454"],["455","456","457"],["458","459","460"],["461"],["462","463","464"],["465","466","467"],["468","469","470"],["471","472","473"],["474","475","476"],["477","478","479"],["480","481"],["482","483"],["484","485","486"],["487"],["488","489","490"],["491","492","493"],["494"],["495","496","497"],["498","499","500"],["501"],["502","503","504"],["505","506","507"],["508","509","510"],["511"],["512","513","514"],["515","516","517"],"Unsafe member access .sync on an `any` value.","Unsafe member access .async on an `any` value.","local/prefer-spread-eventually",["518"],["519","520","521"],["522","523","524"],["525"],["526","527","528"],["529","530","531"],["532"],["533","534","535"],"Unsafe member access .message on an `any` value.",{"messageId":"536","fix":"537","desc":"538"},{"messageId":"539","fix":"540","desc":"541"},{"messageId":"542","fix":"543","desc":"544"},{"messageId":"536","fix":"545","desc":"538"},{"messageId":"546","fix":"547","desc":"548"},{"messageId":"542","fix":"549","desc":"544"},{"messageId":"536","fix":"550","desc":"538"},{"messageId":"539","fix":"551","desc":"541"},{"messageId":"542","fix":"552","desc":"544"},{"messageId":"536","fix":"553","desc":"538"},{"messageId":"539","fix":"554","desc":"541"},{"messageId":"542","fix":"555","desc":"544"},{"messageId":"556","fix":"557","desc":"558"},{"messageId":"536","fix":"559","desc":"538"},{"messageId":"539","fix":"560","desc":"541"},{"messageId":"542","fix":"561","desc":"544"},{"messageId":"556","fix":"562","desc":"558"},{"messageId":"536","fix":"563","desc":"538"},{"messageId":"539","fix":"564","desc":"541"},{"messageId":"542","fix":"565","desc":"544"},{"messageId":"536","fix":"566","desc":"538"},{"messageId":"539","fix":"567","desc":"541"},{"messageId":"542","fix":"568","desc":"544"},{"messageId":"536","fix":"569","desc":"538"},{"messageId":"539","fix":"570","desc":"541"},{"messageId":"542","fix":"571","desc":"544"},{"messageId":"536","fix":"572","desc":"538"},{"messageId":"539","fix":"573","desc":"541"},{"messageId":"542","fix":"574","desc":"544"},{"messageId":"542","fix":"575","desc":"544"},{"messageId":"536","fix":"576","desc":"538"},{"messageId":"539","fix":"577","desc":"541"},{"messageId":"542","fix":"578","desc":"544"},{"messageId":"556","fix":"579","desc":"558"},{"messageId":"580","fix":"581","desc":"582"},{"messageId":"583","fix":"584","desc":"585"},{"messageId":"556","fix":"586","desc":"558"},{"messageId":"556","fix":"587","desc":"558"},{"messageId":"580","fix":"588","desc":"582"},{"messageId":"583","fix":"589","desc":"585"},{"messageId":"536","fix":"590","desc":"538"},{"messageId":"539","fix":"591","desc":"541"},{"messageId":"542","fix":"592","desc":"544"},{"messageId":"536","fix":"593","desc":"538"},{"messageId":"539","fix":"594","desc":"541"},{"messageId":"542","fix":"595","desc":"544"},{"messageId":"536","fix":"596","desc":"538"},{"messageId":"539","fix":"597","desc":"541"},{"messageId":"542","fix":"598","desc":"544"},{"messageId":"580","fix":"599","desc":"582"},{"messageId":"600","fix":"601","desc":"602"},{"messageId":"536","fix":"603","desc":"538"},{"messageId":"539","fix":"604","desc":"541"},{"messageId":"542","fix":"605","desc":"544"},{"messageId":"536","fix":"606","desc":"538"},{"messageId":"539","fix":"607","desc":"541"},{"messageId":"542","fix":"608","desc":"544"},{"messageId":"536","fix":"609","desc":"538"},{"messageId":"539","fix":"610","desc":"541"},{"messageId":"542","fix":"611","desc":"544"},{"messageId":"556","fix":"612","desc":"558"},{"messageId":"536","fix":"613","desc":"538"},{"messageId":"539","fix":"614","desc":"541"},{"messageId":"542","fix":"615","desc":"544"},{"messageId":"536","fix":"616","desc":"538"},{"messageId":"539","fix":"617","desc":"541"},{"messageId":"542","fix":"618","desc":"544"},{"messageId":"536","fix":"619","desc":"538"},{"messageId":"539","fix":"620","desc":"541"},{"messageId":"542","fix":"621","desc":"544"},{"messageId":"580","fix":"622","desc":"582"},{"messageId":"600","fix":"623","desc":"602"},{"messageId":"536","fix":"624","desc":"538"},{"messageId":"539","fix":"625","desc":"541"},{"messageId":"542","fix":"626","desc":"544"},{"messageId":"536","fix":"627","desc":"538"},{"messageId":"539","fix":"628","desc":"541"},{"messageId":"542","fix":"629","desc":"544"},{"messageId":"536","fix":"630","desc":"538"},{"messageId":"539","fix":"631","desc":"541"},{"messageId":"542","fix":"632","desc":"544"},{"messageId":"556","fix":"633","desc":"558"},{"messageId":"536","fix":"634","desc":"538"},{"messageId":"539","fix":"635","desc":"541"},{"messageId":"542","fix":"636","desc":"544"},{"messageId":"556","fix":"637","desc":"558"},{"messageId":"536","fix":"638","desc":"538"},{"messageId":"539","fix":"639","desc":"541"},{"messageId":"542","fix":"640","desc":"544"},{"messageId":"536","fix":"641","desc":"538"},{"messageId":"539","fix":"642","desc":"541"},{"messageId":"542","fix":"643","desc":"544"},{"messageId":"556","fix":"644","desc":"558"},{"messageId":"536","fix":"645","desc":"538"},{"messageId":"539","fix":"646","desc":"541"},{"messageId":"542","fix":"647","desc":"544"},{"messageId":"556","fix":"648","desc":"558"},{"messageId":"536","fix":"649","desc":"538"},{"messageId":"539","fix":"650","desc":"541"},{"messageId":"542","fix":"651","desc":"544"},{"messageId":"580","fix":"652","desc":"582"},{"messageId":"583","fix":"653","desc":"585"},{"messageId":"536","fix":"654","desc":"538"},{"messageId":"539","fix":"655","desc":"541"},{"messageId":"542","fix":"656","desc":"544"},{"messageId":"536","fix":"657","desc":"538"},{"messageId":"539","fix":"658","desc":"541"},{"messageId":"542","fix":"659","desc":"544"},{"messageId":"536","fix":"660","desc":"538"},{"messageId":"539","fix":"661","desc":"541"},{"messageId":"542","fix":"662","desc":"544"},{"messageId":"536","fix":"663","desc":"538"},{"messageId":"539","fix":"664","desc":"541"},{"messageId":"542","fix":"665","desc":"544"},{"messageId":"556","fix":"666","desc":"558"},{"messageId":"536","fix":"667","desc":"538"},{"messageId":"539","fix":"668","desc":"541"},{"messageId":"542","fix":"669","desc":"544"},{"messageId":"536","fix":"670","desc":"538"},{"messageId":"539","fix":"671","desc":"541"},{"messageId":"542","fix":"672","desc":"544"},{"messageId":"536","fix":"673","desc":"538"},{"messageId":"539","fix":"674","desc":"541"},{"messageId":"542","fix":"675","desc":"544"},{"messageId":"556","fix":"676","desc":"558"},{"messageId":"536","fix":"677","desc":"538"},{"messageId":"539","fix":"678","desc":"541"},{"messageId":"542","fix":"679","desc":"544"},{"messageId":"536","fix":"680","desc":"538"},{"messageId":"539","fix":"681","desc":"541"},{"messageId":"542","fix":"682","desc":"544"},{"messageId":"536","fix":"683","desc":"538"},{"messageId":"539","fix":"684","desc":"541"},{"messageId":"542","fix":"685","desc":"544"},{"messageId":"536","fix":"686","desc":"538"},{"messageId":"539","fix":"687","desc":"541"},{"messageId":"542","fix":"688","desc":"544"},{"messageId":"536","fix":"689","desc":"538"},{"messageId":"539","fix":"690","desc":"541"},{"messageId":"542","fix":"691","desc":"544"},{"messageId":"536","fix":"692","desc":"538"},{"messageId":"539","fix":"693","desc":"541"},{"messageId":"542","fix":"694","desc":"544"},{"messageId":"580","fix":"695","desc":"582"},{"messageId":"583","fix":"696","desc":"585"},{"messageId":"580","fix":"697","desc":"582"},{"messageId":"583","fix":"698","desc":"585"},{"messageId":"536","fix":"699","desc":"538"},{"messageId":"539","fix":"700","desc":"541"},{"messageId":"542","fix":"701","desc":"544"},{"messageId":"556","fix":"702","desc":"558"},{"messageId":"536","fix":"703","desc":"538"},{"messageId":"539","fix":"704","desc":"541"},{"messageId":"542","fix":"705","desc":"544"},{"messageId":"536","fix":"706","desc":"538"},{"messageId":"539","fix":"707","desc":"541"},{"messageId":"542","fix":"708","desc":"544"},{"messageId":"556","fix":"709","desc":"558"},{"messageId":"536","fix":"710","desc":"538"},{"messageId":"539","fix":"711","desc":"541"},{"messageId":"542","fix":"712","desc":"544"},{"messageId":"536","fix":"713","desc":"538"},{"messageId":"539","fix":"714","desc":"541"},{"messageId":"542","fix":"715","desc":"544"},{"messageId":"556","fix":"716","desc":"558"},{"messageId":"536","fix":"717","desc":"538"},{"messageId":"539","fix":"718","desc":"541"},{"messageId":"542","fix":"719","desc":"544"},{"messageId":"536","fix":"720","desc":"538"},{"messageId":"539","fix":"721","desc":"541"},{"messageId":"542","fix":"722","desc":"544"},{"messageId":"536","fix":"723","desc":"538"},{"messageId":"539","fix":"724","desc":"541"},{"messageId":"542","fix":"725","desc":"544"},{"messageId":"556","fix":"726","desc":"558"},{"messageId":"536","fix":"727","desc":"538"},{"messageId":"539","fix":"728","desc":"541"},{"messageId":"542","fix":"729","desc":"544"},{"messageId":"536","fix":"730","desc":"538"},{"messageId":"539","fix":"731","desc":"541"},{"messageId":"542","fix":"732","desc":"544"},{"kind":"733","justification":"734"},{"messageId":"536","fix":"735","desc":"538"},{"messageId":"539","fix":"736","desc":"541"},{"messageId":"542","fix":"737","desc":"544"},{"messageId":"536","fix":"738","desc":"538"},{"messageId":"539","fix":"739","desc":"541"},{"messageId":"542","fix":"740","desc":"544"},{"messageId":"556","fix":"741","desc":"558"},{"messageId":"536","fix":"742","desc":"538"},{"messageId":"539","fix":"743","desc":"541"},{"messageId":"542","fix":"744","desc":"544"},{"messageId":"536","fix":"745","desc":"538"},{"messageId":"539","fix":"746","desc":"541"},{"messageId":"542","fix":"747","desc":"544"},{"messageId":"556","fix":"748","desc":"558"},{"messageId":"536","fix":"749","desc":"538"},{"messageId":"539","fix":"750","desc":"541"},{"messageId":"542","fix":"751","desc":"544"},"conditionFixCompareNullish",{"range":"752","text":"753"},"Change condition to check for null/undefined (`value != null`)","conditionFixDefaultEmptyString",{"range":"754","text":"755"},"Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)","conditionFixCastBoolean",{"range":"752","text":"756"},"Explicitly cast value to a boolean (`Boolean(value)`)",{"range":"757","text":"758"},"conditionFixDefaultZero",{"range":"757","text":"759"},"Explicitly treat nullish value the same as 0 (`value ?? 0`)",{"range":"757","text":"760"},{"range":"761","text":"762"},{"range":"761","text":"763"},{"range":"761","text":"764"},{"range":"765","text":"766"},{"range":"765","text":"767"},{"range":"765","text":"768"},"suggestNullish",{"range":"769","text":"770"},"Fix to nullish coalescing operator (`??`).",{"range":"771","text":"766"},{"range":"771","text":"767"},{"range":"771","text":"768"},{"range":"772","text":"770"},{"range":"773","text":"774"},{"range":"773","text":"775"},{"range":"773","text":"776"},{"range":"777","text":"778"},{"range":"777","text":"779"},{"range":"777","text":"780"},{"range":"781","text":"782"},{"range":"783","text":"784"},{"range":"781","text":"785"},{"range":"786","text":"782"},{"range":"787","text":"784"},{"range":"786","text":"785"},{"range":"788","text":"789"},{"range":"790","text":"791"},{"range":"790","text":"792"},{"range":"790","text":"793"},{"range":"794","text":"770"},"conditionFixDefaultFalse",{"range":"795","text":"796"},"Explicitly treat nullish value the same as false (`value ?? false`)","conditionFixCompareTrue",{"range":"795","text":"797"},"Change condition to check if true (`value === true`)",{"range":"798","text":"770"},{"range":"799","text":"770"},{"range":"800","text":"796"},{"range":"800","text":"797"},{"range":"801","text":"802"},{"range":"801","text":"803"},{"range":"801","text":"804"},{"range":"805","text":"806"},{"range":"805","text":"807"},{"range":"805","text":"808"},{"range":"809","text":"810"},{"range":"811","text":"812"},{"range":"809","text":"813"},{"range":"814","text":"815"},"conditionFixCompareFalse",{"range":"816","text":"817"},"Change condition to check if false (`value === false`)",{"range":"818","text":"806"},{"range":"818","text":"807"},{"range":"818","text":"808"},{"range":"819","text":"820"},{"range":"819","text":"821"},{"range":"819","text":"822"},{"range":"823","text":"824"},{"range":"823","text":"825"},{"range":"823","text":"826"},{"range":"827","text":"770"},{"range":"828","text":"802"},{"range":"828","text":"803"},{"range":"828","text":"804"},{"range":"829","text":"806"},{"range":"829","text":"807"},{"range":"829","text":"808"},{"range":"830","text":"810"},{"range":"831","text":"812"},{"range":"830","text":"813"},{"range":"832","text":"815"},{"range":"833","text":"817"},{"range":"834","text":"806"},{"range":"834","text":"807"},{"range":"834","text":"808"},{"range":"835","text":"820"},{"range":"835","text":"821"},{"range":"835","text":"822"},{"range":"836","text":"837"},{"range":"836","text":"838"},{"range":"836","text":"839"},{"range":"840","text":"770"},{"range":"841","text":"842"},{"range":"841","text":"843"},{"range":"841","text":"844"},{"range":"845","text":"770"},{"range":"846","text":"806"},{"range":"846","text":"807"},{"range":"846","text":"808"},{"range":"847","text":"848"},{"range":"847","text":"849"},{"range":"847","text":"850"},{"range":"851","text":"770"},{"range":"852","text":"806"},{"range":"852","text":"807"},{"range":"852","text":"808"},{"range":"853","text":"770"},{"range":"854","text":"855"},{"range":"854","text":"856"},{"range":"854","text":"857"},{"range":"858","text":"859"},{"range":"858","text":"860"},{"range":"861","text":"862"},{"range":"861","text":"863"},{"range":"861","text":"864"},{"range":"865","text":"866"},{"range":"865","text":"867"},{"range":"865","text":"868"},{"range":"869","text":"774"},{"range":"869","text":"775"},{"range":"869","text":"776"},{"range":"870","text":"871"},{"range":"870","text":"872"},{"range":"870","text":"873"},{"range":"874","text":"770"},{"range":"875","text":"866"},{"range":"875","text":"867"},{"range":"875","text":"868"},{"range":"876","text":"774"},{"range":"876","text":"775"},{"range":"876","text":"776"},{"range":"877","text":"871"},{"range":"877","text":"872"},{"range":"877","text":"873"},{"range":"878","text":"770"},{"range":"879","text":"880"},{"range":"879","text":"881"},{"range":"879","text":"882"},{"range":"883","text":"884"},{"range":"883","text":"885"},{"range":"883","text":"886"},{"range":"887","text":"888"},{"range":"887","text":"889"},{"range":"887","text":"890"},{"range":"891","text":"880"},{"range":"891","text":"881"},{"range":"891","text":"882"},{"range":"892","text":"884"},{"range":"892","text":"885"},{"range":"892","text":"886"},{"range":"893","text":"888"},{"range":"893","text":"889"},{"range":"893","text":"890"},{"range":"894","text":"895"},{"range":"894","text":"896"},{"range":"897","text":"895"},{"range":"897","text":"896"},{"range":"898","text":"871"},{"range":"898","text":"872"},{"range":"898","text":"873"},{"range":"899","text":"770"},{"range":"900","text":"901"},{"range":"900","text":"902"},{"range":"900","text":"903"},{"range":"904","text":"871"},{"range":"904","text":"872"},{"range":"904","text":"873"},{"range":"905","text":"770"},{"range":"906","text":"907"},{"range":"906","text":"908"},{"range":"906","text":"909"},{"range":"910","text":"911"},{"range":"910","text":"912"},{"range":"910","text":"913"},{"range":"914","text":"770"},{"range":"915","text":"806"},{"range":"915","text":"807"},{"range":"915","text":"808"},{"range":"916","text":"917"},{"range":"918","text":"919"},{"range":"916","text":"920"},{"range":"921","text":"911"},{"range":"921","text":"912"},{"range":"921","text":"913"},{"range":"922","text":"770"},{"range":"923","text":"806"},{"range":"923","text":"807"},{"range":"923","text":"808"},{"range":"924","text":"917"},{"range":"925","text":"919"},{"range":"924","text":"920"},"directive","",{"range":"926","text":"927"},{"range":"928","text":"929"},{"range":"926","text":"930"},{"range":"931","text":"932"},{"range":"931","text":"933"},{"range":"931","text":"934"},{"range":"935","text":"770"},{"range":"936","text":"806"},{"range":"936","text":"807"},{"range":"936","text":"808"},{"range":"937","text":"932"},{"range":"937","text":"933"},{"range":"937","text":"934"},{"range":"938","text":"770"},{"range":"939","text":"806"},{"range":"939","text":"807"},{"range":"939","text":"808"},[758,780],"this._originalMessage == null",[759,780],"(this._originalMessage ?? \"\")","!Boolean(this._originalMessage)",[891,916],"((this.requireStack?.length) != null)","((this.requireStack?.length) ?? 0)","(Boolean((this.requireStack?.length)))",[1116,1125],"this.hint != null","this.hint ?? \"\"","Boolean(this.hint)",[3775,3796],"(process.env.NODE_PATH != null)","(process.env.NODE_PATH ?? \"\")","(Boolean(process.env.NODE_PATH))",[4614,4616],"??",[10314,10335],[11195,11197],[3864,3874],"moduleName != null","moduleName ?? \"\"","Boolean(moduleName)",[4157,4175],"closestPackageJson != null","closestPackageJson ?? \"\"","Boolean(closestPackageJson)",[4492,4501],"resolved == null",[4493,4501],"(resolved ?? \"\")","!Boolean(resolved)",[5257,5266],[5258,5266],[1003,1004],"(Boolean(e))",[1436,1445],"(NODE_PATH != null)","(NODE_PATH ?? \"\")","(Boolean(NODE_PATH))",[3964,3966],[4070,4093],"options.throwIfNotFound ?? false","options.throwIfNotFound === true",[4636,4638],[5126,5128],[5262,5285],[5981,5992],"cacheResult != null","cacheResult ?? \"\"","Boolean(cacheResult)",[6127,6133],"module != null","module ?? \"\"","Boolean(module)",[6768,6791],"(this._options.resolver == null)",[6769,6791],"(this._options.resolver ?? \"\")","(!Boolean(this._options.resolver))",[7131,7145],"(skipResolution ?? false)",[7130,7145],"skipResolution === false",[7237,7243],[7557,7572],"hasteModulePath != null","hasteModulePath ?? \"\"","Boolean(hasteModulePath)",[7736,7770],"(resolveNodeModule(hasteModulePath) != null)","(resolveNodeModule(hasteModulePath) ?? \"\")","(Boolean(resolveNodeModule(hasteModulePath)))",[7771,7773],[8433,8444],[8579,8585],[9226,9249],[9227,9249],[9594,9608],[9593,9608],[9731,9737],[10051,10066],[10231,10271],"(await resolveNodeModule(hasteModulePath)) != null","(await resolveNodeModule(hasteModulePath)) ?? \"\"","Boolean((await resolveNodeModule(hasteModulePath)))",[10273,10275],[10671,10715],"(this.resolveStubModuleName(from, moduleName) != null)","(this.resolveStubModuleName(from, moduleName) ?? \"\")","(Boolean(this.resolveStubModuleName(from, moduleName)))",[10716,10718],[10798,10804],[11258,11313],"(await this.resolveStubModuleNameAsync(from, moduleName)) != null","(await this.resolveStubModuleNameAsync(from, moduleName)) ?? \"\"","Boolean((await this.resolveStubModuleNameAsync(from, moduleName)))",[11315,11317],[11444,11450],[12005,12007],[12526,12541],"defaultPlatform != null","defaultPlatform ?? \"\"","Boolean(defaultPlatform)",[12708,12734],"(options.skipNodeResolution ?? false)","(options.skipNodeResolution === true)",[13089,13101],"hastePackage != null","hastePackage ?? \"\"","Boolean(hastePackage)",[15050,15054],"mock != null","mock ?? \"\"","Boolean(mock)",[15165,15175],[15194,15220],"(this.getModule(moduleName) != null)","(this.getModule(moduleName) ?? \"\")","(Boolean(this.getModule(moduleName)))",[15221,15223],[15415,15419],[15541,15551],[15570,15596],[15597,15599],[16500,16514],"cachedModuleID != null","cachedModuleID ?? \"\"","Boolean(cachedModuleID)",[16874,16886],"(absolutePath != null)","(absolutePath ?? \"\")","(Boolean(absolutePath))",[16923,16931],"(mockPath != null)","(mockPath ?? \"\")","(Boolean(mockPath))",[17448,17462],[17917,17929],[17966,17974],[19943,19976],"(virtualMocks.get(virtualMockPath) ?? false)","(virtualMocks.get(virtualMockPath) === true)",[20352,20385],[20601,20627],[20628,20630],[20631,20667],"(this.getMockModule(from, moduleName) != null)","(this.getMockModule(from, moduleName) ?? \"\")","(Boolean(this.getMockModule(from, moduleName)))",[20807,20833],[20834,20836],[20844,20891],"(await this.getMockModuleAsync(from, moduleName)) != null","(await this.getMockModuleAsync(from, moduleName)) ?? \"\"","Boolean((await this.getMockModuleAsync(from, moduleName)))",[21983,22010],"(this.getModule(updatedName) != null)","(this.getModule(updatedName) ?? \"\")","(Boolean(this.getModule(updatedName)))",[22011,22013],[22294,22300],[22366,22373],"module == null",[22367,22373],"(module ?? \"\")","!Boolean(module)",[23768,23795],[23796,23798],[24092,24098],[24164,24171],[24165,24171],[1934,1942],"pkgPath == null",[1935,1942],"(pkgPath ?? \"\")","!Boolean(pkgPath)",[1445,1453],"(resolver != null)","(resolver ?? \"\")","(Boolean(resolver))",[1454,1456],[1480,1486],[1678,1686],[1687,1689],[1713,1719]]