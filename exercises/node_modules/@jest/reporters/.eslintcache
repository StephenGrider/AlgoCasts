[{"/Users/simen/repos/jest/packages/jest-reporters/src/BaseReporter.ts":"1","/Users/simen/repos/jest/packages/jest-reporters/src/CoverageReporter.ts":"2","/Users/simen/repos/jest/packages/jest-reporters/src/CoverageWorker.ts":"3","/Users/simen/repos/jest/packages/jest-reporters/src/DefaultReporter.ts":"4","/Users/simen/repos/jest/packages/jest-reporters/src/GitHubActionsReporter.ts":"5","/Users/simen/repos/jest/packages/jest-reporters/src/NotifyReporter.ts":"6","/Users/simen/repos/jest/packages/jest-reporters/src/Status.ts":"7","/Users/simen/repos/jest/packages/jest-reporters/src/SummaryReporter.ts":"8","/Users/simen/repos/jest/packages/jest-reporters/src/VerboseReporter.ts":"9","/Users/simen/repos/jest/packages/jest-reporters/src/__tests__/GitHubActionsReporter.test.ts":"10","/Users/simen/repos/jest/packages/jest-reporters/src/__tests__/NotifyReporter.test.ts":"11","/Users/simen/repos/jest/packages/jest-reporters/src/__tests__/getWatermarks.test.ts":"12","/Users/simen/repos/jest/packages/jest-reporters/src/__tests__/utils.test.ts":"13","/Users/simen/repos/jest/packages/jest-reporters/src/formatTestPath.ts":"14","/Users/simen/repos/jest/packages/jest-reporters/src/generateEmptyCoverage.ts":"15","/Users/simen/repos/jest/packages/jest-reporters/src/getResultHeader.ts":"16","/Users/simen/repos/jest/packages/jest-reporters/src/getSnapshotStatus.ts":"17","/Users/simen/repos/jest/packages/jest-reporters/src/getSnapshotSummary.ts":"18","/Users/simen/repos/jest/packages/jest-reporters/src/getSummary.ts":"19","/Users/simen/repos/jest/packages/jest-reporters/src/getWatermarks.ts":"20","/Users/simen/repos/jest/packages/jest-reporters/src/index.ts":"21","/Users/simen/repos/jest/packages/jest-reporters/src/printDisplayName.ts":"22","/Users/simen/repos/jest/packages/jest-reporters/src/relativePath.ts":"23","/Users/simen/repos/jest/packages/jest-reporters/src/trimAndFormatPath.ts":"24","/Users/simen/repos/jest/packages/jest-reporters/src/types.ts":"25","/Users/simen/repos/jest/packages/jest-reporters/src/wrapAnsiString.ts":"26","/Users/simen/repos/jest/packages/jest-reporters/src/__tests__/getSummary.test.ts":"27"},{"size":1496,"mtime":1665461180560,"results":"28","hashOfConfig":"29"},{"size":16527,"mtime":1665737657500,"results":"30","hashOfConfig":"29"},{"size":1484,"mtime":1664795891597,"results":"31","hashOfConfig":"29"},{"size":6795,"mtime":1665737657500,"results":"32","hashOfConfig":"29"},{"size":2408,"mtime":1665461180560,"results":"33","hashOfConfig":"29"},{"size":4957,"mtime":1665737657500,"results":"34","hashOfConfig":"29"},{"size":5842,"mtime":1665939820573,"results":"35","hashOfConfig":"29"},{"size":6944,"mtime":1665737657501,"results":"36","hashOfConfig":"29"},{"size":5238,"mtime":1664535326132,"results":"37","hashOfConfig":"29"},{"size":5735,"mtime":1665737657501,"results":"38","hashOfConfig":"29"},{"size":6332,"mtime":1665737657501,"results":"39","hashOfConfig":"29"},{"size":1293,"mtime":1663311355497,"results":"40","hashOfConfig":"29"},{"size":4427,"mtime":1665737657502,"results":"41","hashOfConfig":"29"},{"size":652,"mtime":1664535326133,"results":"42","hashOfConfig":"29"},{"size":2861,"mtime":1665737657502,"results":"43","hashOfConfig":"29"},{"size":1815,"mtime":1665737657503,"results":"44","hashOfConfig":"29"},{"size":1753,"mtime":1664535326135,"results":"45","hashOfConfig":"29"},{"size":3928,"mtime":1664535326135,"results":"46","hashOfConfig":"29"},{"size":6580,"mtime":1665737657503,"results":"47","hashOfConfig":"29"},{"size":954,"mtime":1662710982159,"results":"48","hashOfConfig":"29"},{"size":1503,"mtime":1664535326136,"results":"49","hashOfConfig":"29"},{"size":682,"mtime":1664535326136,"results":"50","hashOfConfig":"29"},{"size":906,"mtime":1664535326136,"results":"51","hashOfConfig":"29"},{"size":1524,"mtime":1664535326136,"results":"52","hashOfConfig":"29"},{"size":1755,"mtime":1665737657503,"results":"53","hashOfConfig":"29"},{"size":1999,"mtime":1665737657504,"results":"54","hashOfConfig":"29"},{"size":1176,"mtime":1665737657502,"results":"55","hashOfConfig":"29"},{"filePath":"56","messages":"57","suppressedMessages":"58","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},"knhy16",{"filePath":"59","messages":"60","suppressedMessages":"61","errorCount":17,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"62"},{"filePath":"63","messages":"64","suppressedMessages":"65","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"66","messages":"67","suppressedMessages":"68","errorCount":2,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"69"},{"filePath":"70","messages":"71","suppressedMessages":"72","errorCount":2,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"73"},{"filePath":"74","messages":"75","suppressedMessages":"76","errorCount":13,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"77"},{"filePath":"78","messages":"79","suppressedMessages":"80","errorCount":3,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"81"},{"filePath":"82","messages":"83","suppressedMessages":"84","errorCount":9,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"85"},{"filePath":"86","messages":"87","suppressedMessages":"88","errorCount":5,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"89"},{"filePath":"90","messages":"91","suppressedMessages":"92","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"93","messages":"94","suppressedMessages":"95","errorCount":10,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"96"},{"filePath":"97","messages":"98","suppressedMessages":"99","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"100","messages":"101","suppressedMessages":"102","errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"103"},{"filePath":"104","messages":"105","suppressedMessages":"106","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"107","messages":"108","suppressedMessages":"109","errorCount":2,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"110"},{"filePath":"111","messages":"112","suppressedMessages":"113","errorCount":3,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"114"},{"filePath":"115","messages":"116","suppressedMessages":"117","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"118","messages":"119","suppressedMessages":"120","errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"121"},{"filePath":"122","messages":"123","suppressedMessages":"124","errorCount":6,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"125"},{"filePath":"126","messages":"127","suppressedMessages":"128","errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"129"},{"filePath":"130","messages":"131","suppressedMessages":"132","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"133","messages":"134","suppressedMessages":"135","errorCount":2,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"136"},{"filePath":"137","messages":"138","suppressedMessages":"139","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"140","messages":"141","suppressedMessages":"142","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"143","messages":"144","suppressedMessages":"145","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"146","messages":"147","suppressedMessages":"148","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"149","messages":"150","suppressedMessages":"151","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},"/Users/simen/repos/jest/packages/jest-reporters/src/BaseReporter.ts",[],["152","153","154","155"],"/Users/simen/repos/jest/packages/jest-reporters/src/CoverageReporter.ts",["156","157","158","159","160","161","162","163","164","165","166","167","168","169","170","171","172"],[],"/**\n * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport * as path from 'path';\nimport {mergeProcessCovs} from '@bcoe/v8-coverage';\nimport type {EncodedSourceMap} from '@jridgewell/trace-mapping';\nimport chalk = require('chalk');\nimport glob = require('glob');\nimport * as fs from 'graceful-fs';\nimport istanbulCoverage = require('istanbul-lib-coverage');\nimport istanbulReport = require('istanbul-lib-report');\nimport libSourceMaps = require('istanbul-lib-source-maps');\nimport istanbulReports = require('istanbul-reports');\nimport v8toIstanbul = require('v8-to-istanbul');\nimport type {\n  AggregatedResult,\n  RuntimeTransformResult,\n  Test,\n  TestContext,\n  TestResult,\n  V8CoverageResult,\n} from '@jest/test-result';\nimport type {Config} from '@jest/types';\nimport {clearLine, isInteractive} from 'jest-util';\nimport {JestWorkerFarm, Worker} from 'jest-worker';\nimport BaseReporter from './BaseReporter';\nimport getWatermarks from './getWatermarks';\nimport type {ReporterContext} from './types';\n\ntype CoverageWorker = typeof import('./CoverageWorker');\n\nconst FAIL_COLOR = chalk.bold.red;\nconst RUNNING_TEST_COLOR = chalk.bold.dim;\n\nexport default class CoverageReporter extends BaseReporter {\n  private readonly _context: ReporterContext;\n  private readonly _coverageMap: istanbulCoverage.CoverageMap;\n  private readonly _globalConfig: Config.GlobalConfig;\n  private readonly _sourceMapStore: libSourceMaps.MapStore;\n  private readonly _v8CoverageResults: Array<V8CoverageResult>;\n\n  static readonly filename = __filename;\n\n  constructor(globalConfig: Config.GlobalConfig, context: ReporterContext) {\n    super();\n    this._context = context;\n    this._coverageMap = istanbulCoverage.createCoverageMap({});\n    this._globalConfig = globalConfig;\n    this._sourceMapStore = libSourceMaps.createSourceMapStore();\n    this._v8CoverageResults = [];\n  }\n\n  override onTestResult(_test: Test, testResult: TestResult): void {\n    if (testResult.v8Coverage) {\n      this._v8CoverageResults.push(testResult.v8Coverage);\n      return;\n    }\n\n    if (testResult.coverage) {\n      this._coverageMap.merge(testResult.coverage);\n    }\n  }\n\n  override async onRunComplete(\n    testContexts: Set<TestContext>,\n    aggregatedResults: AggregatedResult,\n  ): Promise<void> {\n    await this._addUntestedFiles(testContexts);\n    const {map, reportContext} = await this._getCoverageResult();\n\n    try {\n      const coverageReporters = this._globalConfig.coverageReporters || [];\n\n      if (!this._globalConfig.useStderr && coverageReporters.length < 1) {\n        coverageReporters.push('text-summary');\n      }\n      coverageReporters.forEach(reporter => {\n        let additionalOptions = {};\n        if (Array.isArray(reporter)) {\n          [reporter, additionalOptions] = reporter;\n        }\n        istanbulReports\n          .create(reporter, {\n            maxCols: process.stdout.columns || Infinity,\n            ...additionalOptions,\n          })\n          .execute(reportContext);\n      });\n      aggregatedResults.coverageMap = map;\n    } catch (e: any) {\n      console.error(\n        chalk.red(`\n        Failed to write coverage reports:\n        ERROR: ${e.toString()}\n        STACK: ${e.stack}\n      `),\n      );\n    }\n\n    this._checkThreshold(map);\n  }\n\n  private async _addUntestedFiles(\n    testContexts: Set<TestContext>,\n  ): Promise<void> {\n    const files: Array<{config: Config.ProjectConfig; path: string}> = [];\n\n    testContexts.forEach(context => {\n      const config = context.config;\n      if (\n        this._globalConfig.collectCoverageFrom &&\n        this._globalConfig.collectCoverageFrom.length\n      ) {\n        context.hasteFS\n          .matchFilesWithGlob(\n            this._globalConfig.collectCoverageFrom,\n            config.rootDir,\n          )\n          .forEach(filePath =>\n            files.push({\n              config,\n              path: filePath,\n            }),\n          );\n      }\n    });\n\n    if (!files.length) {\n      return;\n    }\n\n    if (isInteractive) {\n      process.stderr.write(\n        RUNNING_TEST_COLOR('Running coverage on untested files...'),\n      );\n    }\n\n    let worker:\n      | JestWorkerFarm<CoverageWorker>\n      | typeof import('./CoverageWorker');\n\n    if (this._globalConfig.maxWorkers <= 1) {\n      worker = require('./CoverageWorker');\n    } else {\n      worker = new Worker(require.resolve('./CoverageWorker'), {\n        exposedMethods: ['worker'],\n        forkOptions: {serialization: 'json'},\n        maxRetries: 2,\n        numWorkers: this._globalConfig.maxWorkers,\n      }) as JestWorkerFarm<CoverageWorker>;\n    }\n\n    const instrumentation = files.map(async fileObj => {\n      const filename = fileObj.path;\n      const config = fileObj.config;\n\n      const hasCoverageData = this._v8CoverageResults.some(v8Res =>\n        v8Res.some(innerRes => innerRes.result.url === filename),\n      );\n\n      if (\n        !hasCoverageData &&\n        !this._coverageMap.data[filename] &&\n        'worker' in worker\n      ) {\n        try {\n          const result = await worker.worker({\n            config,\n            context: {\n              changedFiles:\n                this._context.changedFiles &&\n                Array.from(this._context.changedFiles),\n              sourcesRelatedToTestsInChangedFiles:\n                this._context.sourcesRelatedToTestsInChangedFiles &&\n                Array.from(this._context.sourcesRelatedToTestsInChangedFiles),\n            },\n            globalConfig: this._globalConfig,\n            path: filename,\n          });\n\n          if (result) {\n            if (result.kind === 'V8Coverage') {\n              this._v8CoverageResults.push([\n                {codeTransformResult: undefined, result: result.result},\n              ]);\n            } else {\n              this._coverageMap.addFileCoverage(result.coverage);\n            }\n          }\n        } catch (error: any) {\n          console.error(\n            chalk.red(\n              [\n                `Failed to collect coverage from ${filename}`,\n                `ERROR: ${error.message}`,\n                `STACK: ${error.stack}`,\n              ].join('\\n'),\n            ),\n          );\n        }\n      }\n    });\n\n    try {\n      await Promise.all(instrumentation);\n    } catch {\n      // Do nothing; errors were reported earlier to the console.\n    }\n\n    if (isInteractive) {\n      clearLine(process.stderr);\n    }\n\n    if (worker && 'end' in worker && typeof worker.end === 'function') {\n      await worker.end();\n    }\n  }\n\n  private _checkThreshold(map: istanbulCoverage.CoverageMap) {\n    const {coverageThreshold} = this._globalConfig;\n\n    if (coverageThreshold) {\n      function check(\n        name: string,\n        thresholds: Config.CoverageThresholdValue,\n        actuals: istanbulCoverage.CoverageSummaryData,\n      ) {\n        return (\n          ['statements', 'branches', 'lines', 'functions'] as Array<\n            keyof istanbulCoverage.CoverageSummaryData\n          >\n        ).reduce<Array<string>>((errors, key) => {\n          const actual = actuals[key].pct;\n          const actualUncovered = actuals[key].total - actuals[key].covered;\n          const threshold = thresholds[key];\n\n          if (threshold !== undefined) {\n            if (threshold < 0) {\n              if (threshold * -1 < actualUncovered) {\n                errors.push(\n                  `Jest: Uncovered count for ${key} (${actualUncovered}) ` +\n                    `exceeds ${name} threshold (${-1 * threshold})`,\n                );\n              }\n            } else if (actual < threshold) {\n              errors.push(\n                `Jest: \"${name}\" coverage threshold for ${key} (${threshold}%) not met: ${actual}%`,\n              );\n            }\n          }\n          return errors;\n        }, []);\n      }\n\n      const THRESHOLD_GROUP_TYPES = {\n        GLOB: 'glob',\n        GLOBAL: 'global',\n        PATH: 'path',\n      };\n      const coveredFiles = map.files();\n      const thresholdGroups = Object.keys(coverageThreshold);\n      const groupTypeByThresholdGroup: {[index: string]: string} = {};\n      const filesByGlob: {[index: string]: Array<string>} = {};\n\n      const coveredFilesSortedIntoThresholdGroup = coveredFiles.reduce<\n        Array<[string, string | undefined]>\n      >((files, file) => {\n        const pathOrGlobMatches = thresholdGroups.reduce<\n          Array<[string, string]>\n        >((agg, thresholdGroup) => {\n          // Preserve trailing slash, but not required if root dir\n          // See https://github.com/facebook/jest/issues/12703\n          const resolvedThresholdGroup = path.resolve(thresholdGroup);\n          const suffix =\n            (thresholdGroup.endsWith(path.sep) ||\n              (process.platform === 'win32' && thresholdGroup.endsWith('/'))) &&\n            !resolvedThresholdGroup.endsWith(path.sep)\n              ? path.sep\n              : '';\n          const absoluteThresholdGroup = `${resolvedThresholdGroup}${suffix}`;\n\n          // The threshold group might be a path:\n\n          if (file.indexOf(absoluteThresholdGroup) === 0) {\n            groupTypeByThresholdGroup[thresholdGroup] =\n              THRESHOLD_GROUP_TYPES.PATH;\n            return agg.concat([[file, thresholdGroup]]);\n          }\n\n          // If the threshold group is not a path it might be a glob:\n\n          // Note: glob.sync is slow. By memoizing the files matching each glob\n          // (rather than recalculating it for each covered file) we save a tonne\n          // of execution time.\n          if (filesByGlob[absoluteThresholdGroup] === undefined) {\n            filesByGlob[absoluteThresholdGroup] = glob\n              .sync(absoluteThresholdGroup)\n              .map(filePath => path.resolve(filePath));\n          }\n\n          if (filesByGlob[absoluteThresholdGroup].indexOf(file) > -1) {\n            groupTypeByThresholdGroup[thresholdGroup] =\n              THRESHOLD_GROUP_TYPES.GLOB;\n            return agg.concat([[file, thresholdGroup]]);\n          }\n\n          return agg;\n        }, []);\n\n        if (pathOrGlobMatches.length > 0) {\n          return files.concat(pathOrGlobMatches);\n        }\n\n        // Neither a glob or a path? Toss it in global if there's a global threshold:\n        if (thresholdGroups.indexOf(THRESHOLD_GROUP_TYPES.GLOBAL) > -1) {\n          groupTypeByThresholdGroup[THRESHOLD_GROUP_TYPES.GLOBAL] =\n            THRESHOLD_GROUP_TYPES.GLOBAL;\n          return files.concat([[file, THRESHOLD_GROUP_TYPES.GLOBAL]]);\n        }\n\n        // A covered file that doesn't have a threshold:\n        return files.concat([[file, undefined]]);\n      }, []);\n\n      const getFilesInThresholdGroup = (thresholdGroup: string) =>\n        coveredFilesSortedIntoThresholdGroup\n          .filter(fileAndGroup => fileAndGroup[1] === thresholdGroup)\n          .map(fileAndGroup => fileAndGroup[0]);\n\n      function combineCoverage(filePaths: Array<string>) {\n        return filePaths\n          .map(filePath => map.fileCoverageFor(filePath))\n          .reduce(\n            (\n              combinedCoverage:\n                | istanbulCoverage.CoverageSummary\n                | null\n                | undefined,\n              nextFileCoverage: istanbulCoverage.FileCoverage,\n            ) => {\n              if (combinedCoverage === undefined || combinedCoverage === null) {\n                return nextFileCoverage.toSummary();\n              }\n              return combinedCoverage.merge(nextFileCoverage.toSummary());\n            },\n            undefined,\n          );\n      }\n\n      let errors: Array<string> = [];\n\n      thresholdGroups.forEach(thresholdGroup => {\n        switch (groupTypeByThresholdGroup[thresholdGroup]) {\n          case THRESHOLD_GROUP_TYPES.GLOBAL: {\n            const coverage = combineCoverage(\n              getFilesInThresholdGroup(THRESHOLD_GROUP_TYPES.GLOBAL),\n            );\n            if (coverage) {\n              errors = errors.concat(\n                check(\n                  thresholdGroup,\n                  coverageThreshold[thresholdGroup],\n                  coverage,\n                ),\n              );\n            }\n            break;\n          }\n          case THRESHOLD_GROUP_TYPES.PATH: {\n            const coverage = combineCoverage(\n              getFilesInThresholdGroup(thresholdGroup),\n            );\n            if (coverage) {\n              errors = errors.concat(\n                check(\n                  thresholdGroup,\n                  coverageThreshold[thresholdGroup],\n                  coverage,\n                ),\n              );\n            }\n            break;\n          }\n          case THRESHOLD_GROUP_TYPES.GLOB:\n            getFilesInThresholdGroup(thresholdGroup).forEach(\n              fileMatchingGlob => {\n                errors = errors.concat(\n                  check(\n                    fileMatchingGlob,\n                    coverageThreshold[thresholdGroup],\n                    map.fileCoverageFor(fileMatchingGlob).toSummary(),\n                  ),\n                );\n              },\n            );\n            break;\n          default:\n            // If the file specified by path is not found, error is returned.\n            if (thresholdGroup !== THRESHOLD_GROUP_TYPES.GLOBAL) {\n              errors = errors.concat(\n                `Jest: Coverage data for ${thresholdGroup} was not found.`,\n              );\n            }\n          // Sometimes all files in the coverage data are matched by\n          // PATH and GLOB threshold groups in which case, don't error when\n          // the global threshold group doesn't match any files.\n        }\n      });\n\n      errors = errors.filter(\n        err => err !== undefined && err !== null && err.length > 0,\n      );\n\n      if (errors.length > 0) {\n        this.log(`${FAIL_COLOR(errors.join('\\n'))}`);\n        this._setError(new Error(errors.join('\\n')));\n      }\n    }\n  }\n\n  private async _getCoverageResult(): Promise<{\n    map: istanbulCoverage.CoverageMap;\n    reportContext: istanbulReport.Context;\n  }> {\n    if (this._globalConfig.coverageProvider === 'v8') {\n      const mergedCoverages = mergeProcessCovs(\n        this._v8CoverageResults.map(cov => ({result: cov.map(r => r.result)})),\n      );\n\n      const fileTransforms = new Map<string, RuntimeTransformResult>();\n\n      this._v8CoverageResults.forEach(res =>\n        res.forEach(r => {\n          if (r.codeTransformResult && !fileTransforms.has(r.result.url)) {\n            fileTransforms.set(r.result.url, r.codeTransformResult);\n          }\n        }),\n      );\n\n      const transformedCoverage = await Promise.all(\n        mergedCoverages.result.map(async res => {\n          const fileTransform = fileTransforms.get(res.url);\n\n          let sourcemapContent: EncodedSourceMap | undefined = undefined;\n\n          if (\n            fileTransform?.sourceMapPath &&\n            fs.existsSync(fileTransform.sourceMapPath)\n          ) {\n            sourcemapContent = JSON.parse(\n              fs.readFileSync(fileTransform.sourceMapPath, 'utf8'),\n            );\n          }\n\n          const converter = v8toIstanbul(\n            res.url,\n            fileTransform?.wrapperLength ?? 0,\n            fileTransform && sourcemapContent\n              ? {\n                  originalSource: fileTransform.originalCode,\n                  source: fileTransform.code,\n                  sourceMap: {\n                    sourcemap: {file: res.url, ...sourcemapContent},\n                  },\n                }\n              : {source: fs.readFileSync(res.url, 'utf8')},\n          );\n\n          await converter.load();\n\n          converter.applyCoverage(res.functions);\n\n          const istanbulData = converter.toIstanbul();\n\n          return istanbulData;\n        }),\n      );\n\n      const map = istanbulCoverage.createCoverageMap({});\n\n      transformedCoverage.forEach(res => map.merge(res));\n\n      const reportContext = istanbulReport.createContext({\n        coverageMap: map,\n        dir: this._globalConfig.coverageDirectory,\n        watermarks: getWatermarks(this._globalConfig),\n      });\n\n      return {map, reportContext};\n    }\n\n    const map = await this._sourceMapStore.transformCoverage(this._coverageMap);\n    const reportContext = istanbulReport.createContext({\n      coverageMap: map,\n      dir: this._globalConfig.coverageDirectory,\n      sourceFinder: this._sourceMapStore.sourceFinder,\n      watermarks: getWatermarks(this._globalConfig),\n    });\n\n    return {map, reportContext};\n  }\n}\n","/Users/simen/repos/jest/packages/jest-reporters/src/CoverageWorker.ts",[],[],"/Users/simen/repos/jest/packages/jest-reporters/src/DefaultReporter.ts",["173","174"],[],"/**\n * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport chalk = require('chalk');\nimport {getConsoleOutput} from '@jest/console';\nimport type {\n  AggregatedResult,\n  Test,\n  TestCaseResult,\n  TestResult,\n} from '@jest/test-result';\nimport type {Config} from '@jest/types';\nimport {\n  formatStackTrace,\n  indentAllLines,\n  separateMessageFromStack,\n} from 'jest-message-util';\nimport {clearLine, isInteractive} from 'jest-util';\nimport BaseReporter from './BaseReporter';\nimport Status from './Status';\nimport getResultHeader from './getResultHeader';\nimport getSnapshotStatus from './getSnapshotStatus';\nimport type {ReporterOnStartOptions} from './types';\n\ntype write = NodeJS.WriteStream['write'];\ntype FlushBufferedOutput = () => void;\n\nconst TITLE_BULLET = chalk.bold('\\u25cf ');\n\nexport default class DefaultReporter extends BaseReporter {\n  private _clear: string; // ANSI clear sequence for the last printed status\n  private readonly _err: write;\n  protected _globalConfig: Config.GlobalConfig;\n  private readonly _out: write;\n  private readonly _status: Status;\n  private readonly _bufferedOutput: Set<FlushBufferedOutput>;\n\n  static readonly filename = __filename;\n\n  constructor(globalConfig: Config.GlobalConfig) {\n    super();\n    this._globalConfig = globalConfig;\n    this._clear = '';\n    this._out = process.stdout.write.bind(process.stdout);\n    this._err = process.stderr.write.bind(process.stderr);\n    this._status = new Status(globalConfig);\n    this._bufferedOutput = new Set();\n    this.__wrapStdio(process.stdout);\n    this.__wrapStdio(process.stderr);\n    this._status.onChange(() => {\n      this.__clearStatus();\n      this.__printStatus();\n    });\n  }\n\n  protected __wrapStdio(\n    stream: NodeJS.WritableStream | NodeJS.WriteStream,\n  ): void {\n    const write = stream.write.bind(stream);\n\n    let buffer: Array<string> = [];\n    let timeout: NodeJS.Timeout | null = null;\n\n    const flushBufferedOutput = () => {\n      const string = buffer.join('');\n      buffer = [];\n\n      // This is to avoid conflicts between random output and status text\n      this.__clearStatus();\n      if (string) {\n        write(string);\n      }\n      this.__printStatus();\n\n      this._bufferedOutput.delete(flushBufferedOutput);\n    };\n\n    this._bufferedOutput.add(flushBufferedOutput);\n\n    const debouncedFlush = () => {\n      // If the process blows up no errors would be printed.\n      // There should be a smart way to buffer stderr, but for now\n      // we just won't buffer it.\n      if (stream === process.stderr) {\n        flushBufferedOutput();\n      } else {\n        if (!timeout) {\n          timeout = setTimeout(() => {\n            flushBufferedOutput();\n            timeout = null;\n          }, 100);\n        }\n      }\n    };\n\n    stream.write = (chunk: string) => {\n      buffer.push(chunk);\n      debouncedFlush();\n      return true;\n    };\n  }\n\n  // Don't wait for the debounced call and flush all output immediately.\n  forceFlushBufferedOutput(): void {\n    for (const flushBufferedOutput of this._bufferedOutput) {\n      flushBufferedOutput();\n    }\n  }\n\n  protected __clearStatus(): void {\n    if (isInteractive) {\n      if (this._globalConfig.useStderr) {\n        this._err(this._clear);\n      } else {\n        this._out(this._clear);\n      }\n    }\n  }\n\n  protected __printStatus(): void {\n    const {content, clear} = this._status.get();\n    this._clear = clear;\n    if (isInteractive) {\n      if (this._globalConfig.useStderr) {\n        this._err(content);\n      } else {\n        this._out(content);\n      }\n    }\n  }\n\n  override onRunStart(\n    aggregatedResults: AggregatedResult,\n    options: ReporterOnStartOptions,\n  ): void {\n    this._status.runStarted(aggregatedResults, options);\n  }\n\n  override onTestStart(test: Test): void {\n    this._status.testStarted(test.path, test.context.config);\n  }\n\n  override onTestCaseResult(test: Test, testCaseResult: TestCaseResult): void {\n    this._status.addTestCaseResult(test, testCaseResult);\n  }\n\n  override onRunComplete(): void {\n    this.forceFlushBufferedOutput();\n    this._status.runFinished();\n    process.stdout.write = this._out;\n    process.stderr.write = this._err;\n    clearLine(process.stderr);\n  }\n\n  override onTestResult(\n    test: Test,\n    testResult: TestResult,\n    aggregatedResults: AggregatedResult,\n  ): void {\n    this.testFinished(test.context.config, testResult, aggregatedResults);\n    if (!testResult.skipped) {\n      this.printTestFileHeader(\n        testResult.testFilePath,\n        test.context.config,\n        testResult,\n      );\n      this.printTestFileFailureMessage(\n        testResult.testFilePath,\n        test.context.config,\n        testResult,\n      );\n    }\n    this.forceFlushBufferedOutput();\n  }\n\n  testFinished(\n    config: Config.ProjectConfig,\n    testResult: TestResult,\n    aggregatedResults: AggregatedResult,\n  ): void {\n    this._status.testFinished(config, testResult, aggregatedResults);\n  }\n\n  printTestFileHeader(\n    testPath: string,\n    config: Config.ProjectConfig,\n    result: TestResult,\n  ): void {\n    // log retry errors if any exist\n    result.testResults.forEach(testResult => {\n      const testRetryReasons = testResult.retryReasons;\n      if (testRetryReasons && testRetryReasons.length > 0) {\n        this.log(\n          `${chalk.reset.inverse.bold.yellow(\n            ' LOGGING RETRY ERRORS ',\n          )} ${chalk.bold(testResult.fullName)}`,\n        );\n        testRetryReasons.forEach((retryReasons, index) => {\n          let {message, stack} = separateMessageFromStack(retryReasons);\n          stack = this._globalConfig.noStackTrace\n            ? ''\n            : chalk.dim(\n                formatStackTrace(stack, config, this._globalConfig, testPath),\n              );\n\n          message = indentAllLines(message);\n\n          this.log(\n            `${chalk.reset.inverse.bold.blueBright(` RETRY ${index + 1} `)}\\n`,\n          );\n          this.log(`${message}\\n${stack}\\n`);\n        });\n      }\n    });\n\n    this.log(getResultHeader(result, this._globalConfig, config));\n    if (result.console) {\n      this.log(\n        `  ${TITLE_BULLET}Console\\n\\n${getConsoleOutput(\n          result.console,\n          config,\n          this._globalConfig,\n        )}`,\n      );\n    }\n  }\n\n  printTestFileFailureMessage(\n    _testPath: string,\n    _config: Config.ProjectConfig,\n    result: TestResult,\n  ): void {\n    if (result.failureMessage) {\n      this.log(result.failureMessage);\n    }\n    const didUpdate = this._globalConfig.updateSnapshot === 'all';\n    const snapshotStatuses = getSnapshotStatus(result.snapshot, didUpdate);\n    snapshotStatuses.forEach(this.log);\n  }\n}\n","/Users/simen/repos/jest/packages/jest-reporters/src/GitHubActionsReporter.ts",["175","176"],[],"/**\n * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport stripAnsi = require('strip-ansi');\nimport type {Test, TestResult} from '@jest/test-result';\nimport type {Config} from '@jest/types';\nimport {\n  formatPath,\n  getStackTraceLines,\n  getTopFrame,\n  separateMessageFromStack,\n} from 'jest-message-util';\nimport BaseReporter from './BaseReporter';\n\ntype AnnotationOptions = {\n  file?: string;\n  line?: number | string;\n  message: string;\n  title: string;\n  type: 'error' | 'warning';\n};\n\nconst titleSeparator = ' \\u203A ';\n\nexport default class GitHubActionsReporter extends BaseReporter {\n  static readonly filename = __filename;\n\n  onTestFileResult({context}: Test, {testResults}: TestResult): void {\n    testResults.forEach(result => {\n      const title = [...result.ancestorTitles, result.title].join(\n        titleSeparator,\n      );\n\n      result.retryReasons?.forEach((retryReason, index) => {\n        this.#createAnnotation({\n          ...this.#getMessageDetails(retryReason, context.config),\n          title: `RETRY ${index + 1}: ${title}`,\n          type: 'warning',\n        });\n      });\n\n      result.failureMessages.forEach(failureMessage => {\n        this.#createAnnotation({\n          ...this.#getMessageDetails(failureMessage, context.config),\n          title,\n          type: 'error',\n        });\n      });\n    });\n  }\n\n  #getMessageDetails(failureMessage: string, config: Config.ProjectConfig) {\n    const {message, stack} = separateMessageFromStack(failureMessage);\n\n    const stackLines = getStackTraceLines(stack);\n    const topFrame = getTopFrame(stackLines);\n\n    const normalizedStackLines = stackLines.map(line =>\n      formatPath(line, config),\n    );\n    const messageText = [message, ...normalizedStackLines].join('\\n');\n\n    return {\n      file: topFrame?.file,\n      line: topFrame?.line,\n      message: messageText,\n    };\n  }\n\n  #createAnnotation({file, line, message, title, type}: AnnotationOptions) {\n    message = stripAnsi(\n      // copied from: https://github.com/actions/toolkit/blob/main/packages/core/src/command.ts\n      message.replace(/%/g, '%25').replace(/\\r/g, '%0D').replace(/\\n/g, '%0A'),\n    );\n\n    this.log(\n      `\\n::${type} file=${file},line=${line},title=${title}::${message}`,\n    );\n  }\n}\n","/Users/simen/repos/jest/packages/jest-reporters/src/NotifyReporter.ts",["177","178","179","180","181","182","183","184","185","186","187","188","189"],[],"/**\n * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport * as path from 'path';\nimport * as util from 'util';\nimport exit = require('exit');\nimport type {AggregatedResult, TestContext} from '@jest/test-result';\nimport type {Config} from '@jest/types';\nimport {pluralize} from 'jest-util';\nimport BaseReporter from './BaseReporter';\nimport type {ReporterContext} from './types';\n\nconst isDarwin = process.platform === 'darwin';\n\nconst icon = path.resolve(__dirname, '../assets/jest_logo.png');\n\nexport default class NotifyReporter extends BaseReporter {\n  private readonly _notifier = loadNotifier();\n  private readonly _globalConfig: Config.GlobalConfig;\n  private _context: ReporterContext;\n\n  static readonly filename = __filename;\n\n  constructor(globalConfig: Config.GlobalConfig, context: ReporterContext) {\n    super();\n    this._globalConfig = globalConfig;\n    this._context = context;\n  }\n\n  override onRunComplete(\n    testContexts: Set<TestContext>,\n    result: AggregatedResult,\n  ): void {\n    const success =\n      result.numFailedTests === 0 && result.numRuntimeErrorTestSuites === 0;\n\n    const firstContext = testContexts.values().next();\n\n    const hasteFS =\n      firstContext && firstContext.value && firstContext.value.hasteFS;\n\n    let packageName;\n    if (hasteFS != null) {\n      // assuming root package.json is the first one\n      const [filePath] = hasteFS.matchFiles('package.json');\n\n      packageName =\n        filePath != null\n          ? hasteFS.getModuleName(filePath)\n          : this._globalConfig.rootDir;\n    } else {\n      packageName = this._globalConfig.rootDir;\n    }\n\n    packageName = packageName != null ? `${packageName} - ` : '';\n\n    const notifyMode = this._globalConfig.notifyMode;\n    const statusChanged =\n      this._context.previousSuccess !== success || this._context.firstRun;\n    const testsHaveRun = result.numTotalTests !== 0;\n\n    if (\n      testsHaveRun &&\n      success &&\n      (notifyMode === 'always' ||\n        notifyMode === 'success' ||\n        notifyMode === 'success-change' ||\n        (notifyMode === 'change' && statusChanged) ||\n        (notifyMode === 'failure-change' && statusChanged))\n    ) {\n      const title = util.format('%s%d%% Passed', packageName, 100);\n      const message = `${isDarwin ? '\\u2705 ' : ''}${pluralize(\n        'test',\n        result.numPassedTests,\n      )} passed`;\n\n      this._notifier.notify({\n        hint: 'int:transient:1',\n        icon,\n        message,\n        timeout: false,\n        title,\n      });\n    } else if (\n      testsHaveRun &&\n      !success &&\n      (notifyMode === 'always' ||\n        notifyMode === 'failure' ||\n        notifyMode === 'failure-change' ||\n        (notifyMode === 'change' && statusChanged) ||\n        (notifyMode === 'success-change' && statusChanged))\n    ) {\n      const failed = result.numFailedTests / result.numTotalTests;\n\n      const title = util.format(\n        '%s%d%% Failed',\n        packageName,\n        Math.ceil(Number.isNaN(failed) ? 0 : failed * 100),\n      );\n      const message = util.format(\n        `${isDarwin ? '\\u26D4\\uFE0F ' : ''}%d of %d tests failed`,\n        result.numFailedTests,\n        result.numTotalTests,\n      );\n\n      const watchMode = this._globalConfig.watch || this._globalConfig.watchAll;\n      const restartAnswer = 'Run again';\n      const quitAnswer = 'Exit tests';\n\n      if (!watchMode) {\n        this._notifier.notify({\n          hint: 'int:transient:1',\n          icon,\n          message,\n          timeout: false,\n          title,\n        });\n      } else {\n        this._notifier.notify(\n          {\n            // @ts-expect-error - not all options are supported by all systems (specifically `actions` and `hint`)\n            actions: [restartAnswer, quitAnswer],\n            closeLabel: 'Close',\n            hint: 'int:transient:1',\n            icon,\n            message,\n            timeout: false,\n            title,\n          },\n          (err, _, metadata) => {\n            if (err || !metadata) {\n              return;\n            }\n            if (metadata.activationValue === quitAnswer) {\n              exit(0);\n              return;\n            }\n            if (\n              metadata.activationValue === restartAnswer &&\n              this._context.startRun\n            ) {\n              this._context.startRun(this._globalConfig);\n            }\n          },\n        );\n      }\n    }\n\n    this._context.previousSuccess = success;\n    this._context.firstRun = false;\n  }\n}\n\nfunction loadNotifier(): typeof import('node-notifier') {\n  try {\n    return require('node-notifier');\n  } catch (err: any) {\n    if (err.code !== 'MODULE_NOT_FOUND') {\n      throw err;\n    }\n\n    throw Error(\n      'notify reporter requires optional peer dependency \"node-notifier\" but it was not found',\n    );\n  }\n}\n","/Users/simen/repos/jest/packages/jest-reporters/src/Status.ts",["190","191","192"],[],"/**\n * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport chalk = require('chalk');\nimport stringLength = require('string-length');\nimport type {\n  AggregatedResult,\n  Test,\n  TestCaseResult,\n  TestResult,\n} from '@jest/test-result';\nimport type {Config} from '@jest/types';\nimport getSummary from './getSummary';\nimport printDisplayName from './printDisplayName';\nimport trimAndFormatPath from './trimAndFormatPath';\nimport type {ReporterOnStartOptions} from './types';\nimport wrapAnsiString from './wrapAnsiString';\n\nconst RUNNING_TEXT = ' RUNS ';\nconst RUNNING = `${chalk.reset.inverse.yellow.bold(RUNNING_TEXT)} `;\n\n/**\n * This class is a perf optimization for sorting the list of currently\n * running tests. It tries to keep tests in the same positions without\n * shifting the whole list.\n */\nclass CurrentTestList {\n  private _array: Array<{\n    testPath: string;\n    config: Config.ProjectConfig;\n  } | null>;\n\n  constructor() {\n    this._array = [];\n  }\n\n  add(testPath: string, config: Config.ProjectConfig) {\n    const index = this._array.indexOf(null);\n    const record = {config, testPath};\n    if (index !== -1) {\n      this._array[index] = record;\n    } else {\n      this._array.push(record);\n    }\n  }\n\n  delete(testPath: string) {\n    const record = this._array.find(\n      record => record !== null && record.testPath === testPath,\n    );\n    this._array[this._array.indexOf(record || null)] = null;\n  }\n\n  get() {\n    return this._array;\n  }\n}\n\ntype Cache = {\n  content: string;\n  clear: string;\n};\n\n/**\n * A class that generates the CLI status of currently running tests\n * and also provides an ANSI escape sequence to remove status lines\n * from the terminal.\n */\nexport default class Status {\n  private _cache: Cache | null;\n  private _callback?: () => void;\n  private readonly _currentTests: CurrentTestList;\n  private _currentTestCases: Array<{\n    test: Test;\n    testCaseResult: TestCaseResult;\n  }>;\n  private _done: boolean;\n  private _emitScheduled: boolean;\n  private _estimatedTime: number;\n  private _interval?: NodeJS.Timeout;\n  private _aggregatedResults?: AggregatedResult;\n  private _showStatus: boolean;\n\n  constructor(private readonly _globalConfig: Config.GlobalConfig) {\n    this._cache = null;\n    this._currentTests = new CurrentTestList();\n    this._currentTestCases = [];\n    this._done = false;\n    this._emitScheduled = false;\n    this._estimatedTime = 0;\n    this._showStatus = false;\n  }\n\n  onChange(callback: () => void): void {\n    this._callback = callback;\n  }\n\n  runStarted(\n    aggregatedResults: AggregatedResult,\n    options: ReporterOnStartOptions,\n  ): void {\n    this._estimatedTime = (options && options.estimatedTime) || 0;\n    this._showStatus = options && options.showStatus;\n    this._interval = setInterval(() => this._tick(), 1000);\n    this._aggregatedResults = aggregatedResults;\n    this._debouncedEmit();\n  }\n\n  runFinished(): void {\n    this._done = true;\n    if (this._interval) clearInterval(this._interval);\n    this._emit();\n  }\n\n  addTestCaseResult(test: Test, testCaseResult: TestCaseResult): void {\n    this._currentTestCases.push({test, testCaseResult});\n    if (!this._showStatus) {\n      this._emit();\n    } else {\n      this._debouncedEmit();\n    }\n  }\n\n  testStarted(testPath: string, config: Config.ProjectConfig): void {\n    this._currentTests.add(testPath, config);\n    if (!this._showStatus) {\n      this._emit();\n    } else {\n      this._debouncedEmit();\n    }\n  }\n\n  testFinished(\n    _config: Config.ProjectConfig,\n    testResult: TestResult,\n    aggregatedResults: AggregatedResult,\n  ): void {\n    const {testFilePath} = testResult;\n    this._aggregatedResults = aggregatedResults;\n    this._currentTests.delete(testFilePath);\n    this._currentTestCases = this._currentTestCases.filter(({test}) => {\n      if (_config !== test.context.config) {\n        return true;\n      }\n      return test.path !== testFilePath;\n    });\n    this._debouncedEmit();\n  }\n\n  get(): Cache {\n    if (this._cache) {\n      return this._cache;\n    }\n\n    if (this._done) {\n      return {clear: '', content: ''};\n    }\n\n    const width = process.stdout.columns;\n    let content = '\\n';\n    this._currentTests.get().forEach(record => {\n      if (record) {\n        const {config, testPath} = record;\n\n        const projectDisplayName = config.displayName\n          ? `${printDisplayName(config)} `\n          : '';\n        const prefix = RUNNING + projectDisplayName;\n\n        content += `${wrapAnsiString(\n          prefix +\n            trimAndFormatPath(stringLength(prefix), config, testPath, width),\n          width,\n        )}\\n`;\n      }\n    });\n\n    if (this._showStatus && this._aggregatedResults) {\n      content += `\\n${getSummary(this._aggregatedResults, {\n        currentTestCases: this._currentTestCases,\n        estimatedTime: this._estimatedTime,\n        roundTime: true,\n        seed: this._globalConfig.seed,\n        showSeed: this._globalConfig.showSeed,\n        width,\n      })}`;\n    }\n\n    let height = 0;\n\n    for (let i = 0; i < content.length; i++) {\n      if (content[i] === '\\n') {\n        height++;\n      }\n    }\n\n    const clear = '\\r\\x1B[K\\r\\x1B[1A'.repeat(height);\n    return (this._cache = {clear, content});\n  }\n\n  private _emit() {\n    this._cache = null;\n    if (this._callback) this._callback();\n  }\n\n  private _debouncedEmit() {\n    if (!this._emitScheduled) {\n      // Perf optimization to avoid two separate renders When\n      // one test finishes and another test starts executing.\n      this._emitScheduled = true;\n      setTimeout(() => {\n        this._emit();\n        this._emitScheduled = false;\n      }, 100);\n    }\n  }\n\n  private _tick() {\n    this._debouncedEmit();\n  }\n}\n","/Users/simen/repos/jest/packages/jest-reporters/src/SummaryReporter.ts",["193","194","195","196","197","198","199","200","201"],[],"/**\n * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport chalk = require('chalk');\nimport type {\n  AggregatedResult,\n  SnapshotSummary,\n  TestContext,\n} from '@jest/test-result';\nimport type {Config} from '@jest/types';\nimport {testPathPatternToRegExp} from 'jest-util';\nimport BaseReporter from './BaseReporter';\nimport getResultHeader from './getResultHeader';\nimport getSnapshotSummary from './getSnapshotSummary';\nimport getSummary from './getSummary';\nimport type {ReporterOnStartOptions} from './types';\n\nconst TEST_SUMMARY_THRESHOLD = 20;\n\nconst NPM_EVENTS = new Set([\n  'prepublish',\n  'publish',\n  'postpublish',\n  'preinstall',\n  'install',\n  'postinstall',\n  'preuninstall',\n  'uninstall',\n  'postuninstall',\n  'preversion',\n  'version',\n  'postversion',\n  'pretest',\n  'test',\n  'posttest',\n  'prestop',\n  'stop',\n  'poststop',\n  'prestart',\n  'start',\n  'poststart',\n  'prerestart',\n  'restart',\n  'postrestart',\n]);\n\nconst {npm_config_user_agent, npm_lifecycle_event, npm_lifecycle_script} =\n  process.env;\n\nexport default class SummaryReporter extends BaseReporter {\n  private _estimatedTime: number;\n  private readonly _globalConfig: Config.GlobalConfig;\n\n  static readonly filename = __filename;\n\n  constructor(globalConfig: Config.GlobalConfig) {\n    super();\n    this._globalConfig = globalConfig;\n    this._estimatedTime = 0;\n  }\n\n  // If we write more than one character at a time it is possible that\n  // Node.js exits in the middle of printing the result. This was first observed\n  // in Node.js 0.10 and still persists in Node.js 6.7+.\n  // Let's print the test failure summary character by character which is safer\n  // when hundreds of tests are failing.\n  private _write(string: string) {\n    for (let i = 0; i < string.length; i++) {\n      process.stderr.write(string.charAt(i));\n    }\n  }\n\n  override onRunStart(\n    aggregatedResults: AggregatedResult,\n    options: ReporterOnStartOptions,\n  ): void {\n    super.onRunStart(aggregatedResults, options);\n    this._estimatedTime = options.estimatedTime;\n  }\n\n  override onRunComplete(\n    testContexts: Set<TestContext>,\n    aggregatedResults: AggregatedResult,\n  ): void {\n    const {numTotalTestSuites, testResults, wasInterrupted} = aggregatedResults;\n    if (numTotalTestSuites) {\n      const lastResult = testResults[testResults.length - 1];\n      // Print a newline if the last test did not fail to line up newlines\n      // similar to when an error would have been thrown in the test.\n      if (\n        !this._globalConfig.verbose &&\n        lastResult &&\n        !lastResult.numFailingTests &&\n        !lastResult.testExecError\n      ) {\n        this.log('');\n      }\n\n      this._printSummary(aggregatedResults, this._globalConfig);\n      this._printSnapshotSummary(\n        aggregatedResults.snapshot,\n        this._globalConfig,\n      );\n\n      if (numTotalTestSuites) {\n        let message = getSummary(aggregatedResults, {\n          estimatedTime: this._estimatedTime,\n          seed: this._globalConfig.seed,\n          showSeed: this._globalConfig.showSeed,\n        });\n\n        if (!this._globalConfig.silent) {\n          message += `\\n${\n            wasInterrupted\n              ? chalk.bold.red('Test run was interrupted.')\n              : this._getTestSummary(testContexts, this._globalConfig)\n          }`;\n        }\n        this.log(message);\n      }\n    }\n  }\n\n  private _printSnapshotSummary(\n    snapshots: SnapshotSummary,\n    globalConfig: Config.GlobalConfig,\n  ) {\n    if (\n      snapshots.added ||\n      snapshots.filesRemoved ||\n      snapshots.unchecked ||\n      snapshots.unmatched ||\n      snapshots.updated\n    ) {\n      let updateCommand;\n      const event = npm_lifecycle_event || '';\n      const prefix = NPM_EVENTS.has(event) ? '' : 'run ';\n      const isYarn =\n        typeof npm_config_user_agent === 'string' &&\n        npm_config_user_agent.includes('yarn');\n      const client = isYarn ? 'yarn' : 'npm';\n      const scriptUsesJest =\n        typeof npm_lifecycle_script === 'string' &&\n        npm_lifecycle_script.includes('jest');\n\n      if (globalConfig.watch || globalConfig.watchAll) {\n        updateCommand = 'press `u`';\n      } else if (event && scriptUsesJest) {\n        updateCommand = `run \\`${`${client} ${prefix}${event}${\n          isYarn ? '' : ' --'\n        }`} -u\\``;\n      } else {\n        updateCommand = 're-run jest with `-u`';\n      }\n\n      const snapshotSummary = getSnapshotSummary(\n        snapshots,\n        globalConfig,\n        updateCommand,\n      );\n      snapshotSummary.forEach(this.log);\n\n      this.log(''); // print empty line\n    }\n  }\n\n  private _printSummary(\n    aggregatedResults: AggregatedResult,\n    globalConfig: Config.GlobalConfig,\n  ) {\n    // If there were any failing tests and there was a large number of tests\n    // executed, re-print the failing results at the end of execution output.\n    const failedTests = aggregatedResults.numFailedTests;\n    const runtimeErrors = aggregatedResults.numRuntimeErrorTestSuites;\n    if (\n      failedTests + runtimeErrors > 0 &&\n      aggregatedResults.numTotalTestSuites > TEST_SUMMARY_THRESHOLD\n    ) {\n      this.log(chalk.bold('Summary of all failing tests'));\n      aggregatedResults.testResults.forEach(testResult => {\n        const {failureMessage} = testResult;\n        if (failureMessage) {\n          this._write(\n            `${getResultHeader(testResult, globalConfig)}\\n${failureMessage}\\n`,\n          );\n        }\n      });\n      this.log(''); // print empty line\n    }\n  }\n\n  private _getTestSummary(\n    testContexts: Set<TestContext>,\n    globalConfig: Config.GlobalConfig,\n  ) {\n    const getMatchingTestsInfo = () => {\n      const prefix = globalConfig.findRelatedTests\n        ? ' related to files matching '\n        : ' matching ';\n\n      return (\n        chalk.dim(prefix) +\n        testPathPatternToRegExp(globalConfig.testPathPattern).toString()\n      );\n    };\n\n    let testInfo = '';\n\n    if (globalConfig.runTestsByPath) {\n      testInfo = chalk.dim(' within paths');\n    } else if (globalConfig.onlyChanged) {\n      testInfo = chalk.dim(' related to changed files');\n    } else if (globalConfig.testPathPattern) {\n      testInfo = getMatchingTestsInfo();\n    }\n\n    let nameInfo = '';\n\n    if (globalConfig.runTestsByPath) {\n      nameInfo = ` ${globalConfig.nonFlagArgs.map(p => `\"${p}\"`).join(', ')}`;\n    } else if (globalConfig.testNamePattern) {\n      nameInfo = `${chalk.dim(' with tests matching ')}\"${\n        globalConfig.testNamePattern\n      }\"`;\n    }\n\n    const contextInfo =\n      testContexts.size > 1\n        ? chalk.dim(' in ') + testContexts.size + chalk.dim(' projects')\n        : '';\n\n    return (\n      chalk.dim('Ran all test suites') +\n      testInfo +\n      nameInfo +\n      contextInfo +\n      chalk.dim('.')\n    );\n  }\n}\n","/Users/simen/repos/jest/packages/jest-reporters/src/VerboseReporter.ts",["202","203","204","205","206"],[],"/**\n * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport chalk = require('chalk');\nimport type {\n  AggregatedResult,\n  AssertionResult,\n  Suite,\n  Test,\n  TestResult,\n} from '@jest/test-result';\nimport type {Config} from '@jest/types';\nimport {formatTime, specialChars} from 'jest-util';\nimport DefaultReporter from './DefaultReporter';\n\nconst {ICONS} = specialChars;\n\nexport default class VerboseReporter extends DefaultReporter {\n  protected override _globalConfig: Config.GlobalConfig;\n\n  static override readonly filename = __filename;\n\n  constructor(globalConfig: Config.GlobalConfig) {\n    super(globalConfig);\n    this._globalConfig = globalConfig;\n  }\n\n  // Verbose mode is for debugging. Buffering of output is undesirable.\n  // See https://github.com/facebook/jest/issues/8208\n  protected override __wrapStdio(\n    stream: NodeJS.WritableStream | NodeJS.WriteStream,\n  ): void {\n    const write = stream.write.bind(stream);\n\n    stream.write = (chunk: string) => {\n      this.__clearStatus();\n      write(chunk);\n      this.__printStatus();\n      return true;\n    };\n  }\n\n  static filterTestResults(\n    testResults: Array<AssertionResult>,\n  ): Array<AssertionResult> {\n    return testResults.filter(({status}) => status !== 'pending');\n  }\n\n  static groupTestsBySuites(testResults: Array<AssertionResult>): Suite {\n    const root: Suite = {suites: [], tests: [], title: ''};\n    testResults.forEach(testResult => {\n      let targetSuite = root;\n\n      // Find the target suite for this test,\n      // creating nested suites as necessary.\n      for (const title of testResult.ancestorTitles) {\n        let matchingSuite = targetSuite.suites.find(s => s.title === title);\n        if (!matchingSuite) {\n          matchingSuite = {suites: [], tests: [], title};\n          targetSuite.suites.push(matchingSuite);\n        }\n        targetSuite = matchingSuite;\n      }\n\n      targetSuite.tests.push(testResult);\n    });\n    return root;\n  }\n\n  override onTestResult(\n    test: Test,\n    result: TestResult,\n    aggregatedResults: AggregatedResult,\n  ): void {\n    super.testFinished(test.context.config, result, aggregatedResults);\n    if (!result.skipped) {\n      this.printTestFileHeader(\n        result.testFilePath,\n        test.context.config,\n        result,\n      );\n      if (!result.testExecError && !result.skipped) {\n        this._logTestResults(result.testResults);\n      }\n      this.printTestFileFailureMessage(\n        result.testFilePath,\n        test.context.config,\n        result,\n      );\n    }\n    super.forceFlushBufferedOutput();\n  }\n\n  private _logTestResults(testResults: Array<AssertionResult>) {\n    this._logSuite(VerboseReporter.groupTestsBySuites(testResults), 0);\n    this._logLine();\n  }\n\n  private _logSuite(suite: Suite, indentLevel: number) {\n    if (suite.title) {\n      this._logLine(suite.title, indentLevel);\n    }\n\n    this._logTests(suite.tests, indentLevel + 1);\n\n    suite.suites.forEach(suite => this._logSuite(suite, indentLevel + 1));\n  }\n\n  private _getIcon(status: string) {\n    if (status === 'failed') {\n      return chalk.red(ICONS.failed);\n    } else if (status === 'pending') {\n      return chalk.yellow(ICONS.pending);\n    } else if (status === 'todo') {\n      return chalk.magenta(ICONS.todo);\n    } else {\n      return chalk.green(ICONS.success);\n    }\n  }\n\n  private _logTest(test: AssertionResult, indentLevel: number) {\n    const status = this._getIcon(test.status);\n    const time = test.duration\n      ? ` (${formatTime(Math.round(test.duration))})`\n      : '';\n    this._logLine(`${status} ${chalk.dim(test.title + time)}`, indentLevel);\n  }\n\n  private _logTests(tests: Array<AssertionResult>, indentLevel: number) {\n    if (this._globalConfig.expand) {\n      tests.forEach(test => this._logTest(test, indentLevel));\n    } else {\n      const summedTests = tests.reduce<{\n        pending: Array<AssertionResult>;\n        todo: Array<AssertionResult>;\n      }>(\n        (result, test) => {\n          if (test.status === 'pending') {\n            result.pending.push(test);\n          } else if (test.status === 'todo') {\n            result.todo.push(test);\n          } else {\n            this._logTest(test, indentLevel);\n          }\n\n          return result;\n        },\n        {pending: [], todo: []},\n      );\n\n      if (summedTests.pending.length > 0) {\n        summedTests.pending.forEach(this._logTodoOrPendingTest(indentLevel));\n      }\n\n      if (summedTests.todo.length > 0) {\n        summedTests.todo.forEach(this._logTodoOrPendingTest(indentLevel));\n      }\n    }\n  }\n\n  private _logTodoOrPendingTest(indentLevel: number) {\n    return (test: AssertionResult): void => {\n      const printedTestStatus =\n        test.status === 'pending' ? 'skipped' : test.status;\n      const icon = this._getIcon(test.status);\n      const text = chalk.dim(`${printedTestStatus} ${test.title}`);\n      this._logLine(`${icon} ${text}`, indentLevel);\n    };\n  }\n\n  private _logLine(str?: string, indentLevel?: number) {\n    const indentation = '  '.repeat(indentLevel || 0);\n    this.log(indentation + (str || ''));\n  }\n}\n","/Users/simen/repos/jest/packages/jest-reporters/src/__tests__/GitHubActionsReporter.test.ts",[],[],"/Users/simen/repos/jest/packages/jest-reporters/src/__tests__/NotifyReporter.test.ts",["207","208","209","210","211","212","213","214","215","216"],[],"/**\n * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport type {AggregatedResult, TestContext} from '@jest/test-result';\nimport {makeGlobalConfig} from '@jest/test-utils';\nimport type {Config} from '@jest/types';\nimport Resolver from 'jest-resolve';\nimport NotifyReporter from '../NotifyReporter';\nimport type {ReporterContext} from '../types';\n\njest.mock('../DefaultReporter');\njest.mock('node-notifier', () => ({\n  notify: jest.fn(),\n}));\n\nconst initialContext: ReporterContext = {\n  firstRun: true,\n  previousSuccess: false,\n  startRun: () => {},\n};\n\nconst aggregatedResultsSuccess = {\n  numFailedTestSuites: 0,\n  numFailedTests: 0,\n  numPassedTestSuites: 1,\n  numPassedTests: 3,\n  numRuntimeErrorTestSuites: 0,\n  numTotalTestSuites: 1,\n  numTotalTests: 3,\n  success: true,\n} as AggregatedResult;\n\nconst aggregatedResultsFailure = {\n  numFailedTestSuites: 1,\n  numFailedTests: 3,\n  numPassedTestSuites: 0,\n  numPassedTests: 9,\n  numRuntimeErrorTestSuites: 0,\n  numTotalTestSuites: 1,\n  numTotalTests: 3,\n  success: false,\n} as AggregatedResult;\n\nconst aggregatedResultsNoTests = {\n  numFailedTestSuites: 0,\n  numFailedTests: 0,\n  numPassedTestSuites: 0,\n  numPassedTests: 0,\n  numPendingTestSuites: 0,\n  numPendingTests: 0,\n  numRuntimeErrorTestSuites: 0,\n  numTotalTestSuites: 0,\n  numTotalTests: 0,\n} as AggregatedResult;\n\n// Simulated sequence of events for NotifyReporter\nconst notifyEvents = [\n  aggregatedResultsNoTests,\n  aggregatedResultsSuccess,\n  aggregatedResultsFailure,\n  aggregatedResultsSuccess,\n  aggregatedResultsSuccess,\n  aggregatedResultsFailure,\n  aggregatedResultsFailure,\n];\n\nconst testModes = ({\n  notifyMode,\n  arl,\n  rootDir,\n  moduleName,\n}: {arl: Array<AggregatedResult>; moduleName?: string} & Pick<\n  Config.GlobalConfig,\n  'notifyMode'\n> &\n  Partial<Pick<Config.ProjectConfig, 'rootDir'>>) => {\n  const notify = require('node-notifier');\n\n  const globalConfig = makeGlobalConfig({notify: true, notifyMode, rootDir});\n\n  let previousContext = initialContext;\n  arl.forEach((ar, i) => {\n    const newContext: ReporterContext = Object.assign(previousContext, {\n      firstRun: i === 0,\n      previousSuccess: previousContext.previousSuccess,\n    });\n    const reporter = new NotifyReporter(globalConfig, newContext);\n    previousContext = newContext;\n    const testContexts = new Set<TestContext>();\n\n    if (moduleName != null) {\n      testContexts.add({\n        hasteFS: {\n          getModuleName() {\n            return moduleName;\n          },\n\n          matchFiles() {\n            return ['package.json'];\n          },\n        },\n      } as unknown as TestContext);\n    }\n\n    reporter.onRunComplete(testContexts, ar);\n\n    if (ar.numTotalTests === 0) {\n      expect(notify.notify).not.toHaveBeenCalled();\n    }\n  });\n\n  const calls: Array<any> = notify.notify.mock.calls;\n  expect(\n    calls.map(([{message, title}]) => ({\n      message: message.replace('\\u26D4\\uFE0F ', '').replace('\\u2705 ', ''),\n      title,\n    })),\n  ).toMatchSnapshot();\n};\n\ntest('test always', () => {\n  testModes({arl: notifyEvents, notifyMode: 'always'});\n});\n\ntest('test success', () => {\n  testModes({arl: notifyEvents, notifyMode: 'success'});\n});\n\ntest('test change', () => {\n  testModes({arl: notifyEvents, notifyMode: 'change'});\n});\n\ntest('test success-change', () => {\n  testModes({arl: notifyEvents, notifyMode: 'success-change'});\n});\n\ntest('test failure-change', () => {\n  testModes({arl: notifyEvents, notifyMode: 'failure-change'});\n});\n\ntest('test always with rootDir', () => {\n  testModes({arl: notifyEvents, notifyMode: 'always', rootDir: 'some-test'});\n});\n\ntest('test success with rootDir', () => {\n  testModes({arl: notifyEvents, notifyMode: 'success', rootDir: 'some-test'});\n});\n\ntest('test change with rootDir', () => {\n  testModes({arl: notifyEvents, notifyMode: 'change', rootDir: 'some-test'});\n});\n\ntest('test success-change with rootDir', () => {\n  testModes({\n    arl: notifyEvents,\n    notifyMode: 'success-change',\n    rootDir: 'some-test',\n  });\n});\n\ntest('test failure-change with rootDir', () => {\n  testModes({\n    arl: notifyEvents,\n    notifyMode: 'failure-change',\n    rootDir: 'some-test',\n  });\n});\n\ntest('test always with moduleName', () => {\n  testModes({\n    arl: notifyEvents,\n    moduleName: 'some-module',\n    notifyMode: 'always',\n  });\n});\n\ntest('test success with moduleName', () => {\n  testModes({\n    arl: notifyEvents,\n    moduleName: 'some-module',\n    notifyMode: 'success',\n  });\n});\n\ntest('test change with moduleName', () => {\n  testModes({\n    arl: notifyEvents,\n    moduleName: 'some-module',\n    notifyMode: 'change',\n  });\n});\n\ntest('test success-change with moduleName', () => {\n  testModes({\n    arl: notifyEvents,\n    moduleName: 'some-module',\n    notifyMode: 'success-change',\n  });\n});\n\ntest('test failure-change with moduleName', () => {\n  testModes({\n    arl: notifyEvents,\n    moduleName: 'some-module',\n    notifyMode: 'failure-change',\n  });\n});\n\ndescribe('node-notifier is an optional dependency', () => {\n  beforeEach(() => {\n    jest.resetModules();\n  });\n\n  const ctor = () => {\n    const globalConfig = makeGlobalConfig({\n      notify: true,\n      notifyMode: 'success',\n      rootDir: 'some-test',\n    });\n    return new NotifyReporter(globalConfig, initialContext);\n  };\n\n  test('without node-notifier uses mock function that throws an error', () => {\n    jest.doMock('node-notifier', () => {\n      throw new Resolver.ModuleNotFoundError(\n        \"Cannot find module 'node-notifier'\",\n      );\n    });\n\n    expect(ctor).toThrow(\n      'notify reporter requires optional peer dependency \"node-notifier\" but it was not found',\n    );\n  });\n\n  test('throws the error when require throws an unexpected error', () => {\n    const error = new Error('unexpected require error');\n    jest.doMock('node-notifier', () => {\n      throw error;\n    });\n    expect(ctor).toThrow(error);\n  });\n\n  test('uses node-notifier when it is available', () => {\n    const mockNodeNotifier = {notify: jest.fn()};\n    jest.doMock('node-notifier', () => mockNodeNotifier);\n    const result = ctor();\n    expect(result._notifier).toBe(mockNodeNotifier);\n  });\n});\n\nafterEach(() => {\n  jest.clearAllMocks();\n});\n","/Users/simen/repos/jest/packages/jest-reporters/src/__tests__/getWatermarks.test.ts",[],[],"/Users/simen/repos/jest/packages/jest-reporters/src/__tests__/utils.test.ts",["217"],[],"/**\n * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport * as path from 'path';\nimport chalk = require('chalk');\nimport stripAnsi = require('strip-ansi');\nimport {makeProjectConfig} from '@jest/test-utils';\nimport printDisplayName from '../printDisplayName';\nimport trimAndFormatPath from '../trimAndFormatPath';\nimport wrapAnsiString from '../wrapAnsiString';\n\ndescribe('wrapAnsiString()', () => {\n  it('wraps a long string containing ansi chars', () => {\n    const string =\n      `abcde ${chalk.red.bold('red-bold')} 1234456` +\n      `${chalk.dim('bcd')} ` +\n      '123ttttttththththththththththththththththththththth' +\n      `tetetetetettetetetetetetetete${chalk.underline.bold('stnhsnthsnth')}` +\n      'ssot';\n    expect(wrapAnsiString(string, 10)).toMatchSnapshot();\n    expect(stripAnsi(wrapAnsiString(string, 10))).toMatchSnapshot();\n  });\n\n  it('returns the string unaltered if given a terminal width of zero', () => {\n    const string = \"This string shouldn't cause you any trouble\";\n    expect(wrapAnsiString(string, 0)).toMatchSnapshot();\n    expect(stripAnsi(wrapAnsiString(string, 0))).toMatchSnapshot();\n  });\n});\n\ndescribe('trimAndFormatPath()', () => {\n  it('trims dirname', () => {\n    const pad = 5;\n    const basename = '1234.js';\n    const dirname = '1234567890/1234567890';\n    const columns = 25;\n    const result = trimAndFormatPath(\n      pad,\n      makeProjectConfig({cwd: '', rootDir: ''}),\n      path.join(dirname, basename),\n      columns,\n    );\n\n    expect(result).toMatchSnapshot();\n    expect(stripAnsi(result)).toHaveLength(20);\n  });\n\n  it('trims dirname (longer line width)', () => {\n    const pad = 5;\n    const basename = '1234.js';\n    const dirname = '1234567890/1234567890';\n    const columns = 30;\n    const result = trimAndFormatPath(\n      pad,\n      makeProjectConfig({cwd: '', rootDir: ''}),\n      path.join(dirname, basename),\n      columns,\n    );\n\n    expect(result).toMatchSnapshot();\n    expect(stripAnsi(result)).toHaveLength(25);\n  });\n\n  it('trims dirname and basename', () => {\n    const pad = 5;\n    const basename = '1234.js';\n    const dirname = '1234567890/1234567890';\n    const columns = 15;\n    const result = trimAndFormatPath(\n      pad,\n      makeProjectConfig({cwd: '', rootDir: ''}),\n      path.join(dirname, basename),\n      columns,\n    );\n\n    expect(result).toMatchSnapshot();\n    expect(stripAnsi(result)).toHaveLength(10);\n  });\n\n  it('does not trim anything', () => {\n    const pad = 5;\n    const basename = '1234.js';\n    const dirname = '1234567890/1234567890';\n    const columns = 50;\n    const totalLength = basename.length + path.sep.length + dirname.length;\n    const result = trimAndFormatPath(\n      pad,\n      makeProjectConfig({cwd: '', rootDir: ''}),\n      path.join(dirname, basename),\n      columns,\n    );\n\n    expect(result).toMatchSnapshot();\n    expect(stripAnsi(result)).toHaveLength(totalLength);\n  });\n\n  test('split at the path.sep index', () => {\n    const pad = 5;\n    const basename = '1234.js';\n    const dirname = '1234567890';\n    const columns = 16;\n    const result = trimAndFormatPath(\n      pad,\n      makeProjectConfig({cwd: '', rootDir: ''}),\n      path.join(dirname, basename),\n      columns,\n    );\n\n    expect(result).toMatchSnapshot();\n    expect(stripAnsi(result)).toHaveLength(columns - pad);\n  });\n});\n\ndescribe('printDisplayName', () => {\n  it('should default displayName color to white when displayName is a string', () => {\n    expect(\n      printDisplayName(\n        makeProjectConfig({\n          displayName: {\n            color: 'white',\n            name: 'hello',\n          },\n        }),\n      ),\n    ).toMatchSnapshot();\n  });\n\n  it('should default displayName color to white when color is not a valid value', () => {\n    expect(\n      printDisplayName(\n        makeProjectConfig({\n          displayName: {\n            color: 'rubbish' as any,\n            name: 'hello',\n          },\n        }),\n      ),\n    ).toMatchSnapshot();\n  });\n\n  it('should correctly print the displayName when color and name are valid values', () => {\n    expect(\n      printDisplayName(\n        makeProjectConfig({\n          displayName: {\n            color: 'green',\n            name: 'hello',\n          },\n        }),\n      ),\n    ).toMatchSnapshot();\n  });\n});\n","/Users/simen/repos/jest/packages/jest-reporters/src/formatTestPath.ts",[],[],"/Users/simen/repos/jest/packages/jest-reporters/src/generateEmptyCoverage.ts",["218","219"],[],"/**\n * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport type {V8Coverage} from 'collect-v8-coverage';\nimport * as fs from 'graceful-fs';\nimport {FileCoverage, createFileCoverage} from 'istanbul-lib-coverage';\nimport {readInitialCoverage} from 'istanbul-lib-instrument';\nimport {createScriptTransformer, shouldInstrument} from '@jest/transform';\nimport type {Config} from '@jest/types';\n\ntype SingleV8Coverage = V8Coverage[number];\n\nexport type CoverageWorkerResult =\n  | {\n      kind: 'BabelCoverage';\n      coverage: FileCoverage;\n    }\n  | {\n      kind: 'V8Coverage';\n      result: SingleV8Coverage;\n    };\n\nexport default async function generateEmptyCoverage(\n  source: string,\n  filename: string,\n  globalConfig: Config.GlobalConfig,\n  config: Config.ProjectConfig,\n  changedFiles?: Set<string>,\n  sourcesRelatedToTestsInChangedFiles?: Set<string>,\n): Promise<CoverageWorkerResult | null> {\n  const coverageOptions = {\n    changedFiles,\n    collectCoverage: globalConfig.collectCoverage,\n    collectCoverageFrom: globalConfig.collectCoverageFrom,\n    coverageProvider: globalConfig.coverageProvider,\n    sourcesRelatedToTestsInChangedFiles,\n  };\n  let coverageWorkerResult: CoverageWorkerResult | null = null;\n  if (shouldInstrument(filename, coverageOptions, config)) {\n    if (coverageOptions.coverageProvider === 'v8') {\n      const stat = fs.statSync(filename);\n      return {\n        kind: 'V8Coverage',\n        result: {\n          functions: [\n            {\n              functionName: '(empty-report)',\n              isBlockCoverage: true,\n              ranges: [\n                {\n                  count: 0,\n                  endOffset: stat.size,\n                  startOffset: 0,\n                },\n              ],\n            },\n          ],\n          scriptId: '0',\n          url: filename,\n        },\n      };\n    }\n\n    const scriptTransformer = await createScriptTransformer(config);\n\n    // Transform file with instrumentation to make sure initial coverage data is well mapped to original code.\n    const {code} = await scriptTransformer.transformSourceAsync(\n      filename,\n      source,\n      {\n        instrument: true,\n        supportsDynamicImport: true,\n        supportsExportNamespaceFrom: true,\n        supportsStaticESM: true,\n        supportsTopLevelAwait: true,\n      },\n    );\n    // TODO: consider passing AST\n    const extracted = readInitialCoverage(code);\n    // Check extracted initial coverage is not null, this can happen when using /* istanbul ignore file */\n    if (extracted) {\n      coverageWorkerResult = {\n        coverage: createFileCoverage(extracted.coverageData),\n        kind: 'BabelCoverage',\n      };\n    }\n  }\n  return coverageWorkerResult;\n}\n","/Users/simen/repos/jest/packages/jest-reporters/src/getResultHeader.ts",["220","221","222"],[],"/**\n * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport chalk = require('chalk');\nimport type {TestResult} from '@jest/test-result';\nimport type {Config} from '@jest/types';\nimport {formatTime} from 'jest-util';\nimport formatTestPath from './formatTestPath';\nimport printDisplayName from './printDisplayName';\n\nconst LONG_TEST_COLOR = chalk.reset.bold.bgRed;\n// Explicitly reset for these messages since they can get written out in the\n// middle of error logging\nconst FAIL_TEXT = 'FAIL';\nconst PASS_TEXT = 'PASS';\n\nconst FAIL = chalk.supportsColor\n  ? chalk.reset.inverse.bold.red(` ${FAIL_TEXT} `)\n  : FAIL_TEXT;\n\nconst PASS = chalk.supportsColor\n  ? chalk.reset.inverse.bold.green(` ${PASS_TEXT} `)\n  : PASS_TEXT;\n\nexport default function getResultHeader(\n  result: TestResult,\n  globalConfig: Config.GlobalConfig,\n  projectConfig?: Config.ProjectConfig,\n): string {\n  const testPath = result.testFilePath;\n  const status =\n    result.numFailingTests > 0 || result.testExecError ? FAIL : PASS;\n\n  const testDetail = [];\n\n  if (result.perfStats?.slow) {\n    const runTime = result.perfStats.runtime / 1000;\n\n    testDetail.push(LONG_TEST_COLOR(formatTime(runTime, 0)));\n  }\n\n  if (result.memoryUsage) {\n    const toMB = (bytes: number) => Math.floor(bytes / 1024 / 1024);\n    testDetail.push(`${toMB(result.memoryUsage)} MB heap size`);\n  }\n\n  const projectDisplayName =\n    projectConfig && projectConfig.displayName\n      ? `${printDisplayName(projectConfig)} `\n      : '';\n\n  return `${status} ${projectDisplayName}${formatTestPath(\n    projectConfig ?? globalConfig,\n    testPath,\n  )}${testDetail.length ? ` (${testDetail.join(', ')})` : ''}`;\n}\n","/Users/simen/repos/jest/packages/jest-reporters/src/getSnapshotStatus.ts",[],[],"/Users/simen/repos/jest/packages/jest-reporters/src/getSnapshotSummary.ts",["223"],[],"/**\n * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport chalk = require('chalk');\nimport type {SnapshotSummary} from '@jest/test-result';\nimport type {Config} from '@jest/types';\nimport {pluralize} from 'jest-util';\nimport formatTestPath from './formatTestPath';\n\nconst ARROW = ' \\u203A ';\nconst DOWN_ARROW = ' \\u21B3 ';\nconst DOT = ' \\u2022 ';\nconst FAIL_COLOR = chalk.bold.red;\nconst OBSOLETE_COLOR = chalk.bold.yellow;\nconst SNAPSHOT_ADDED = chalk.bold.green;\nconst SNAPSHOT_NOTE = chalk.dim;\nconst SNAPSHOT_REMOVED = chalk.bold.green;\nconst SNAPSHOT_SUMMARY = chalk.bold;\nconst SNAPSHOT_UPDATED = chalk.bold.green;\n\nexport default function getSnapshotSummary(\n  snapshots: SnapshotSummary,\n  globalConfig: Config.GlobalConfig,\n  updateCommand: string,\n): Array<string> {\n  const summary = [];\n  summary.push(SNAPSHOT_SUMMARY('Snapshot Summary'));\n  if (snapshots.added) {\n    summary.push(\n      `${SNAPSHOT_ADDED(\n        `${ARROW + pluralize('snapshot', snapshots.added)} written `,\n      )}from ${pluralize('test suite', snapshots.filesAdded)}.`,\n    );\n  }\n\n  if (snapshots.unmatched) {\n    summary.push(\n      `${FAIL_COLOR(\n        `${ARROW}${pluralize('snapshot', snapshots.unmatched)} failed`,\n      )} from ${pluralize(\n        'test suite',\n        snapshots.filesUnmatched,\n      )}. ${SNAPSHOT_NOTE(\n        `Inspect your code changes or ${updateCommand} to update them.`,\n      )}`,\n    );\n  }\n\n  if (snapshots.updated) {\n    summary.push(\n      `${SNAPSHOT_UPDATED(\n        `${ARROW + pluralize('snapshot', snapshots.updated)} updated `,\n      )}from ${pluralize('test suite', snapshots.filesUpdated)}.`,\n    );\n  }\n\n  if (snapshots.filesRemoved) {\n    if (snapshots.didUpdate) {\n      summary.push(\n        `${SNAPSHOT_REMOVED(\n          `${ARROW}${pluralize(\n            'snapshot file',\n            snapshots.filesRemoved,\n          )} removed `,\n        )}from ${pluralize('test suite', snapshots.filesRemoved)}.`,\n      );\n    } else {\n      summary.push(\n        `${OBSOLETE_COLOR(\n          `${ARROW}${pluralize(\n            'snapshot file',\n            snapshots.filesRemoved,\n          )} obsolete `,\n        )}from ${pluralize(\n          'test suite',\n          snapshots.filesRemoved,\n        )}. ${SNAPSHOT_NOTE(\n          `To remove ${\n            snapshots.filesRemoved === 1 ? 'it' : 'them all'\n          }, ${updateCommand}.`,\n        )}`,\n      );\n    }\n  }\n  if (snapshots.filesRemovedList && snapshots.filesRemovedList.length) {\n    const [head, ...tail] = snapshots.filesRemovedList;\n    summary.push(`  ${DOWN_ARROW} ${DOT}${formatTestPath(globalConfig, head)}`);\n\n    tail.forEach(key => {\n      summary.push(`      ${DOT}${formatTestPath(globalConfig, key)}`);\n    });\n  }\n\n  if (snapshots.unchecked) {\n    if (snapshots.didUpdate) {\n      summary.push(\n        `${SNAPSHOT_REMOVED(\n          `${ARROW}${pluralize('snapshot', snapshots.unchecked)} removed `,\n        )}from ${pluralize(\n          'test suite',\n          snapshots.uncheckedKeysByFile.length,\n        )}.`,\n      );\n    } else {\n      summary.push(\n        `${OBSOLETE_COLOR(\n          `${ARROW}${pluralize('snapshot', snapshots.unchecked)} obsolete `,\n        )}from ${pluralize(\n          'test suite',\n          snapshots.uncheckedKeysByFile.length,\n        )}. ${SNAPSHOT_NOTE(\n          `To remove ${\n            snapshots.unchecked === 1 ? 'it' : 'them all'\n          }, ${updateCommand}.`,\n        )}`,\n      );\n    }\n\n    snapshots.uncheckedKeysByFile.forEach(uncheckedFile => {\n      summary.push(\n        `  ${DOWN_ARROW}${formatTestPath(\n          globalConfig,\n          uncheckedFile.filePath,\n        )}`,\n      );\n\n      uncheckedFile.keys.forEach(key => {\n        summary.push(`      ${DOT}${key}`);\n      });\n    });\n  }\n\n  return summary;\n}\n","/Users/simen/repos/jest/packages/jest-reporters/src/getSummary.ts",["224","225","226","227","228","229"],[],"/**\n * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport chalk = require('chalk');\nimport type {AggregatedResult, Test, TestCaseResult} from '@jest/test-result';\nimport {formatTime, pluralize} from 'jest-util';\nimport type {SummaryOptions} from './types';\n\nexport const PROGRESS_BAR_WIDTH = 40;\n\nfunction getValuesCurrentTestCases(\n  currentTestCases: Array<{test: Test; testCaseResult: TestCaseResult}> = [],\n) {\n  let numFailingTests = 0;\n  let numPassingTests = 0;\n  let numPendingTests = 0;\n  let numTodoTests = 0;\n  let numTotalTests = 0;\n  currentTestCases.forEach(testCase => {\n    switch (testCase.testCaseResult.status) {\n      case 'failed': {\n        numFailingTests++;\n        break;\n      }\n      case 'passed': {\n        numPassingTests++;\n        break;\n      }\n      case 'skipped': {\n        numPendingTests++;\n        break;\n      }\n      case 'todo': {\n        numTodoTests++;\n        break;\n      }\n    }\n    numTotalTests++;\n  });\n\n  return {\n    numFailingTests,\n    numPassingTests,\n    numPendingTests,\n    numTodoTests,\n    numTotalTests,\n  };\n}\n\nfunction renderTime(runTime: number, estimatedTime: number, width: number) {\n  // If we are more than one second over the estimated time, highlight it.\n  const renderedTime =\n    estimatedTime && runTime >= estimatedTime + 1\n      ? chalk.bold.yellow(formatTime(runTime, 0))\n      : formatTime(runTime, 0);\n  let time = `${chalk.bold('Time:')}        ${renderedTime}`;\n  if (runTime < estimatedTime) {\n    time += `, estimated ${formatTime(estimatedTime, 0)}`;\n  }\n\n  // Only show a progress bar if the test run is actually going to take\n  // some time.\n  if (estimatedTime > 2 && runTime < estimatedTime && width) {\n    const availableWidth = Math.min(PROGRESS_BAR_WIDTH, width);\n    const length = Math.min(\n      Math.floor((runTime / estimatedTime) * availableWidth),\n      availableWidth,\n    );\n    if (availableWidth >= 2) {\n      time += `\\n${chalk.green('█').repeat(length)}${chalk\n        .white('█')\n        .repeat(availableWidth - length)}`;\n    }\n  }\n  return time;\n}\n\nexport default function getSummary(\n  aggregatedResults: AggregatedResult,\n  options?: SummaryOptions,\n): string {\n  let runTime = (Date.now() - aggregatedResults.startTime) / 1000;\n  if (options && options.roundTime) {\n    runTime = Math.floor(runTime);\n  }\n\n  const valuesForCurrentTestCases = getValuesCurrentTestCases(\n    options?.currentTestCases,\n  );\n\n  const estimatedTime = (options && options.estimatedTime) || 0;\n  const snapshotResults = aggregatedResults.snapshot;\n  const snapshotsAdded = snapshotResults.added;\n  const snapshotsFailed = snapshotResults.unmatched;\n  const snapshotsOutdated = snapshotResults.unchecked;\n  const snapshotsFilesRemoved = snapshotResults.filesRemoved;\n  const snapshotsDidUpdate = snapshotResults.didUpdate;\n  const snapshotsPassed = snapshotResults.matched;\n  const snapshotsTotal = snapshotResults.total;\n  const snapshotsUpdated = snapshotResults.updated;\n  const suitesFailed = aggregatedResults.numFailedTestSuites;\n  const suitesPassed = aggregatedResults.numPassedTestSuites;\n  const suitesPending = aggregatedResults.numPendingTestSuites;\n  const suitesRun = suitesFailed + suitesPassed;\n  const suitesTotal = aggregatedResults.numTotalTestSuites;\n  const testsFailed = aggregatedResults.numFailedTests;\n  const testsPassed = aggregatedResults.numPassedTests;\n  const testsPending = aggregatedResults.numPendingTests;\n  const testsTodo = aggregatedResults.numTodoTests;\n  const testsTotal = aggregatedResults.numTotalTests;\n  const width = (options && options.width) || 0;\n\n  const optionalLines: Array<string> = [];\n\n  if (options?.showSeed === true) {\n    const {seed} = options;\n    if (seed === undefined) {\n      throw new Error('Attempted to display seed but seed value is undefined');\n    }\n    optionalLines.push(`${chalk.bold('Seed:        ') + seed}`);\n  }\n\n  const suites = `${\n    chalk.bold('Test Suites: ') +\n    (suitesFailed ? `${chalk.bold.red(`${suitesFailed} failed`)}, ` : '') +\n    (suitesPending\n      ? `${chalk.bold.yellow(`${suitesPending} skipped`)}, `\n      : '') +\n    (suitesPassed ? `${chalk.bold.green(`${suitesPassed} passed`)}, ` : '') +\n    (suitesRun !== suitesTotal ? `${suitesRun} of ${suitesTotal}` : suitesTotal)\n  } total`;\n\n  const updatedTestsFailed =\n    testsFailed + valuesForCurrentTestCases.numFailingTests;\n  const updatedTestsPending =\n    testsPending + valuesForCurrentTestCases.numPendingTests;\n  const updatedTestsTodo = testsTodo + valuesForCurrentTestCases.numTodoTests;\n  const updatedTestsPassed =\n    testsPassed + valuesForCurrentTestCases.numPassingTests;\n  const updatedTestsTotal =\n    testsTotal + valuesForCurrentTestCases.numTotalTests;\n\n  const tests = `${\n    chalk.bold('Tests:       ') +\n    (updatedTestsFailed > 0\n      ? `${chalk.bold.red(`${updatedTestsFailed} failed`)}, `\n      : '') +\n    (updatedTestsPending > 0\n      ? `${chalk.bold.yellow(`${updatedTestsPending} skipped`)}, `\n      : '') +\n    (updatedTestsTodo > 0\n      ? `${chalk.bold.magenta(`${updatedTestsTodo} todo`)}, `\n      : '') +\n    (updatedTestsPassed > 0\n      ? `${chalk.bold.green(`${updatedTestsPassed} passed`)}, `\n      : '')\n  }${updatedTestsTotal} total`;\n\n  const snapshots = `${\n    chalk.bold('Snapshots:   ') +\n    (snapshotsFailed\n      ? `${chalk.bold.red(`${snapshotsFailed} failed`)}, `\n      : '') +\n    (snapshotsOutdated && !snapshotsDidUpdate\n      ? `${chalk.bold.yellow(`${snapshotsOutdated} obsolete`)}, `\n      : '') +\n    (snapshotsOutdated && snapshotsDidUpdate\n      ? `${chalk.bold.green(`${snapshotsOutdated} removed`)}, `\n      : '') +\n    (snapshotsFilesRemoved && !snapshotsDidUpdate\n      ? `${chalk.bold.yellow(\n          `${pluralize('file', snapshotsFilesRemoved)} obsolete`,\n        )}, `\n      : '') +\n    (snapshotsFilesRemoved && snapshotsDidUpdate\n      ? `${chalk.bold.green(\n          `${pluralize('file', snapshotsFilesRemoved)} removed`,\n        )}, `\n      : '') +\n    (snapshotsUpdated\n      ? `${chalk.bold.green(`${snapshotsUpdated} updated`)}, `\n      : '') +\n    (snapshotsAdded\n      ? `${chalk.bold.green(`${snapshotsAdded} written`)}, `\n      : '') +\n    (snapshotsPassed\n      ? `${chalk.bold.green(`${snapshotsPassed} passed`)}, `\n      : '')\n  }${snapshotsTotal} total`;\n\n  const time = renderTime(runTime, estimatedTime, width);\n\n  return [...optionalLines, suites, tests, snapshots, time].join('\\n');\n}\n","/Users/simen/repos/jest/packages/jest-reporters/src/getWatermarks.ts",["230"],[],"/**\n * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport istanbulReport = require('istanbul-lib-report');\nimport type {Config} from '@jest/types';\n\nexport default function getWatermarks(\n  config: Config.GlobalConfig,\n): istanbulReport.Watermarks {\n  const defaultWatermarks = istanbulReport.getDefaultWatermarks();\n\n  const {coverageThreshold} = config;\n\n  if (!coverageThreshold || !coverageThreshold.global) {\n    return defaultWatermarks;\n  }\n\n  const keys: Array<keyof Config.CoverageThresholdValue> = [\n    'branches',\n    'functions',\n    'lines',\n    'statements',\n  ];\n  return keys.reduce((watermarks, key) => {\n    const value = coverageThreshold.global[key];\n    if (value !== undefined) {\n      watermarks[key][1] = value;\n    }\n\n    return watermarks;\n  }, defaultWatermarks);\n}\n","/Users/simen/repos/jest/packages/jest-reporters/src/index.ts",[],[],"/Users/simen/repos/jest/packages/jest-reporters/src/printDisplayName.ts",["231","232"],[],"/**\n * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport chalk = require('chalk');\nimport type {Config} from '@jest/types';\n\nexport default function printDisplayName(config: Config.ProjectConfig): string {\n  const {displayName} = config;\n  const white = chalk.reset.inverse.white;\n  if (!displayName) {\n    return '';\n  }\n\n  const {name, color} = displayName;\n  const chosenColor = chalk.reset.inverse[color]\n    ? chalk.reset.inverse[color]\n    : white;\n  return chalk.supportsColor ? chosenColor(` ${name} `) : name;\n}\n","/Users/simen/repos/jest/packages/jest-reporters/src/relativePath.ts",[],[],"/Users/simen/repos/jest/packages/jest-reporters/src/trimAndFormatPath.ts",[],[],"/Users/simen/repos/jest/packages/jest-reporters/src/types.ts",[],[],"/Users/simen/repos/jest/packages/jest-reporters/src/wrapAnsiString.ts",[],[],"/Users/simen/repos/jest/packages/jest-reporters/src/__tests__/getSummary.test.ts",[],[],{"ruleId":"233","severity":2,"message":"234","line":35,"column":72,"nodeType":"235","messageId":"236","endLine":35,"endColumn":74,"suppressions":"237"},{"ruleId":"233","severity":2,"message":"238","line":41,"column":11,"nodeType":"235","messageId":"236","endLine":41,"endColumn":13,"suppressions":"239"},{"ruleId":"233","severity":2,"message":"240","line":43,"column":35,"nodeType":"235","messageId":"236","endLine":43,"endColumn":37,"suppressions":"241"},{"ruleId":"233","severity":2,"message":"242","line":48,"column":27,"nodeType":"235","messageId":"236","endLine":48,"endColumn":29,"suppressions":"243"},{"ruleId":"244","severity":2,"message":"245","line":76,"column":33,"nodeType":"246","messageId":"247","endLine":76,"endColumn":69},{"ruleId":"248","severity":2,"message":"249","line":98,"column":18,"nodeType":"250","messageId":"251","endLine":98,"endColumn":30},{"ruleId":"252","severity":2,"message":"253","line":98,"column":18,"nodeType":"246","messageId":"254","endLine":98,"endColumn":28},{"ruleId":"255","severity":2,"message":"256","line":98,"column":18,"nodeType":"246","messageId":"257","endLine":98,"endColumn":28},{"ruleId":"248","severity":2,"message":"249","line":99,"column":18,"nodeType":"246","messageId":"251","endLine":99,"endColumn":25},{"ruleId":"252","severity":2,"message":"258","line":99,"column":18,"nodeType":"246","messageId":"254","endLine":99,"endColumn":25},{"ruleId":"244","severity":2,"message":"245","line":115,"column":9,"nodeType":"246","messageId":"247","endLine":115,"endColumn":47},{"ruleId":"259","severity":2,"message":"260","line":147,"column":7,"nodeType":"261","messageId":"262","endLine":147,"endColumn":43},{"ruleId":"244","severity":2,"message":"245","line":167,"column":10,"nodeType":"246","messageId":"247","endLine":167,"endColumn":42},{"ruleId":"248","severity":2,"message":"249","line":199,"column":27,"nodeType":"246","messageId":"251","endLine":199,"endColumn":40},{"ruleId":"252","severity":2,"message":"263","line":199,"column":27,"nodeType":"246","messageId":"254","endLine":199,"endColumn":40},{"ruleId":"248","severity":2,"message":"249","line":200,"column":27,"nodeType":"246","messageId":"251","endLine":200,"endColumn":38},{"ruleId":"252","severity":2,"message":"258","line":200,"column":27,"nodeType":"246","messageId":"254","endLine":200,"endColumn":38},{"ruleId":"244","severity":2,"message":"245","line":218,"column":9,"nodeType":"264","messageId":"247","endLine":218,"endColumn":15},{"ruleId":"244","severity":2,"message":"265","line":451,"column":13,"nodeType":"266","messageId":"267","endLine":451,"endColumn":41,"suggestions":"268"},{"ruleId":"259","severity":2,"message":"260","line":454,"column":13,"nodeType":"261","messageId":"262","endLine":456,"endColumn":14},{"ruleId":"269","severity":2,"message":"270","line":500,"column":21,"nodeType":"246","messageId":"271","endLine":500,"endColumn":54},{"ruleId":"244","severity":2,"message":"265","line":237,"column":9,"nodeType":"246","messageId":"267","endLine":237,"endColumn":30,"suggestions":"272"},{"ruleId":"269","severity":2,"message":"270","line":242,"column":30,"nodeType":"246","messageId":"271","endLine":242,"endColumn":38},{"ruleId":"248","severity":2,"message":"273","line":81,"column":27,"nodeType":"264","messageId":"251","endLine":81,"endColumn":31},{"ruleId":"248","severity":2,"message":"274","line":81,"column":40,"nodeType":"264","messageId":"251","endLine":81,"endColumn":44},{"ruleId":"259","severity":2,"message":"260","line":43,"column":11,"nodeType":"275","messageId":"262","endLine":44,"endColumn":71},{"ruleId":"244","severity":2,"message":"245","line":44,"column":7,"nodeType":"264","messageId":"247","endLine":44,"endColumn":19},{"ruleId":"244","severity":2,"message":"276","line":44,"column":23,"nodeType":"246","messageId":"277","endLine":44,"endColumn":41,"suggestions":"278"},{"ruleId":"252","severity":2,"message":"279","line":44,"column":45,"nodeType":"246","messageId":"254","endLine":44,"endColumn":71},{"ruleId":"259","severity":2,"message":"260","line":49,"column":13,"nodeType":"275","messageId":"262","endLine":49,"endColumn":60},{"ruleId":"252","severity":2,"message":"280","line":49,"column":26,"nodeType":"246","messageId":"254","endLine":49,"endColumn":44},{"ruleId":"255","severity":2,"message":"256","line":49,"column":26,"nodeType":"246","messageId":"257","endLine":49,"endColumn":44},{"ruleId":"259","severity":2,"message":"260","line":51,"column":7,"nodeType":"261","messageId":"262","endLine":54,"endColumn":39},{"ruleId":"252","severity":2,"message":"281","line":53,"column":13,"nodeType":"246","messageId":"254","endLine":53,"endColumn":34},{"ruleId":"255","severity":2,"message":"256","line":53,"column":13,"nodeType":"246","messageId":"257","endLine":53,"endColumn":34},{"ruleId":"248","severity":2,"message":"249","line":59,"column":44,"nodeType":"264","messageId":"251","endLine":59,"endColumn":55},{"ruleId":"282","severity":2,"message":"283","line":160,"column":5,"nodeType":"284","messageId":"285","endLine":160,"endColumn":37},{"ruleId":"252","severity":2,"message":"286","line":162,"column":9,"nodeType":"246","messageId":"254","endLine":162,"endColumn":17},{"ruleId":"287","severity":2,"message":"288","line":55,"column":44,"nodeType":"289","messageId":"290","endLine":55,"endColumn":46,"suggestions":"291"},{"ruleId":"244","severity":2,"message":"245","line":106,"column":28,"nodeType":"264","messageId":"247","endLine":106,"endColumn":35},{"ruleId":"244","severity":2,"message":"245","line":107,"column":24,"nodeType":"264","messageId":"247","endLine":107,"endColumn":31},{"ruleId":"244","severity":2,"message":"292","line":95,"column":10,"nodeType":"246","messageId":"293","endLine":95,"endColumn":36,"suggestions":"294"},{"ruleId":"244","severity":2,"message":"245","line":96,"column":9,"nodeType":"264","messageId":"247","endLine":96,"endColumn":19},{"ruleId":"244","severity":2,"message":"292","line":116,"column":14,"nodeType":"246","messageId":"293","endLine":116,"endColumn":39,"suggestions":"295"},{"ruleId":"244","severity":2,"message":"265","line":140,"column":21,"nodeType":"264","messageId":"267","endLine":140,"endColumn":40,"suggestions":"296"},{"ruleId":"287","severity":2,"message":"288","line":140,"column":41,"nodeType":"289","messageId":"290","endLine":140,"endColumn":43,"suggestions":"297"},{"ruleId":"269","severity":2,"message":"270","line":165,"column":31,"nodeType":"246","messageId":"271","endLine":165,"endColumn":39},{"ruleId":"244","severity":2,"message":"265","line":186,"column":13,"nodeType":"264","messageId":"267","endLine":186,"endColumn":27,"suggestions":"298"},{"ruleId":"244","severity":2,"message":"265","line":225,"column":16,"nodeType":"246","messageId":"267","endLine":225,"endColumn":44,"suggestions":"299"},{"ruleId":"300","severity":2,"message":"301","line":233,"column":11,"nodeType":"302","messageId":"303","endLine":233,"endColumn":48},{"ruleId":"244","severity":2,"message":"304","line":127,"column":18,"nodeType":"246","messageId":"305","endLine":127,"endColumn":31,"suggestions":"306"},{"ruleId":"244","severity":2,"message":"304","line":176,"column":37,"nodeType":"264","messageId":"305","endLine":176,"endColumn":48,"suggestions":"307"},{"ruleId":"287","severity":2,"message":"288","line":176,"column":49,"nodeType":"289","messageId":"290","endLine":176,"endColumn":51,"suggestions":"308"},{"ruleId":"244","severity":2,"message":"265","line":177,"column":29,"nodeType":"264","messageId":"267","endLine":177,"endColumn":32,"suggestions":"309"},{"ruleId":"287","severity":2,"message":"288","line":177,"column":33,"nodeType":"289","messageId":"290","endLine":177,"endColumn":35,"suggestions":"310"},{"ruleId":"259","severity":2,"message":"260","line":81,"column":9,"nodeType":"275","messageId":"262","endLine":81,"endColumn":42},{"ruleId":"252","severity":2,"message":"311","line":112,"column":14,"nodeType":"246","messageId":"254","endLine":112,"endColumn":27},{"ruleId":"259","severity":2,"message":"260","line":116,"column":9,"nodeType":"275","messageId":"262","endLine":116,"endColumn":53},{"ruleId":"252","severity":2,"message":"311","line":116,"column":29,"nodeType":"246","messageId":"254","endLine":116,"endColumn":42},{"ruleId":"259","severity":2,"message":"260","line":119,"column":7,"nodeType":"312","messageId":"262","endLine":119,"endColumn":75},{"ruleId":"252","severity":2,"message":"313","line":119,"column":16,"nodeType":"246","messageId":"254","endLine":119,"endColumn":60},{"ruleId":"255","severity":2,"message":"256","line":119,"column":16,"nodeType":"246","messageId":"257","endLine":119,"endColumn":60},{"ruleId":"252","severity":2,"message":"313","line":119,"column":16,"nodeType":"246","messageId":"254","endLine":119,"endColumn":31},{"ruleId":"255","severity":2,"message":"256","line":119,"column":16,"nodeType":"246","messageId":"257","endLine":119,"endColumn":31},{"ruleId":"259","severity":2,"message":"260","line":120,"column":7,"nodeType":"312","messageId":"262","endLine":120,"endColumn":12},{"ruleId":"259","severity":2,"message":"260","line":137,"column":13,"nodeType":"312","messageId":"262","endLine":137,"endColumn":36},{"ruleId":"244","severity":2,"message":"245","line":85,"column":9,"nodeType":"264","messageId":"247","endLine":85,"endColumn":18},{"ruleId":"314","severity":2,"message":"315","line":87,"column":38,"nodeType":"246","messageId":"316","endLine":87,"endColumn":60},{"ruleId":"244","severity":2,"message":"317","line":21,"column":14,"nodeType":"246","messageId":"318","endLine":21,"endColumn":33},{"ruleId":"244","severity":2,"message":"317","line":25,"column":14,"nodeType":"246","messageId":"318","endLine":25,"endColumn":33},{"ruleId":"244","severity":2,"message":"304","line":46,"column":7,"nodeType":"246","messageId":"305","endLine":46,"endColumn":25,"suggestions":"319"},{"ruleId":"244","severity":2,"message":"245","line":89,"column":7,"nodeType":"246","messageId":"247","endLine":89,"endColumn":33},{"ruleId":"320","severity":2,"message":"321","line":24,"column":13,"nodeType":"246","messageId":"322","endLine":24,"endColumn":43,"suggestions":"323"},{"ruleId":"244","severity":2,"message":"292","line":87,"column":18,"nodeType":"246","messageId":"293","endLine":87,"endColumn":35,"suggestions":"324"},{"ruleId":"244","severity":2,"message":"304","line":95,"column":37,"nodeType":"246","messageId":"305","endLine":95,"endColumn":58,"suggestions":"325"},{"ruleId":"244","severity":2,"message":"304","line":115,"column":29,"nodeType":"246","messageId":"305","endLine":115,"endColumn":42,"suggestions":"326"},{"ruleId":"300","severity":2,"message":"301","line":124,"column":27,"nodeType":"302","messageId":"303","endLine":124,"endColumn":61},{"ruleId":"300","severity":2,"message":"301","line":128,"column":5,"nodeType":"302","messageId":"303","endLine":134,"endColumn":81},{"ruleId":"244","severity":2,"message":"245","line":18,"column":30,"nodeType":"246","messageId":"247","endLine":18,"endColumn":54},{"ruleId":"244","severity":2,"message":"245","line":19,"column":23,"nodeType":"246","messageId":"247","endLine":19,"endColumn":49},{"ruleId":"244","severity":2,"message":"317","line":22,"column":10,"nodeType":"246","messageId":"318","endLine":22,"endColumn":29},"@typescript-eslint/no-empty-function","Unexpected empty method 'onTestCaseResult'.","FunctionExpression","unexpected",["327"],"Unexpected empty method 'onTestResult'.",["328"],"Unexpected empty method 'onTestStart'.",["329"],"Unexpected empty method 'onRunComplete'.",["330"],"@typescript-eslint/strict-boolean-expressions","Unexpected object value in conditional. The condition is always true.","MemberExpression","conditionErrorObject","@typescript-eslint/restrict-template-expressions","Invalid type \"any\" of template literal expression.","CallExpression","invalidType","@typescript-eslint/no-unsafe-member-access","Unsafe member access .toString on an `any` value.","unsafeMemberExpression","@typescript-eslint/no-unsafe-call","Unsafe call of an `any` typed value.","unsafeCall","Unsafe member access .stack on an `any` value.","@typescript-eslint/no-unsafe-assignment","Unsafe assignment of an `any` value.","AssignmentExpression","anyAssignment","Unsafe member access .message on an `any` value.","Identifier","Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.","ChainExpression","conditionErrorNullableString",["331","332","333"],"@typescript-eslint/unbound-method","Avoid referencing unbound methods which may cause unintentional scoping of `this`.\nIf your function does not access `this`, you can annotate it with `this: void`, or consider using an arrow function instead.","unboundWithoutThisAnnotation",["334","335","336"],"Invalid type \"string | undefined\" of template literal expression.","Invalid type \"string | number | undefined\" of template literal expression.","VariableDeclarator","Unexpected any value in conditional. An explicit comparison or type cast is required.","conditionErrorAny",["337"],"Unsafe member access .hasteFS on an `any` value.","Unsafe member access .matchFiles on an `any` value.","Unsafe member access .getModuleName on an `any` value.","@typescript-eslint/no-unsafe-return","Unsafe return of an `any` typed value.","ReturnStatement","unsafeReturn","Unsafe member access .code on an `any` value.","@typescript-eslint/prefer-nullish-coalescing","Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.","Punctuator","preferNullishOverOr",["338"],"Unexpected nullable boolean value in conditional. Please handle the nullish case explicitly.","conditionErrorNullableBoolean",["339","340"],["341","342"],["343","344","345"],["346"],["347","348","349"],["350","351","352"],"@typescript-eslint/restrict-plus-operands","Operands of '+' operation must either be both strings or both numbers. Consider using a template literal.","BinaryExpression","notStrings","Unexpected nullable number value in conditional. Please handle the nullish/zero/NaN cases explicitly.","conditionErrorNullableNumber",["353","354","355"],["356","357","358"],["359"],["360","361","362"],["363"],"Unsafe member access .notify on an `any` value.","Property","Unsafe member access .replace on an `any` value.","@typescript-eslint/no-unsafe-argument","Unsafe argument of type `any` assigned to a parameter of type `string | FileCoverage | FileCoverageData`.","unsafeArgument","Unexpected value in conditional. A boolean expression is required.","conditionErrorOther",["364","365","366"],"@typescript-eslint/switch-exhaustiveness-check","Switch is not exhaustive. Cases not matched: \"pending\" | \"disabled\"","switchIsNotExhaustive",["367"],["368","369"],["370","371","372"],["373","374","375"],{"kind":"376","justification":"377"},{"kind":"376","justification":"377"},{"kind":"376","justification":"377"},{"kind":"376","justification":"377"},{"messageId":"378","fix":"379","desc":"380"},{"messageId":"381","fix":"382","desc":"383"},{"messageId":"384","fix":"385","desc":"386"},{"messageId":"378","fix":"387","desc":"380"},{"messageId":"381","fix":"388","desc":"383"},{"messageId":"384","fix":"389","desc":"386"},{"messageId":"384","fix":"390","desc":"386"},{"messageId":"391","fix":"392","desc":"393"},{"messageId":"394","fix":"395","desc":"396"},{"messageId":"397","fix":"398","desc":"399"},{"messageId":"394","fix":"400","desc":"396"},{"messageId":"397","fix":"401","desc":"399"},{"messageId":"378","fix":"402","desc":"380"},{"messageId":"381","fix":"403","desc":"383"},{"messageId":"384","fix":"404","desc":"386"},{"messageId":"391","fix":"405","desc":"393"},{"messageId":"378","fix":"406","desc":"380"},{"messageId":"381","fix":"407","desc":"383"},{"messageId":"384","fix":"408","desc":"386"},{"messageId":"378","fix":"409","desc":"380"},{"messageId":"381","fix":"410","desc":"383"},{"messageId":"384","fix":"411","desc":"386"},{"messageId":"378","fix":"412","desc":"380"},{"messageId":"413","fix":"414","desc":"415"},{"messageId":"384","fix":"416","desc":"386"},{"messageId":"378","fix":"417","desc":"380"},{"messageId":"413","fix":"418","desc":"415"},{"messageId":"384","fix":"419","desc":"386"},{"messageId":"391","fix":"420","desc":"393"},{"messageId":"378","fix":"421","desc":"380"},{"messageId":"381","fix":"422","desc":"383"},{"messageId":"384","fix":"423","desc":"386"},{"messageId":"391","fix":"424","desc":"393"},{"messageId":"378","fix":"425","desc":"380"},{"messageId":"413","fix":"426","desc":"415"},{"messageId":"384","fix":"427","desc":"386"},{"messageId":"428","fix":"429","desc":"430"},{"messageId":"394","fix":"431","desc":"396"},{"messageId":"432","fix":"433","desc":"434"},{"messageId":"378","fix":"435","desc":"380"},{"messageId":"413","fix":"436","desc":"415"},{"messageId":"384","fix":"437","desc":"386"},{"messageId":"378","fix":"438","desc":"380"},{"messageId":"413","fix":"439","desc":"415"},{"messageId":"384","fix":"440","desc":"386"},"directive","","conditionFixCompareNullish",{"range":"441","text":"442"},"Change condition to check for null/undefined (`value != null`)","conditionFixDefaultEmptyString",{"range":"441","text":"443"},"Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)","conditionFixCastBoolean",{"range":"441","text":"444"},"Explicitly cast value to a boolean (`Boolean(value)`)",{"range":"445","text":"446"},{"range":"445","text":"447"},{"range":"445","text":"448"},{"range":"449","text":"450"},"suggestNullish",{"range":"451","text":"452"},"Fix to nullish coalescing operator (`??`).","conditionFixDefaultFalse",{"range":"453","text":"454"},"Explicitly treat nullish value the same as false (`value ?? false`)","conditionFixCompareFalse",{"range":"455","text":"456"},"Change condition to check if false (`value === false`)",{"range":"457","text":"458"},{"range":"459","text":"460"},{"range":"461","text":"462"},{"range":"461","text":"463"},{"range":"461","text":"464"},{"range":"465","text":"452"},{"range":"466","text":"467"},{"range":"466","text":"468"},{"range":"466","text":"469"},{"range":"470","text":"471"},{"range":"470","text":"472"},{"range":"470","text":"473"},{"range":"474","text":"475"},"conditionFixDefaultZero",{"range":"474","text":"476"},"Explicitly treat nullish value the same as 0 (`value ?? 0`)",{"range":"474","text":"477"},{"range":"478","text":"479"},{"range":"478","text":"480"},{"range":"478","text":"481"},{"range":"482","text":"452"},{"range":"483","text":"484"},{"range":"483","text":"485"},{"range":"483","text":"486"},{"range":"487","text":"452"},{"range":"488","text":"489"},{"range":"488","text":"490"},{"range":"488","text":"491"},"addMissingCases",{"range":"492","text":"493"},"Add branches for missing cases.",{"range":"494","text":"495"},"conditionFixCompareTrue",{"range":"494","text":"496"},"Change condition to check if true (`value === true`)",{"range":"497","text":"498"},{"range":"497","text":"499"},{"range":"497","text":"500"},{"range":"501","text":"502"},{"range":"501","text":"503"},{"range":"501","text":"504"},[14868,14896],"((fileTransform?.sourceMapPath) != null)","((fileTransform?.sourceMapPath) ?? \"\")","(Boolean((fileTransform?.sourceMapPath)))",[6536,6557],"result.failureMessage != null","result.failureMessage ?? \"\"","Boolean(result.failureMessage)",[1359,1377],"(Boolean(firstContext.value))",[1559,1561],"??",[2650,2676],"(this._globalConfig.verbose ?? false)",[2649,2676],"(this._globalConfig.verbose === false)",[3237,3262],"(this._globalConfig.silent ?? false)",[3236,3262],"this._globalConfig.silent === false",[3832,3851],"(npm_lifecycle_event != null)","(npm_lifecycle_event ?? \"\")","(Boolean(npm_lifecycle_event))",[3852,3854],[5452,5466],"failureMessage != null","failureMessage ?? \"\"","Boolean(failureMessage)",[6516,6544],"globalConfig.testNamePattern != null","globalConfig.testNamePattern ?? \"\"","Boolean(globalConfig.testNamePattern)",[3610,3623],"(test.duration != null)","(test.duration ?? 0)","(Boolean(test.duration))",[5172,5183],"(indentLevel != null)","(indentLevel ?? 0)","(Boolean(indentLevel))",[5184,5186],[5219,5222],"(str != null)","(str ?? \"\")","(Boolean(str))",[5223,5225],[1345,1363],"result.memoryUsage != null","result.memoryUsage ?? 0","Boolean(result.memoryUsage)",[1079,1079],"\n      case \"pending\": { throw new Error('Not implemented yet: \"pending\" case') }\n      case \"disabled\": { throw new Error('Not implemented yet: \"disabled\" case') }",[2415,2432],"(options.roundTime ?? false)","(options.roundTime === true)",[2612,2633],"(options.estimatedTime != null)","(options.estimatedTime ?? 0)","(Boolean(options.estimatedTime))",[3721,3734],"(options.width != null)","(options.width ?? 0)","(Boolean(options.width))"]